; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\fstaticrender.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@MLKAHID@L_dynamic_pos@			; `string'
PUBLIC	??_C@_0BA@FNHAPCAE@L_dynamic_color@		; `string'
PUBLIC	??_C@_0BA@PCGAPDHO@L_dynamic_xform@		; `string'
PUBLIC	??_C@_0L@CBIMIPPL@?9nodistort@			; `string'
PUBLIC	??_C@_0M@JGJOANLK@unavailable@			; `string'
PUBLIC	??_C@_0CD@DCBDPIBM@?$CK?5distortion?3?5?$CFs?0?5dev?$CI?$CFd?$CJ?0need?$CI@ ; `string'
PUBLIC	??_C@_07BDKAKIOP@?9disasm@			; `string'
PUBLIC	??_C@_06MLLEPAHM@?9skinw@			; `string'
PUBLIC	??_C@_0BA@FMJGKLOA@L_dynamic_props@		; `string'
PUBLIC	??_C@_0BI@HOANMMBE@CRender?3?3model_CreatePE@	; `string'
PUBLIC	??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0BO@PKGKJKHO@Particle?5effect?5doesn?8t?5exist@ ; `string'
PUBLIC	??_C@_02ODEKANEE@SE@				; `string'
PUBLIC	??_C@_0BP@GFBDPMDM@CRender?3?3model_CreateParticles@ ; `string'
PUBLIC	??_C@_0CH@CNEGHEIB@Particle?5effect?5or?5group?5doesn?8@ ; `string'
PUBLIC	??_C@_02NBHMGPMG@SG@				; `string'
PUBLIC	??_C@_0BK@OKMDHAJE@?5?$CK?$CK?$CK?$CK?5Occ?9Q?$CI?$CF03?41f?$CJ?5?$CK?$CK?$CK?$CK?5@ ; `string'
PUBLIC	??_C@_0O@OKFLLHFA@?5total?5?5?3?5?$CF2d@	; `string'
PUBLIC	??_C@_0O@CFLPMGDN@?5culled?5?3?5?$CF2d@		; `string'
PUBLIC	??_C@_0P@IMLOOCAI@$game_shaders$@		; `string'
PUBLIC	??_C@_06FBCGDMPM@?$CB?5PS?3?5@			; `string'
PUBLIC	??_C@_0CB@LMOENIDG@?$CB?5CreatePixelShader?5hr?5?$DN?$DN?50x?$CF08@ ; `string'
PUBLIC	??_C@_0CF@PIPNAOIB@?$CB?5D3DXFindShaderComment?5hr?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_06NOGGMJFM@?$CB?5VS?3?5@			; `string'
PUBLIC	??_C@_03MKDIMGDJ@?4vs@				; `string'
PUBLIC	??_C@_03MOLFLKIL@?4ps@				; `string'
PUBLIC	??_C@_07NGDNODCK@disasm?2@			; `string'
PUBLIC	??_C@_0BA@BDJNLMJI@$app_data_root$@		; `string'
PUBLIC	??_C@_0L@PJCDFAEI@SKIN_COLOR@			; `string'
PUBLIC	??_C@_09BOBBOPBB@SKIN_NONE@			; `string'
PUBLIC	??_C@_06IDLPGDEM@SKIN_0@			; `string'
PUBLIC	??_C@_06JKKEFCAN@SKIN_1@			; `string'
PUBLIC	??_C@_06LBIJABMO@SKIN_2@			; `string'
PUBLIC	??_C@_0BI@NLEBJGLM@CRender?3?3shader_compile@	; `string'
PUBLIC	??_C@_0N@KDLHPIAJ@def_it?5?$DM?5128@		; `string'
PUBLIC	??_C@_0M@MCOCEOGP@objects?2r1?2@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@		; `string'
PUBLIC	??_C@_02KMLFCOJI@?$CB?5@			; `string'
PUBLIC	??_C@_0M@LHHOJELD@?$CB?5Warning?3?5@		; `string'
PUBLIC	??_C@_0BP@OMCFLODH@?$CB?5Can?8t?5compile?5shader?3?5?$CFs?0?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@DCAGGEAG@SUCCEEDED?$CI_result?$CJ@	; `string'
PUBLIC	??_C@_09EFHBAOK@?$CB?5Error?3?5@		; `string'
PUBLIC	??_C@_0BP@CEIAODPN@Can?8t?5compile?5shader?5hr?$DN0x?$CF08x@ ; `string'
PUBLIC	??_C@_0N@GPBBBEHJ@match_shader@			; `string'
PUBLIC	??_C@_0CE@HAHBDCPG@bad?5cache?5for?5shader?5?$CFs?0?5?$FL?$CFs?$FN?0?5@ ; `string'
PUBLIC	??_C@_0CF@MFPDANGH@full_shader_id_length?5?$DN?$DN?5mask_l@ ; `string'
PUBLIC	??_R2includer@@8				; includer::`RTTI Base Class Array'
PUBLIC	??_R2cl_light_XFORM@@8				; cl_light_XFORM::`RTTI Base Class Array'
PUBLIC	??_R2cl_light_C@@8				; cl_light_C::`RTTI Base Class Array'
PUBLIC	??_R2cl_light_PR@@8				; cl_light_PR::`RTTI Base Class Array'
PUBLIC	??_R2R_constant_setup@@8			; R_constant_setup::`RTTI Base Class Array'
PUBLIC	??_R2CRender@@8					; CRender::`RTTI Base Class Array'
PUBLIC	??_R2ID3DXInclude@@8				; ID3DXInclude::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@includer@@8			; includer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@cl_light_XFORM@@8			; cl_light_XFORM::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@cl_light_C@@8			; cl_light_C::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@cl_light_PR@@8			; cl_light_PR::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@R_constant_setup@@8		; R_constant_setup::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CRender@@8			; CRender::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ID3DXInclude@@8			; ID3DXInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3includer@@8				; includer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVincluder@@@8				; includer `RTTI Type Descriptor'
PUBLIC	??_R3cl_light_XFORM@@8				; cl_light_XFORM::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVcl_light_XFORM@@@8			; cl_light_XFORM `RTTI Type Descriptor'
PUBLIC	??_R3cl_light_C@@8				; cl_light_C::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVcl_light_C@@@8				; cl_light_C `RTTI Type Descriptor'
PUBLIC	??_R3R_constant_setup@@8			; R_constant_setup::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVR_constant_setup@@@8			; R_constant_setup `RTTI Type Descriptor'
PUBLIC	??_R3cl_light_PR@@8				; cl_light_PR::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVcl_light_PR@@@8				; cl_light_PR `RTTI Type Descriptor'
PUBLIC	??_R3CRender@@8					; CRender::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCRender@@@8				; CRender `RTTI Type Descriptor'
PUBLIC	??_R3ID3DXInclude@@8				; ID3DXInclude::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUID3DXInclude@@@8			; ID3DXInclude `RTTI Type Descriptor'
PUBLIC	??_R4includer@@6B@				; includer::`RTTI Complete Object Locator'
PUBLIC	??_R4cl_light_XFORM@@6B@			; cl_light_XFORM::`RTTI Complete Object Locator'
PUBLIC	??_R4cl_light_C@@6B@				; cl_light_C::`RTTI Complete Object Locator'
PUBLIC	??_R4cl_light_PR@@6B@				; cl_light_PR::`RTTI Complete Object Locator'
PUBLIC	??_R4CRender@@6BpureFrame@@@			; CRender::`RTTI Complete Object Locator'
PUBLIC	??_C@_03CMCKNFAL@r1?2@				; `string'
PUBLIC	??_R4CRender@@6BIRender_interface@@@		; CRender::`RTTI Complete Object Locator'
PUBLIC	?did_init@?1??init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ@4_NA ; `boost::detail::crc_table_t<32,79764919,1>::init_table'::`2'::did_init
PUBLIC	?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA ; boost::detail::crc_table_t<32,79764919,1>::table_
PUBLIC	??_7includer@@6B@				; includer::`vftable'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R0?AVCGlow@@@8				; CGlow `RTTI Type Descriptor'
PUBLIC	??_7cl_light_XFORM@@6B@				; cl_light_XFORM::`vftable'
PUBLIC	??_7cl_light_C@@6B@				; cl_light_C::`vftable'
PUBLIC	??_7cl_light_PR@@6B@				; cl_light_PR::`vftable'
PUBLIC	??_7CRender@@6BpureFrame@@@			; CRender::`vftable'
PUBLIC	??_7CRender@@6BIRender_interface@@@		; CRender::`vftable'
PUBLIC	??_R4R_dsgraph_structure@@6BIRender_interface@@@ ; R_dsgraph_structure::`RTTI Complete Object Locator'
PUBLIC	??_7R_dsgraph_structure@@6BIRender_interface@@@	; R_dsgraph_structure::`vftable'
PUBLIC	??_R0?AVR_dsgraph_structure@@@8			; R_dsgraph_structure `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@R_dsgraph_structure@@8		; R_dsgraph_structure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVIRender_interface@@@8			; IRender_interface `RTTI Type Descriptor'
PUBLIC	??_R2IRender_interface@@8			; IRender_interface::`RTTI Base Class Array'
PUBLIC	??_R3IRender_interface@@8			; IRender_interface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@IRender_interface@@8		; IRender_interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVpureFrame@@@8				; pureFrame `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@pureFrame@@8			; pureFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2pureFrame@@8				; pureFrame::`RTTI Base Class Array'
PUBLIC	??_R3pureFrame@@8				; pureFrame::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1BAA@?0A@EA@pureFrame@@8			; pureFrame::`RTTI Base Class Descriptor at (256,-1,0,64)'
PUBLIC	??_R2R_dsgraph_structure@@8			; R_dsgraph_structure::`RTTI Base Class Array'
PUBLIC	??_R3R_dsgraph_structure@@8			; R_dsgraph_structure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4R_dsgraph_structure@@6BpureFrame@@@	; R_dsgraph_structure::`RTTI Complete Object Locator'
PUBLIC	??_7R_dsgraph_structure@@6BpureFrame@@@		; R_dsgraph_structure::`vftable'
PUBLIC	?g_fSCREEN@@3MA					; g_fSCREEN
EXTRN	__imp_?ROS@CObject@@QAEPAVIRender_ObjectSpecific@@XZ:PROC
EXTRN	__imp_??0R_constant_setup@@QAE@XZ:PROC
EXTRN	__imp_?_inc@?$resptr_base@VIRender_Glow@@@@IAEXXZ:PROC
EXTRN	__imp_??1FS_File@@QAE@XZ:PROC
EXTRN	__imp__strncpy_s:PROC
EXTRN	__imp_?_REG_Compare@@YAHPBX0@Z:PROC
EXTRN	__imp__qsort:PROC
EXTRN	__imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_?fail@xrDebug@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H0AA_N@Z:PROC
EXTRN	__imp__D3DXCompileShader@40:PROC
EXTRN	__imp_?file_list@CLocatorAPI@@QAEHAAV?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@PBDI1@Z:PROC
EXTRN	__imp__D3DXDisassembleShader@16:PROC
EXTRN	__imp_?parse@R_constant_table@@QAEHPAXG@Z:PROC
EXTRN	__imp__D3DXFindShaderComment@16:PROC
EXTRN	__imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD0@Z:PROC
EXTRN	__imp_?OutSkip@CGameFont@@QAEXM@Z:PROC
EXTRN	__imp_?OutNext@CGameFont@@QAAXPBDZZ:PROC
EXTRN	__imp_?RenderLast@CEnvironment@@QAEXXZ:PROC
EXTRN	__imp_?RenderFlares@CEnvironment@@QAEXXZ:PROC
EXTRN	__imp_?RenderClouds@CEnvironment@@QAEXXZ:PROC
EXTRN	__imp_?RenderSky@CEnvironment@@QAEXXZ:PROC
EXTRN	__imp_?spatial_updatesector_internal@ISpatial@@QAEXXZ:PROC
EXTRN	__imp_?spatial_updatesector@ISpatial@@QAEXXZ:PROC
EXTRN	__imp_?CurrentViewEntity@IGame_Level@@QBEPAVCObject@@XZ:PROC
EXTRN	__imp_??_7R_constant_setup@@6B@:QWORD
EXTRN	__imp_??_7IRender_interface@@6B@:BYTE
EXTRN	__imp_??0IRender_interface@@QAE@XZ:PROC
EXTRN	__imp_??1IRender_interface@@UAE@XZ:PROC
EXTRN	__imp_??_7pureFrame@@6B@:QWORD
EXTRN	__imp_??0pureFrame@@QAE@XZ:PROC
EXTRN	?Statistics@IRender_interface@@UAEXPAVCGameFont@@@Z:PROC ; IRender_interface::Statistics
EXTRN	__imp_?Statistics@IRender_interface@@UAEXPAVCGameFont@@@Z:PROC
EXTRN	?light_destroy@IRender_interface@@UAEXPAVIRender_Light@@@Z:PROC ; IRender_interface::light_destroy
EXTRN	__imp_?light_destroy@IRender_interface@@UAEXPAVIRender_Light@@@Z:PROC
EXTRN	?glow_destroy@IRender_interface@@UAEXPAVIRender_Glow@@@Z:PROC ; IRender_interface::glow_destroy
EXTRN	__imp_?glow_destroy@IRender_interface@@UAEXPAVIRender_Glow@@@Z:PROC
EXTRN	__imp_?getMask@CFrustum@@QBEIXZ:PROC
EXTRN	__imp_?fail@xrDebug@@QAEXPBD000H0AA_N@Z:PROC
EXTRN	__imp_?RegisterConstantSetup@CResourceManager@@QAEXPBDPAVR_constant_setup@@@Z:PROC
EXTRN	__imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ:PROC
;	COMDAT ?did_init@?1??init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ@4_NA
_BSS	SEGMENT
?did_init@?1??init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ@4_NA DB 01H DUP (?) ; `boost::detail::crc_table_t<32,79764919,1>::init_table'::`2'::did_init
_BSS	ENDS
;	COMDAT ?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA
_BSS	SEGMENT
?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA DD 0100H DUP (?) ; boost::detail::crc_table_t<32,79764919,1>::table_
_BSS	ENDS
;	COMDAT ?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA DB 01H DUP (?) ; `match_shader'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?DC@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?DC@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA DB 01H DUP (?) ; `CRender::shader_compile'::`50'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BF@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BF@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA DB 01H DUP (?) ; `CRender::shader_compile'::`21'::ignore_always
?g_fSCREEN@@3MA DD 01H DUP (?)				; g_fSCREEN
_BSS	ENDS
;	COMDAT ?ignore_always@?7??model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::model_CreateParticles'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA DB 01H DUP (?) ; `CRender::model_CreatePE'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_7R_dsgraph_structure@@6BpureFrame@@@
CONST	SEGMENT
??_7R_dsgraph_structure@@6BpureFrame@@@ DD FLAT:??_R4R_dsgraph_structure@@6BpureFrame@@@ ; R_dsgraph_structure::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4R_dsgraph_structure@@6BpureFrame@@@
rdata$r	SEGMENT
??_R4R_dsgraph_structure@@6BpureFrame@@@ DD 00H		; R_dsgraph_structure::`RTTI Complete Object Locator'
	DD	0100H
	DD	00H
	DD	FLAT:??_R0?AVR_dsgraph_structure@@@8
	DD	FLAT:??_R3R_dsgraph_structure@@8
rdata$r	ENDS
;	COMDAT ??_R3R_dsgraph_structure@@8
rdata$r	SEGMENT
??_R3R_dsgraph_structure@@8 DD 00H			; R_dsgraph_structure::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2R_dsgraph_structure@@8
rdata$r	ENDS
;	COMDAT ??_R2R_dsgraph_structure@@8
rdata$r	SEGMENT
??_R2R_dsgraph_structure@@8 DD FLAT:??_R1A@?0A@EA@R_dsgraph_structure@@8 ; R_dsgraph_structure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_interface@@8
	DD	FLAT:??_R1BAA@?0A@EA@pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R1BAA@?0A@EA@pureFrame@@8
rdata$r	SEGMENT
??_R1BAA@?0A@EA@pureFrame@@8 DD FLAT:??_R0?AVpureFrame@@@8 ; pureFrame::`RTTI Base Class Descriptor at (256,-1,0,64)'
	DD	00H
	DD	0100H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R3pureFrame@@8
rdata$r	SEGMENT
??_R3pureFrame@@8 DD 00H				; pureFrame::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R2pureFrame@@8
rdata$r	SEGMENT
??_R2pureFrame@@8 DD FLAT:??_R1A@?0A@EA@pureFrame@@8	; pureFrame::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@pureFrame@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@pureFrame@@8 DD FLAT:??_R0?AVpureFrame@@@8 ; pureFrame::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpureFrame@@@8
data$rs	SEGMENT
??_R0?AVpureFrame@@@8 DD FLAT:??_7type_info@@6B@	; pureFrame `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpureFrame@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_interface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_interface@@8 DD FLAT:??_R0?AVIRender_interface@@@8 ; IRender_interface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_interface@@8
rdata$r	ENDS
;	COMDAT ??_R3IRender_interface@@8
rdata$r	SEGMENT
??_R3IRender_interface@@8 DD 00H			; IRender_interface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_interface@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_interface@@8
rdata$r	SEGMENT
??_R2IRender_interface@@8 DD FLAT:??_R1A@?0A@EA@IRender_interface@@8 ; IRender_interface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_interface@@@8
data$rs	SEGMENT
??_R0?AVIRender_interface@@@8 DD FLAT:??_7type_info@@6B@ ; IRender_interface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_interface@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@R_dsgraph_structure@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@R_dsgraph_structure@@8 DD FLAT:??_R0?AVR_dsgraph_structure@@@8 ; R_dsgraph_structure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3R_dsgraph_structure@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVR_dsgraph_structure@@@8
data$rs	SEGMENT
??_R0?AVR_dsgraph_structure@@@8 DD FLAT:??_7type_info@@6B@ ; R_dsgraph_structure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVR_dsgraph_structure@@', 00H
data$rs	ENDS
;	COMDAT ??_7R_dsgraph_structure@@6BIRender_interface@@@
CONST	SEGMENT
??_7R_dsgraph_structure@@6BIRender_interface@@@ DD FLAT:??_R4R_dsgraph_structure@@6BIRender_interface@@@ ; R_dsgraph_structure::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Statistics@IRender_interface@@UAEXPAVCGameFont@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z
	DD	FLAT:?set_HUD@R_dsgraph_structure@@UAEXH@Z
	DD	FLAT:?get_HUD@R_dsgraph_structure@@UAEHXZ
	DD	FLAT:?set_Invisible@R_dsgraph_structure@@UAEXH@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?light_destroy@IRender_interface@@UAEXPAVIRender_Light@@@Z
	DD	FLAT:__purecall
	DD	FLAT:?glow_destroy@IRender_interface@@UAEXPAVIRender_Glow@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?memory_usage@R_dsgraph_structure@@UAEIXZ
	DD	FLAT:??_ER_dsgraph_structure@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4R_dsgraph_structure@@6BIRender_interface@@@
rdata$r	SEGMENT
??_R4R_dsgraph_structure@@6BIRender_interface@@@ DD 00H	; R_dsgraph_structure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVR_dsgraph_structure@@@8
	DD	FLAT:??_R3R_dsgraph_structure@@8
rdata$r	ENDS
;	COMDAT ??_7CRender@@6BIRender_interface@@@
CONST	SEGMENT
??_7CRender@@6BIRender_interface@@@ DD FLAT:??_R4CRender@@6BIRender_interface@@@ ; CRender::`vftable'
	DD	FLAT:?get_generation@CRender@@UAE?AW4GenerationLevel@IRender_interface@@XZ
	DD	FLAT:?create@CRender@@UAEXXZ
	DD	FLAT:?destroy@CRender@@UAEXXZ
	DD	FLAT:?reset_begin@CRender@@UAEXXZ
	DD	FLAT:?reset_end@CRender@@UAEXXZ
	DD	FLAT:?level_Load@CRender@@UAEXPAVIReader@@@Z
	DD	FLAT:?level_Unload@CRender@@UAEXXZ
	DD	FLAT:?texture_load@CRender@@UAEPAUIDirect3DBaseTexture9@@PBDAAI@Z
	DD	FLAT:?shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z
	DD	FLAT:?Statistics@CRender@@UAEXPAVCGameFont@@@Z
	DD	FLAT:?getShaderPath@CRender@@UAEPBDXZ
	DD	FLAT:?getShader@CRender@@UAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@H@Z
	DD	FLAT:?getSector@CRender@@UAEPAVIRender_Sector@@H@Z
	DD	FLAT:?getVisual@CRender@@UAEPAVIRender_Visual@@H@Z
	DD	FLAT:?detectSector@CRender@@UAEPAVIRender_Sector@@ABU?$_vector3@M@@@Z
	DD	FLAT:?getTarget@CRender@@UAEPAVIRender_Target@@XZ
	DD	FLAT:?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z
	DD	FLAT:?set_HUD@R_dsgraph_structure@@UAEXH@Z
	DD	FLAT:?get_HUD@R_dsgraph_structure@@UAEHXZ
	DD	FLAT:?set_Invisible@R_dsgraph_structure@@UAEXH@Z
	DD	FLAT:?flush@CRender@@UAEXXZ
	DD	FLAT:?set_Object@CRender@@UAEXPAVIRenderable@@@Z
	DD	FLAT:?add_Occluder@CRender@@UAEXAAV?$_box2@M@@@Z
	DD	FLAT:?add_Visual@CRender@@UAEXPAVIRender_Visual@@@Z
	DD	FLAT:?add_Geometry@CRender@@UAEXPAVIRender_Visual@@@Z
	DD	FLAT:?add_StaticWallmark@CRender@@UAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@MPAVTRI@CDB@@PAU3@@Z
	DD	FLAT:?clear_static_wallmarks@CRender@@UAEXXZ
	DD	FLAT:?add_SkeletonWallmark@CRender@@UAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z
	DD	FLAT:?add_SkeletonWallmark@CRender@@UAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
	DD	FLAT:?blender_create@CRender@@UAEPAVIBlender@@_K@Z
	DD	FLAT:?blender_destroy@CRender@@UAEXAAPAVIBlender@@@Z
	DD	FLAT:?ros_create@CRender@@UAEPAVIRender_ObjectSpecific@@PAVIRenderable@@@Z
	DD	FLAT:?ros_destroy@CRender@@UAEXAAPAVIRender_ObjectSpecific@@@Z
	DD	FLAT:?light_create@CRender@@UAEPAVIRender_Light@@XZ
	DD	FLAT:?light_destroy@IRender_interface@@UAEXPAVIRender_Light@@@Z
	DD	FLAT:?glow_create@CRender@@UAEPAVIRender_Glow@@XZ
	DD	FLAT:?glow_destroy@IRender_interface@@UAEXPAVIRender_Glow@@@Z
	DD	FLAT:?model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z
	DD	FLAT:?model_CreateDM@CRender@@UAEPAVIRender_DetailModel@@PAVIReader@@@Z
	DD	FLAT:?model_Create@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z
	DD	FLAT:?model_CreateChild@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z
	DD	FLAT:?model_Duplicate@CRender@@UAEPAVIRender_Visual@@PAV2@@Z
	DD	FLAT:?model_Delete@CRender@@UAEXAAPAVIRender_DetailModel@@@Z
	DD	FLAT:?model_Delete@CRender@@UAEXAAPAVIRender_Visual@@H@Z
	DD	FLAT:?model_Logging@CRender@@UAEXH@Z
	DD	FLAT:?models_Prefetch@CRender@@UAEXXZ
	DD	FLAT:?models_Clear@CRender@@UAEXH@Z
	DD	FLAT:?occ_visible@CRender@@UAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z
	DD	FLAT:?occ_visible@CRender@@UAEHAAV?$_box3@M@@@Z
	DD	FLAT:?occ_visible@CRender@@UAEHAAUvis_data@@@Z
	DD	FLAT:?Calculate@CRender@@UAEXXZ
	DD	FLAT:?Render@CRender@@UAEXXZ
	DD	FLAT:?Screenshot@CRender@@UAEXW4ScreenshotMode@IRender_interface@@PBD@Z
	DD	FLAT:?rmNear@CRender@@UAEXXZ
	DD	FLAT:?rmFar@CRender@@UAEXXZ
	DD	FLAT:?rmNormal@CRender@@UAEXXZ
	DD	FLAT:?memory_usage@R_dsgraph_structure@@UAEIXZ
	DD	FLAT:??_ECRender@@UAEPAXI@Z
	DD	FLAT:?ps_library@CRender@@UAEPAVCPSLibrary@@XZ
CONST	ENDS
;	COMDAT ??_7CRender@@6BpureFrame@@@
CONST	SEGMENT
??_7CRender@@6BpureFrame@@@ DD FLAT:??_R4CRender@@6BpureFrame@@@ ; CRender::`vftable'
	DD	FLAT:?OnFrame@CRender@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7cl_light_PR@@6B@
CONST	SEGMENT
??_7cl_light_PR@@6B@ DD FLAT:??_R4cl_light_PR@@6B@	; cl_light_PR::`vftable'
	DD	FLAT:?setup@cl_light_PR@@EAEXPAUR_constant@@@Z
CONST	ENDS
;	COMDAT ??_7cl_light_C@@6B@
CONST	SEGMENT
??_7cl_light_C@@6B@ DD FLAT:??_R4cl_light_C@@6B@	; cl_light_C::`vftable'
	DD	FLAT:?setup@cl_light_C@@EAEXPAUR_constant@@@Z
CONST	ENDS
;	COMDAT ??_7cl_light_XFORM@@6B@
CONST	SEGMENT
??_7cl_light_XFORM@@6B@ DD FLAT:??_R4cl_light_XFORM@@6B@ ; cl_light_XFORM::`vftable'
	DD	FLAT:?setup@cl_light_XFORM@@EAEXPAUR_constant@@@Z
CONST	ENDS
;	COMDAT ??_R0?AVCGlow@@@8
data$r	SEGMENT
??_R0?AVCGlow@@@8 DD FLAT:??_7type_info@@6B@		; CGlow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGlow@@', 00H
data$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7includer@@6B@
CONST	SEGMENT
??_7includer@@6B@ DD FLAT:??_R4includer@@6B@		; includer::`vftable'
	DD	FLAT:?Open@includer@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
	DD	FLAT:?Close@includer@@UAGJPBX@Z
CONST	ENDS
;	COMDAT ??_R4CRender@@6BIRender_interface@@@
rdata$r	SEGMENT
??_R4CRender@@6BIRender_interface@@@ DD 00H		; CRender::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRender@@@8
	DD	FLAT:??_R3CRender@@8
rdata$r	ENDS
;	COMDAT ??_C@_03CMCKNFAL@r1?2@
CONST	SEGMENT
??_C@_03CMCKNFAL@r1?2@ DB 'r1\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R4CRender@@6BpureFrame@@@
rdata$r	SEGMENT
??_R4CRender@@6BpureFrame@@@ DD 00H			; CRender::`RTTI Complete Object Locator'
	DD	0100H
	DD	00H
	DD	FLAT:??_R0?AVCRender@@@8
	DD	FLAT:??_R3CRender@@8
rdata$r	ENDS
;	COMDAT ??_R4cl_light_PR@@6B@
rdata$r	SEGMENT
??_R4cl_light_PR@@6B@ DD 00H				; cl_light_PR::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcl_light_PR@@@8
	DD	FLAT:??_R3cl_light_PR@@8
rdata$r	ENDS
;	COMDAT ??_R4cl_light_C@@6B@
rdata$r	SEGMENT
??_R4cl_light_C@@6B@ DD 00H				; cl_light_C::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcl_light_C@@@8
	DD	FLAT:??_R3cl_light_C@@8
rdata$r	ENDS
;	COMDAT ??_R4cl_light_XFORM@@6B@
rdata$r	SEGMENT
??_R4cl_light_XFORM@@6B@ DD 00H				; cl_light_XFORM::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcl_light_XFORM@@@8
	DD	FLAT:??_R3cl_light_XFORM@@8
rdata$r	ENDS
;	COMDAT ??_R4includer@@6B@
rdata$r	SEGMENT
??_R4includer@@6B@ DD 00H				; includer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVincluder@@@8
	DD	FLAT:??_R3includer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUID3DXInclude@@@8
data$rs	SEGMENT
??_R0?AUID3DXInclude@@@8 DD FLAT:??_7type_info@@6B@	; ID3DXInclude `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUID3DXInclude@@', 00H
data$rs	ENDS
;	COMDAT ??_R3ID3DXInclude@@8
rdata$r	SEGMENT
??_R3ID3DXInclude@@8 DD 00H				; ID3DXInclude::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRender@@@8
data$rs	SEGMENT
??_R0?AVCRender@@@8 DD FLAT:??_7type_info@@6B@		; CRender `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRender@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CRender@@8
rdata$r	SEGMENT
??_R3CRender@@8 DD 00H					; CRender::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2CRender@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcl_light_PR@@@8
data$rs	SEGMENT
??_R0?AVcl_light_PR@@@8 DD FLAT:??_7type_info@@6B@	; cl_light_PR `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcl_light_PR@@', 00H
data$rs	ENDS
;	COMDAT ??_R3cl_light_PR@@8
rdata$r	SEGMENT
??_R3cl_light_PR@@8 DD 00H				; cl_light_PR::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2cl_light_PR@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVR_constant_setup@@@8
data$rs	SEGMENT
??_R0?AVR_constant_setup@@@8 DD FLAT:??_7type_info@@6B@	; R_constant_setup `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVR_constant_setup@@', 00H
data$rs	ENDS
;	COMDAT ??_R3R_constant_setup@@8
rdata$r	SEGMENT
??_R3R_constant_setup@@8 DD 00H				; R_constant_setup::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2R_constant_setup@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcl_light_C@@@8
data$rs	SEGMENT
??_R0?AVcl_light_C@@@8 DD FLAT:??_7type_info@@6B@	; cl_light_C `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcl_light_C@@', 00H
data$rs	ENDS
;	COMDAT ??_R3cl_light_C@@8
rdata$r	SEGMENT
??_R3cl_light_C@@8 DD 00H				; cl_light_C::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2cl_light_C@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcl_light_XFORM@@@8
data$rs	SEGMENT
??_R0?AVcl_light_XFORM@@@8 DD FLAT:??_7type_info@@6B@	; cl_light_XFORM `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcl_light_XFORM@@', 00H
data$rs	ENDS
;	COMDAT ??_R3cl_light_XFORM@@8
rdata$r	SEGMENT
??_R3cl_light_XFORM@@8 DD 00H				; cl_light_XFORM::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2cl_light_XFORM@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVincluder@@@8
data$rs	SEGMENT
??_R0?AVincluder@@@8 DD FLAT:??_7type_info@@6B@		; includer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVincluder@@', 00H
data$rs	ENDS
;	COMDAT ??_R3includer@@8
rdata$r	SEGMENT
??_R3includer@@8 DD 00H					; includer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2includer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ID3DXInclude@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ID3DXInclude@@8 DD FLAT:??_R0?AUID3DXInclude@@@8 ; ID3DXInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRender@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRender@@8 DD FLAT:??_R0?AVCRender@@@8	; CRender::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRender@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@R_constant_setup@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@R_constant_setup@@8 DD FLAT:??_R0?AVR_constant_setup@@@8 ; R_constant_setup::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3R_constant_setup@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@cl_light_PR@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@cl_light_PR@@8 DD FLAT:??_R0?AVcl_light_PR@@@8 ; cl_light_PR::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3cl_light_PR@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@cl_light_C@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@cl_light_C@@8 DD FLAT:??_R0?AVcl_light_C@@@8 ; cl_light_C::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3cl_light_C@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@cl_light_XFORM@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@cl_light_XFORM@@8 DD FLAT:??_R0?AVcl_light_XFORM@@@8 ; cl_light_XFORM::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3cl_light_XFORM@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@includer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@includer@@8 DD FLAT:??_R0?AVincluder@@@8	; includer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3includer@@8
rdata$r	ENDS
;	COMDAT ??_R2ID3DXInclude@@8
rdata$r	SEGMENT
??_R2ID3DXInclude@@8 DD FLAT:??_R1A@?0A@EA@ID3DXInclude@@8 ; ID3DXInclude::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CRender@@8
rdata$r	SEGMENT
??_R2CRender@@8 DD FLAT:??_R1A@?0A@EA@CRender@@8	; CRender::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@R_dsgraph_structure@@8
	DD	FLAT:??_R1A@?0A@EA@IRender_interface@@8
	DD	FLAT:??_R1BAA@?0A@EA@pureFrame@@8
rdata$r	ENDS
;	COMDAT ??_R2R_constant_setup@@8
rdata$r	SEGMENT
??_R2R_constant_setup@@8 DD FLAT:??_R1A@?0A@EA@R_constant_setup@@8 ; R_constant_setup::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2cl_light_PR@@8
rdata$r	SEGMENT
??_R2cl_light_PR@@8 DD FLAT:??_R1A@?0A@EA@cl_light_PR@@8 ; cl_light_PR::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@R_constant_setup@@8
rdata$r	ENDS
;	COMDAT ??_R2cl_light_C@@8
rdata$r	SEGMENT
??_R2cl_light_C@@8 DD FLAT:??_R1A@?0A@EA@cl_light_C@@8	; cl_light_C::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@R_constant_setup@@8
rdata$r	ENDS
;	COMDAT ??_R2cl_light_XFORM@@8
rdata$r	SEGMENT
??_R2cl_light_XFORM@@8 DD FLAT:??_R1A@?0A@EA@cl_light_XFORM@@8 ; cl_light_XFORM::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@R_constant_setup@@8
rdata$r	ENDS
;	COMDAT ??_R2includer@@8
rdata$r	SEGMENT
??_R2includer@@8 DD FLAT:??_R1A@?0A@EA@includer@@8	; includer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CF@MFPDANGH@full_shader_id_length?5?$DN?$DN?5mask_l@
CONST	SEGMENT
??_C@_0CF@MFPDANGH@full_shader_id_length?5?$DN?$DN?5mask_l@ DB 'full_shad'
	DB	'er_id_length == mask_length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HAHBDCPG@bad?5cache?5for?5shader?5?$CFs?0?5?$FL?$CFs?$FN?0?5@
CONST	SEGMENT
??_C@_0CE@HAHBDCPG@bad?5cache?5for?5shader?5?$CFs?0?5?$FL?$CFs?$FN?0?5@ DB 'b'
	DB	'ad cache for shader %s, [%s], [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GPBBBEHJ@match_shader@
CONST	SEGMENT
??_C@_0N@GPBBBEHJ@match_shader@ DB 'match_shader', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CEIAODPN@Can?8t?5compile?5shader?5hr?$DN0x?$CF08x@
CONST	SEGMENT
??_C@_0BP@CEIAODPN@Can?8t?5compile?5shader?5hr?$DN0x?$CF08x@ DB 'Can''t c'
	DB	'ompile shader hr=0x%08x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFHBAOK@?$CB?5Error?3?5@
CONST	SEGMENT
??_C@_09EFHBAOK@?$CB?5Error?3?5@ DB '! Error: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCAGGEAG@SUCCEEDED?$CI_result?$CJ@
CONST	SEGMENT
??_C@_0BD@DCAGGEAG@SUCCEEDED?$CI_result?$CJ@ DB 'SUCCEEDED(_result)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OMCFLODH@?$CB?5Can?8t?5compile?5shader?3?5?$CFs?0?5?$CFs@
CONST	SEGMENT
??_C@_0BP@OMCFLODH@?$CB?5Can?8t?5compile?5shader?3?5?$CFs?0?5?$CFs@ DB '!'
	DB	' Can''t compile shader: %s, %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHHOJELD@?$CB?5Warning?3?5@
CONST	SEGMENT
??_C@_0M@LHHOJELD@?$CB?5Warning?3?5@ DB '! Warning: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMLFCOJI@?$CB?5@
CONST	SEGMENT
??_C@_02KMLFCOJI@?$CB?5@ DB '! ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@
CONST	SEGMENT
??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@ DB 'shaders_cache\r1\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCOCEOGP@objects?2r1?2@
CONST	SEGMENT
??_C@_0M@MCOCEOGP@objects?2r1?2@ DB 'objects\r1\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLHPIAJ@def_it?5?$DM?5128@
CONST	SEGMENT
??_C@_0N@KDLHPIAJ@def_it?5?$DM?5128@ DB 'def_it < 128', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NLEBJGLM@CRender?3?3shader_compile@
CONST	SEGMENT
??_C@_0BI@NLEBJGLM@CRender?3?3shader_compile@ DB 'CRender::shader_compile'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06LBIJABMO@SKIN_2@
CONST	SEGMENT
??_C@_06LBIJABMO@SKIN_2@ DB 'SKIN_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKKEFCAN@SKIN_1@
CONST	SEGMENT
??_C@_06JKKEFCAN@SKIN_1@ DB 'SKIN_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IDLPGDEM@SKIN_0@
CONST	SEGMENT
??_C@_06IDLPGDEM@SKIN_0@ DB 'SKIN_0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BOBBOPBB@SKIN_NONE@
CONST	SEGMENT
??_C@_09BOBBOPBB@SKIN_NONE@ DB 'SKIN_NONE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJCDFAEI@SKIN_COLOR@
CONST	SEGMENT
??_C@_0L@PJCDFAEI@SKIN_COLOR@ DB 'SKIN_COLOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BDJNLMJI@$app_data_root$@
CONST	SEGMENT
??_C@_0BA@BDJNLMJI@$app_data_root$@ DB '$app_data_root$', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGDNODCK@disasm?2@
CONST	SEGMENT
??_C@_07NGDNODCK@disasm?2@ DB 'disasm\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MOLFLKIL@?4ps@
CONST	SEGMENT
??_C@_03MOLFLKIL@?4ps@ DB '.ps', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MKDIMGDJ@?4vs@
CONST	SEGMENT
??_C@_03MKDIMGDJ@?4vs@ DB '.vs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOGGMJFM@?$CB?5VS?3?5@
CONST	SEGMENT
??_C@_06NOGGMJFM@?$CB?5VS?3?5@ DB '! VS: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PIPNAOIB@?$CB?5D3DXFindShaderComment?5hr?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CF@PIPNAOIB@?$CB?5D3DXFindShaderComment?5hr?5?$DN?$DN?50@ DB '! D3'
	DB	'DXFindShaderComment hr == 0x%08x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LMOENIDG@?$CB?5CreatePixelShader?5hr?5?$DN?$DN?50x?$CF08@
CONST	SEGMENT
??_C@_0CB@LMOENIDG@?$CB?5CreatePixelShader?5hr?5?$DN?$DN?50x?$CF08@ DB '!'
	DB	' CreatePixelShader hr == 0x%08x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FBCGDMPM@?$CB?5PS?3?5@
CONST	SEGMENT
??_C@_06FBCGDMPM@?$CB?5PS?3?5@ DB '! PS: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMLOOCAI@$game_shaders$@
CONST	SEGMENT
??_C@_0P@IMLOOCAI@$game_shaders$@ DB '$game_shaders$', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFLPMGDN@?5culled?5?3?5?$CF2d@
CONST	SEGMENT
??_C@_0O@CFLPMGDN@?5culled?5?3?5?$CF2d@ DB ' culled : %2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OKFLLHFA@?5total?5?5?3?5?$CF2d@
CONST	SEGMENT
??_C@_0O@OKFLLHFA@?5total?5?5?3?5?$CF2d@ DB ' total  : %2d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OKMDHAJE@?5?$CK?$CK?$CK?$CK?5Occ?9Q?$CI?$CF03?41f?$CJ?5?$CK?$CK?$CK?$CK?5@
CONST	SEGMENT
??_C@_0BK@OKMDHAJE@?5?$CK?$CK?$CK?$CK?5Occ?9Q?$CI?$CF03?41f?$CJ?5?$CK?$CK?$CK?$CK?5@ DB ' '
	DB	'**** Occ-Q(%03.1f) **** ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMGPMG@SG@
CONST	SEGMENT
??_C@_02NBHMGPMG@SG@ DB 'SG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CNEGHEIB@Particle?5effect?5or?5group?5doesn?8@
CONST	SEGMENT
??_C@_0CH@CNEGHEIB@Particle?5effect?5or?5group?5doesn?8@ DB 'Particle eff'
	DB	'ect or group doesn''t exist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GFBDPMDM@CRender?3?3model_CreateParticles@
CONST	SEGMENT
??_C@_0BP@GFBDPMDM@CRender?3?3model_CreateParticles@ DB 'CRender::model_C'
	DB	'reateParticles', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKANEE@SE@
CONST	SEGMENT
??_C@_02ODEKANEE@SE@ DB 'SE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PKGKJKHO@Particle?5effect?5doesn?8t?5exist@
CONST	SEGMENT
??_C@_0BO@PKGKJKHO@Particle?5effect?5doesn?8t?5exist@ DB 'Particle effect'
	DB	' doesn''t exist', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HOANMMBE@CRender?3?3model_CreatePE@
CONST	SEGMENT
??_C@_0BI@HOANMMBE@CRender?3?3model_CreatePE@ DB 'CRender::model_CreatePE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMJGKLOA@L_dynamic_props@
CONST	SEGMENT
??_C@_0BA@FMJGKLOA@L_dynamic_props@ DB 'L_dynamic_props', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLLEPAHM@?9skinw@
CONST	SEGMENT
??_C@_06MLLEPAHM@?9skinw@ DB '-skinw', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BDKAKIOP@?9disasm@
CONST	SEGMENT
??_C@_07BDKAKIOP@?9disasm@ DB '-disasm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DCBDPIBM@?$CK?5distortion?3?5?$CFs?0?5dev?$CI?$CFd?$CJ?0need?$CI@
CONST	SEGMENT
??_C@_0CD@DCBDPIBM@?$CK?5distortion?3?5?$CFs?0?5dev?$CI?$CFd?$CJ?0need?$CI@ DB '*'
	DB	' distortion: %s, dev(%d),need(%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGJOANLK@unavailable@
CONST	SEGMENT
??_C@_0M@JGJOANLK@unavailable@ DB 'unavailable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CBIMIPPL@?9nodistort@
CONST	SEGMENT
??_C@_0L@CBIMIPPL@?9nodistort@ DB '-nodistort', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCGAPDHO@L_dynamic_xform@
CONST	SEGMENT
??_C@_0BA@PCGAPDHO@L_dynamic_xform@ DB 'L_dynamic_xform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FNHAPCAE@L_dynamic_color@
CONST	SEGMENT
??_C@_0BA@FNHAPCAE@L_dynamic_color@ DB 'L_dynamic_color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLKAHID@L_dynamic_pos@
CONST	SEGMENT
??_C@_0O@MLKAHID@L_dynamic_pos@ DB 'L_dynamic_pos', 00H	; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?shadowing@CLightProjector@@QAEHXZ		; CLightProjector::shadowing
PUBLIC	?r_dsgraph_destroy@R_dsgraph_structure@@QAEXXZ	; R_dsgraph_structure::r_dsgraph_destroy
PUBLIC	?destroy@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::destroy
PUBLIC	?last@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::last
PUBLIC	?begin@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::begin
PUBLIC	?destroy@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::destroy
PUBLIC	?last@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::last
PUBLIC	?begin@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::begin
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapMatrixPS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixPS::~mapMatrixPS
PUBLIC	??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapMatrixCS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixCS::~mapMatrixCS
PUBLIC	??1?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapMatrixStates@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixStates::~mapMatrixStates
PUBLIC	??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapMatrixTextures@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixTextures::~mapMatrixTextures
PUBLIC	??1?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapMatrixItems@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixItems::~mapMatrixItems
PUBLIC	??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	??1?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >
PUBLIC	?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Tidy
PUBLIC	?last@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::last
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapNormalPS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalPS::~mapNormalPS
PUBLIC	??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapNormalCS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalCS::~mapNormalCS
PUBLIC	??1?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapNormalStates@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalStates::~mapNormalStates
PUBLIC	??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapNormalTextures@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalTextures::~mapNormalTextures
PUBLIC	??1?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>
PUBLIC	?destroy@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::destroy
PUBLIC	??_GTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::`scalar deleting destructor'
PUBLIC	??1TNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::~TNode
PUBLIC	??1mapNormalItems@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalItems::~mapNormalItems
PUBLIC	??1?$xr_vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	??1?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >
PUBLIC	?_Tidy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXXZ ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Tidy
PUBLIC	?last@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::last
PUBLIC	?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::last
PUBLIC	?clear@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear
PUBLIC	?clear_and_free@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear_and_free
PUBLIC	?clear@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAEXXZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::clear
PUBLIC	?_Destroy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXPAPAVISpatial@@0@Z ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEAAV?$xalloc@PAVISpatial@@@@XZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVISpatial@@@@XZ ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Get_first
PUBLIC	??$_Destroy_range@V?$xalloc@PAVISpatial@@@@@std@@YAXPAPAVISpatial@@QAPAV1@AAV?$xalloc@PAVISpatial@@@@@Z ; std::_Destroy_range<xalloc<ISpatial *> >
PUBLIC	??$_Unfancy@PAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ; std::_Unfancy<ISpatial *>
PUBLIC	??$destroy@PAVISpatial@@@?$_Normal_allocator_traits@V?$xalloc@PAVISpatial@@@@@std@@SAXAAV?$xalloc@PAVISpatial@@@@PAPAVISpatial@@@Z ; std::_Normal_allocator_traits<xalloc<ISpatial *> >::destroy<ISpatial *>
PUBLIC	?destroy@?$xalloc@PAVISpatial@@@@QAEXPAPAVISpatial@@@Z ; xalloc<ISpatial *>::destroy
PUBLIC	??$_Destroy_in_place@PAPAVISpatial@@@std@@YAXAAPAPAVISpatial@@@Z ; std::_Destroy_in_place<ISpatial * *>
PUBLIC	??D?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEAAUShader@@XZ ; resptr_core<Shader,resptrcode_shader>::operator*
PUBLIC	?occlude@CHOM@@QAEXAAV?$_box2@M@@@Z		; CHOM::occlude
PUBLIC	??0R_dsgraph_structure@@QAE@XZ			; R_dsgraph_structure::R_dsgraph_structure
PUBLIC	?r_pmask@R_dsgraph_structure@@QAEX_N00@Z	; R_dsgraph_structure::r_pmask
PUBLIC	??1?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
PUBLIC	??1?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
PUBLIC	?_Tidy@?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@AAEXXZ ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::_Tidy
PUBLIC	??0?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
PUBLIC	??0?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><>
PUBLIC	??0?$doug_lea_alloc@PAVIRender_Visual@@@@QAE@XZ	; doug_lea_alloc<IRender_Visual *>::doug_lea_alloc<IRender_Visual *>
PUBLIC	??1?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ ; xr_vector<ISpatial *,xalloc<ISpatial *> >::~xr_vector<ISpatial *,xalloc<ISpatial *> >
PUBLIC	??1?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::~vector<ISpatial *,xalloc<ISpatial *> >
PUBLIC	?_Tidy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXXZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Tidy
PUBLIC	?deallocate@?$xalloc@PAVISpatial@@@@QBEXPAPAVISpatial@@I@Z ; xalloc<ISpatial *>::deallocate
PUBLIC	??$xr_free@PAVISpatial@@@@YAXAAPAPAVISpatial@@@Z ; xr_free<ISpatial *>
PUBLIC	??0?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ ; xr_vector<ISpatial *,xalloc<ISpatial *> >::xr_vector<ISpatial *,xalloc<ISpatial *> >
PUBLIC	??0?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::vector<ISpatial *,xalloc<ISpatial *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<ISpatial *> >::_Vector_val<std::_Simple_types<ISpatial *> >
PUBLIC	??0?$xalloc@PAVISpatial@@@@QAE@XZ		; xalloc<ISpatial *>::xalloc<ISpatial *>
PUBLIC	??1?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ	; xr_vector<int,doug_lea_alloc<int> >::~xr_vector<int,doug_lea_alloc<int> >
PUBLIC	??1?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ	; std::vector<int,doug_lea_alloc<int> >::~vector<int,doug_lea_alloc<int> >
PUBLIC	?_Tidy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXXZ ; std::vector<int,doug_lea_alloc<int> >::_Tidy
PUBLIC	??0?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ	; xr_vector<int,doug_lea_alloc<int> >::xr_vector<int,doug_lea_alloc<int> >
PUBLIC	??0?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ	; std::vector<int,doug_lea_alloc<int> >::vector<int,doug_lea_alloc<int> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??0?$doug_lea_alloc@H@@QAE@XZ			; doug_lea_alloc<int>::doug_lea_alloc<int>
PUBLIC	??1?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??1?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	?_Tidy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Tidy
PUBLIC	??0?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??0?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >
PUBLIC	??0?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAE@XZ ; doug_lea_alloc<R_dsgraph::_LodItem>::doug_lea_alloc<R_dsgraph::_LodItem>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>
PUBLIC	??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
PUBLIC	??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
PUBLIC	?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Tidy
PUBLIC	??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
PUBLIC	??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>
PUBLIC	??1?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>
PUBLIC	??0?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>
PUBLIC	??1?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>
PUBLIC	??0?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>
PUBLIC	??1mapMatrixVS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixVS::~mapMatrixVS
PUBLIC	??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>
PUBLIC	??0mapMatrixVS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapMatrixVS::mapMatrixVS
PUBLIC	??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>
PUBLIC	??1mapNormalVS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalVS::~mapNormalVS
PUBLIC	??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>
PUBLIC	??0mapNormalVS@R_dsgraph@@QAE@XZ		; R_dsgraph::mapNormalVS::mapNormalVS
PUBLIC	??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>
PUBLIC	??_GR_dsgraph_structure@@UAEPAXI@Z		; R_dsgraph_structure::`scalar deleting destructor'
PUBLIC	?memory_usage@R_dsgraph_structure@@UAEIXZ	; R_dsgraph_structure::memory_usage
PUBLIC	?set_Invisible@R_dsgraph_structure@@UAEXH@Z	; R_dsgraph_structure::set_Invisible
PUBLIC	?get_HUD@R_dsgraph_structure@@UAEHXZ		; R_dsgraph_structure::get_HUD
PUBLIC	?set_HUD@R_dsgraph_structure@@UAEXH@Z		; R_dsgraph_structure::set_HUD
PUBLIC	?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z ; R_dsgraph_structure::set_Transform
PUBLIC	??1R_dsgraph_structure@@UAE@XZ			; R_dsgraph_structure::~R_dsgraph_structure
PUBLIC	??0CPSLibrary@@QAE@XZ				; CPSLibrary::CPSLibrary
PUBLIC	??1?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
PUBLIC	??1?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
PUBLIC	?_Tidy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXXZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Tidy
PUBLIC	??0?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
PUBLIC	??0?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PS::CPGDef *> >::_Vector_val<std::_Simple_types<PS::CPGDef *> >
PUBLIC	??0?$xalloc@PAVCPGDef@PS@@@@QAE@XZ		; xalloc<PS::CPGDef *>::xalloc<PS::CPGDef *>
PUBLIC	??1?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
PUBLIC	??1?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
PUBLIC	?_Tidy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXXZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Tidy
PUBLIC	??0?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
PUBLIC	??0?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1><>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PS::CPEDef *> >::_Vector_val<std::_Simple_types<PS::CPEDef *> >
PUBLIC	??0?$xalloc@PAVCPEDef@PS@@@@QAE@XZ		; xalloc<PS::CPEDef *>::xalloc<PS::CPEDef *>
PUBLIC	??1CPSLibrary@@QAE@XZ				; CPSLibrary::~CPSLibrary
PUBLIC	?finalize@CLightProjector@@QAEXXZ		; CLightProjector::finalize
PUBLIC	?clear@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear
PUBLIC	?clear_and_free@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear_and_free
PUBLIC	?clear@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXXZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::clear
PUBLIC	?_Destroy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@0@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEAAV?$xalloc@PAVIRenderable@@@@XZ ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRenderable@@@@XZ ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first
PUBLIC	??$_Destroy_range@V?$xalloc@PAVIRenderable@@@@@std@@YAXPAPAVIRenderable@@QAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z ; std::_Destroy_range<xalloc<IRenderable *> >
PUBLIC	??$_Unfancy@PAVIRenderable@@@std@@YAPAPAVIRenderable@@PAPAV1@@Z ; std::_Unfancy<IRenderable *>
PUBLIC	??$destroy@PAVIRenderable@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@@Z ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::destroy<IRenderable *>
PUBLIC	?destroy@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@@Z ; xalloc<IRenderable *>::destroy
PUBLIC	??$_Destroy_in_place@PAPAVIRenderable@@@std@@YAXAAPAPAVIRenderable@@@Z ; std::_Destroy_in_place<IRenderable * *>
PUBLIC	?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; make_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??2@YAPAXI@Z					; operator new
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	_vsprintf
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::size
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::c_str
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??$_Unfancy@U_REG_INFO@@@std@@YAPAU_REG_INFO@@PAU1@@Z ; std::_Unfancy<_REG_INFO>
PUBLIC	?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEAAV?$xalloc@U_REG_INFO@@@@XZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_REG_INFO@@@@XZ ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first
PUBLIC	??$destroy@U_REG_INFO@@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::destroy<_REG_INFO>
PUBLIC	?destroy@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@@Z ; xalloc<_REG_INFO>::destroy
PUBLIC	??$_Destroy_in_place@PAU_REG_INFO@@@std@@YAXAAPAU_REG_INFO@@@Z ; std::_Destroy_in_place<_REG_INFO *>
PUBLIC	?_Destroy@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@0@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Destroy
PUBLIC	??$_Destroy_range@V?$xalloc@U_REG_INFO@@@@@std@@YAXPAU_REG_INFO@@QAU1@AAV?$xalloc@U_REG_INFO@@@@@Z ; std::_Destroy_range<xalloc<_REG_INFO> >
PUBLIC	?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z ; xalloc<_REG_INFO>::deallocate
PUBLIC	??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z	; xr_free<_REG_INFO>
PUBLIC	?get_generation@CRender@@UAE?AW4GenerationLevel@IRender_interface@@XZ ; CRender::get_generation
PUBLIC	?getShaderPath@CRender@@UAEPBDXZ		; CRender::getShaderPath
PUBLIC	?model_Logging@CRender@@UAEXH@Z			; CRender::model_Logging
PUBLIC	?ps_library@CRender@@UAEPAVCPSLibrary@@XZ	; CRender::ps_library
PUBLIC	??$forward@AAPAPAVISpatial@@@std@@YAAAPAPAVISpatial@@AAPAPAV1@@Z ; std::forward<ISpatial * * &>
PUBLIC	??$swap@PAVISpatial@@$0A@@std@@YAXAAPAVISpatial@@0@Z ; std::swap<ISpatial *,0>
PUBLIC	??$_Med3_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z ; std::_Med3_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_unchecked<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Push_heap_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Push_heap_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$forward@PAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z ; std::forward<ISpatial *>
PUBLIC	??$_To_address@PAPAVISpatial@@@std@@YA?A_PABQAPAVISpatial@@@Z ; std::_To_address<ISpatial * *>
PUBLIC	??$_Copy_backward_memmove@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z ; std::_Copy_backward_memmove<ISpatial * *,ISpatial * *>
PUBLIC	??$construct@U_REG_INFO@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@$$QAU3@@Z ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO>
PUBLIC	??$forward@U_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z ; std::forward<_REG_INFO>
PUBLIC	??$?0AAPAPAVISpatial@@AAPAPAV0@$0A@@?$pair@PAPAVISpatial@@PAPAV1@@std@@QAE@AAPAPAVISpatial@@0@Z ; std::pair<ISpatial * *,ISpatial * *>::pair<ISpatial * *,ISpatial * *><ISpatial * * &,ISpatial * * &,0>
PUBLIC	??$iter_swap@PAPAVISpatial@@PAPAV1@@std@@YAXPAPAVISpatial@@0@Z ; std::iter_swap<ISpatial * *,ISpatial * *>
PUBLIC	??$_Next_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ; std::_Next_iter<ISpatial * *>
PUBLIC	??$_Guess_median_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z ; std::_Guess_median_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Prev_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ; std::_Prev_iter<ISpatial * *>
PUBLIC	??$_Pop_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ; std::_Pop_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Move_backward_unchecked@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z ; std::_Move_backward_unchecked<ISpatial * *,ISpatial * *>
PUBLIC	??$move@AAPAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z ; std::move<ISpatial * &>
PUBLIC	??_GFS_File@@QAEPAXI@Z				; FS_File::`scalar deleting destructor'
PUBLIC	??$xr_free@U?$_Tree_node@UFS_File@@PAX@std@@@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@std@@@Z ; xr_free<std::_Tree_node<FS_File,void *> >
PUBLIC	??$_Destroy_in_place@PAPAVIRender_Portal@@@std@@YAXAAPAPAVIRender_Portal@@@Z ; std::_Destroy_in_place<IRender_Portal * *>
PUBLIC	??$_Destroy_in_place@PAUFSlideWindowItem@@@std@@YAXAAPAUFSlideWindowItem@@@Z ; std::_Destroy_in_place<FSlideWindowItem *>
PUBLIC	??$_Destroy_in_place@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Destroy_in_place<resptr_core<Shader,resptrcode_shader> *>
PUBLIC	??$_Destroy_in_place@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; std::_Destroy_in_place<svector<_D3DVERTEXELEMENT9,65> *>
PUBLIC	??$_Destroy_in_place@PAPAUIDirect3DVertexBuffer9@@@std@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z ; std::_Destroy_in_place<IDirect3DVertexBuffer9 * *>
PUBLIC	??$_Destroy_in_place@PAPAUIDirect3DIndexBuffer9@@@std@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z ; std::_Destroy_in_place<IDirect3DIndexBuffer9 * *>
PUBLIC	?reflect@?$reflector@$07@detail@boost@@SAEE@Z	; boost::detail::reflector<8>::reflect
PUBLIC	??$_Emplace_back@U_REG_INFO@@@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEX$$QAU_REG_INFO@@@Z ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Emplace_back<_REG_INFO>
PUBLIC	??$move@AAU_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z ; std::move<_REG_INFO &>
PUBLIC	??$forward@ABQAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAABQAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<FS_File,void *> * const &>
PUBLIC	??$_Voidify_iter@PAPAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@UFS_File@@PAX@0@@Z ; std::_Voidify_iter<std::_Tree_node<FS_File,void *> * *>
PUBLIC	??$addressof@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<FS_File,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<FS_File,void *> *>
PUBLIC	??$destroy@UFS_File@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAUFS_File@@@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::destroy<FS_File>
PUBLIC	??$addressof@UFS_File@@@std@@YAPAUFS_File@@AAU1@@Z ; std::addressof<FS_File>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YA?AU?$pair@PAPAVISpatial@@PAPAV1@@0@PAPAVISpatial@@0P6A_NPAV2@1@Z@Z ; std::_Partition_by_median_guess_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Sort_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ; std::_Sort_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Make_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ; std::_Make_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Insertion_sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAPAPAVISpatial@@QAPAV1@0P6A_NPAV1@1@Z@Z ; std::_Insertion_sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	?deallocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEXPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z ; xalloc<std::_Tree_node<FS_File,void *> >::deallocate
PUBLIC	??0?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QAE@XZ ; xalloc<std::_Tree_node<FS_File,void *> >::xalloc<std::_Tree_node<FS_File,void *> >
PUBLIC	?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@2@I@Z ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::deallocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Tree_val<std::_Tree_simple_types<FS_File> >
PUBLIC	?destroy@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@@Z ; xalloc<IRender_Portal *>::destroy
PUBLIC	?destroy@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@@Z ; xalloc<FSlideWindowItem>::destroy
PUBLIC	?destroy@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; xalloc<resptr_core<Shader,resptrcode_shader> >::destroy
PUBLIC	?destroy@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::destroy
PUBLIC	?destroy@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@@Z ; xalloc<IDirect3DVertexBuffer9 *>::destroy
PUBLIC	?destroy@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@@Z ; xalloc<IDirect3DIndexBuffer9 *>::destroy
PUBLIC	?reflect@?$crc_helper@$07$00@detail@boost@@SAEE@Z ; boost::detail::crc_helper<8,1>::reflect
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@PAU_REG_INFO@@AAV?$xalloc@U_REG_INFO@@@@@Z ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Uninitialized_backout_al<xalloc<_REG_INFO> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::~_Uninitialized_backout_al<xalloc<_REG_INFO> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@XZ ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Release
PUBLIC	??$xr_alloc@U?$_Tree_node@UFS_File@@PAX@std@@@@YAPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z ; xr_alloc<std::_Tree_node<FS_File,void *> >
PUBLIC	??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z	; xr_alloc<_REG_INFO>
PUBLIC	??$_Get_unwrapped@ABQAU_REG_INFO@@@std@@YA?A_TABQAU_REG_INFO@@@Z ; std::_Get_unwrapped<_REG_INFO * const &>
PUBLIC	??$_Uninitialized_move@PAU_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@YAPAU_REG_INFO@@QAU1@0PAU1@AAV?$xalloc@U_REG_INFO@@@@@Z ; std::_Uninitialized_move<_REG_INFO *,xalloc<_REG_INFO> >
PUBLIC	?reflect@?$reflector@$0CA@@detail@boost@@SAII@Z	; boost::detail::reflector<32>::reflect
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * const &>
PUBLIC	??$destroy@PAVIRender_Portal@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::destroy<IRender_Portal *>
PUBLIC	??$_Unfancy@PAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@PAPAV1@@Z ; std::_Unfancy<IRender_Portal *>
PUBLIC	??$destroy@UFSlideWindowItem@@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::destroy<FSlideWindowItem>
PUBLIC	??$_Unfancy@UFSlideWindowItem@@@std@@YAPAUFSlideWindowItem@@PAU1@@Z ; std::_Unfancy<FSlideWindowItem>
PUBLIC	??$destroy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::destroy<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$_Unfancy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@@Z ; std::_Unfancy<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$destroy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::destroy<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$_Unfancy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@@Z ; std::_Unfancy<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$destroy@PAUIDirect3DVertexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::destroy<IDirect3DVertexBuffer9 *>
PUBLIC	??$_Unfancy@PAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@@Z ; std::_Unfancy<IDirect3DVertexBuffer9 *>
PUBLIC	??$destroy@PAUIDirect3DIndexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::destroy<IDirect3DIndexBuffer9 *>
PUBLIC	??$_Unfancy@PAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@@Z ; std::_Unfancy<IDirect3DIndexBuffer9 *>
PUBLIC	??$forward@ABU?$less@UFS_File@@@std@@@std@@YAABU?$less@UFS_File@@@0@ABU10@@Z ; std::forward<std::less<FS_File> const &>
PUBLIC	??$_Freenode0@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z ; std::_Tree_node<FS_File,void *>::_Freenode0<xalloc<std::_Tree_node<FS_File,void *> > >
PUBLIC	??$_Freenode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z ; std::_Tree_node<FS_File,void *>::_Freenode<xalloc<std::_Tree_node<FS_File,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@UFS_File@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * &>
PUBLIC	??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$_Pass_fn@P6A_NPAVISpatial@@0@Z$0A@@std@@YAP6A_NPAVISpatial@@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(ISpatial *,ISpatial *),0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1><>
PUBLIC	?init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ ; boost::detail::crc_table_t<32,79764919,1>::init_table
PUBLIC	?get_final_xor_value@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::get_final_xor_value
PUBLIC	?max_size@?$xalloc@U_REG_INFO@@@@QBEIXZ		; xalloc<_REG_INFO>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_REG_INFO@@@@XZ ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAIABV?$xalloc@U_REG_INFO@@@@@Z ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::max_size
PUBLIC	?capacity@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00U?$integral_constant@_N$00@2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEABV?$xalloc@U_REG_INFO@@@@XZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal
PUBLIC	?allocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEPAU?$_Tree_node@UFS_File@@PAX@std@@IPBX@Z ; xalloc<std::_Tree_node<FS_File,void *> >::allocate
PUBLIC	?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z ; xalloc<_REG_INFO>::allocate
PUBLIC	?construct@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@ABU2@@Z ; xalloc<_REG_INFO>::construct
PUBLIC	?max_size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::max_size
PUBLIC	?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEII@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXQAU_REG_INFO@@II@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@CAXXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Xlength
PUBLIC	??0?$xalloc@PAVIRender_Portal@@@@QAE@XZ		; xalloc<IRender_Portal *>::xalloc<IRender_Portal *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IRender_Portal *> >::_Vector_val<std::_Simple_types<IRender_Portal *> >
PUBLIC	??0?$xalloc@UFSlideWindowItem@@@@QAE@XZ		; xalloc<FSlideWindowItem>::xalloc<FSlideWindowItem>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FSlideWindowItem> >::_Vector_val<std::_Simple_types<FSlideWindowItem> >
PUBLIC	??0?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAE@XZ ; xalloc<resptr_core<Shader,resptrcode_shader> >::xalloc<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??0?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAE@XZ ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::xalloc<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??0?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAE@XZ	; xalloc<IDirect3DVertexBuffer9 *>::xalloc<IDirect3DVertexBuffer9 *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >
PUBLIC	??0?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAE@XZ	; xalloc<IDirect3DIndexBuffer9 *>::xalloc<IDirect3DIndexBuffer9 *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEPAPAVISpatial@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Unwrapped
PUBLIC	??R?$xr_special_free@$00VCLightR_Manager@@@@QAEXAAPAVCLightR_Manager@@@Z ; xr_special_free<1,CLightR_Manager>::operator()
PUBLIC	??R?$xr_special_free@$00VCModelPool@@@@QAEXAAPAVCModelPool@@@Z ; xr_special_free<1,CModelPool>::operator()
PUBLIC	??R?$xr_special_free@$00VCRenderTarget@@@@QAEXAAPAVCRenderTarget@@@Z ; xr_special_free<1,CRenderTarget>::operator()
PUBLIC	??R?$xr_special_free@$00VIRender_ObjectSpecific@@@@QAEXAAPAVIRender_ObjectSpecific@@@Z ; xr_special_free<1,IRender_ObjectSpecific>::operator()
PUBLIC	?reflect@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z ; boost::detail::crc_helper<32,1>::reflect
PUBLIC	?index@?$crc_helper@$0CA@$00@detail@boost@@SAEIE@Z ; boost::detail::crc_helper<32,1>::index
PUBLIC	?shift@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z ; boost::detail::crc_helper<32,1>::shift
PUBLIC	?reflect@?$crc_helper@$0CA@$0A@@detail@boost@@SAII@Z ; boost::detail::crc_helper<32,0>::reflect
PUBLIC	??$_Buyheadnode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z ; std::_Tree_node<FS_File,void *>::_Buyheadnode<xalloc<std::_Tree_node<FS_File,void *> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
PUBLIC	??$xr_free@PAVIRender_Portal@@@@YAXAAPAPAVIRender_Portal@@@Z ; xr_free<IRender_Portal *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAVIRender_Portal@@@@@std@@YAXPAPAVIRender_Portal@@QAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z ; std::_Destroy_range<xalloc<IRender_Portal *> >
PUBLIC	??$xr_free@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z ; xr_free<FSlideWindowItem>
PUBLIC	??$_Destroy_range@V?$xalloc@UFSlideWindowItem@@@@@std@@YAXPAUFSlideWindowItem@@QAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z ; std::_Destroy_range<xalloc<FSlideWindowItem> >
PUBLIC	??$xr_free@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; xr_free<resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ; std::_Destroy_range<xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??$xr_free@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ; xr_free<svector<_D3DVERTEXELEMENT9,65> >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ; std::_Destroy_range<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??$xr_free@PAUIDirect3DVertexBuffer9@@@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z ; xr_free<IDirect3DVertexBuffer9 *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAXPAPAUIDirect3DVertexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ; std::_Destroy_range<xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??$xr_free@PAUIDirect3DIndexBuffer9@@@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z ; xr_free<IDirect3DIndexBuffer9 *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAXPAPAUIDirect3DIndexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ; std::_Destroy_range<xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??$?0ABU?$less@UFS_File@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@UFS_File@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@UFS_File@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1>::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1><std::less<FS_File> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > const >
PUBLIC	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
PUBLIC	??$construct@U_REG_INFO@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@ABU3@@Z ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO const &>
PUBLIC	??$forward@ABU_REG_INFO@@@std@@YAABU_REG_INFO@@ABU1@@Z ; std::forward<_REG_INFO const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
PUBLIC	??$_Erase_head@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_head<xalloc<std::_Tree_node<FS_File,void *> > >
PUBLIC	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
PUBLIC	??$strncpy_s@$02@@YAHAAY02DPBDI@Z		; strncpy_s<3>
PUBLIC	?checksum@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::checksum
PUBLIC	?process_block@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAEXPBX0@Z ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::process_block
PUBLIC	??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::crc_optimal<32,79764919,4294967295,4294967295,1,1>
PUBLIC	??$xr_free@$$CBX@@YAXAAPBX@Z			; xr_free<void const >
PUBLIC	??$xr_alloc@E@@YAPAEI@Z				; xr_alloc<unsigned char>
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@P6A_NPAVISpatial@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0P6A_NPAVISpatial@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,bool (__cdecl*)(ISpatial *,ISpatial *)>
PUBLIC	??$xr_new@VCGlow@@@@YAPAVCGlow@@XZ		; xr_new<CGlow>
PUBLIC	??$xr_delete@VIRender_ObjectSpecific@@@@YAXAAPAVIRender_ObjectSpecific@@@Z ; xr_delete<IRender_ObjectSpecific>
PUBLIC	??$xr_new@VCROS_impl@@@@YAPAVCROS_impl@@XZ	; xr_new<CROS_impl>
PUBLIC	??$xr_delete@VCRenderTarget@@@@YAXAAPAVCRenderTarget@@@Z ; xr_delete<CRenderTarget>
PUBLIC	??$xr_delete@VCModelPool@@@@YAXAAPAVCModelPool@@@Z ; xr_delete<CModelPool>
PUBLIC	??$xr_delete@VCLightR_Manager@@@@YAXAAPAVCLightR_Manager@@@Z ; xr_delete<CLightR_Manager>
PUBLIC	??$xr_new@VCLightR_Manager@@@@YAPAVCLightR_Manager@@XZ ; xr_new<CLightR_Manager>
PUBLIC	??$xr_new@VCModelPool@@@@YAPAVCModelPool@@XZ	; xr_new<CModelPool>
PUBLIC	??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ ; xr_new<CRenderTarget>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Verify_offset
PUBLIC	?clear@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::clear
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Verify_offset
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=
PUBLIC	?clear_and_free@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear_and_free
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Portal@@@@XZ ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UFSlideWindowItem@@@@XZ ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEABU_REG_INFO@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@SAPAU?$_Tree_node@UFS_File@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Min
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Get_first
PUBLIC	?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::pop_back
PUBLIC	?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@2@XZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::begin
PUBLIC	?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBE_NXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::empty
PUBLIC	?size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::size
PUBLIC	?_Orphan_range@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEXPAU_REG_INFO@@0@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Orphan_range
PUBLIC	?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear
PUBLIC	?deallocate@?$xalloc@PAVIRender_Portal@@@@QBEXPAPAVIRender_Portal@@I@Z ; xalloc<IRender_Portal *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@0@Z ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEAAV?$xalloc@PAVIRender_Portal@@@@XZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal
PUBLIC	?deallocate@?$xalloc@UFSlideWindowItem@@@@QBEXPAUFSlideWindowItem@@I@Z ; xalloc<FSlideWindowItem>::deallocate
PUBLIC	?_Destroy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@0@Z ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Destroy
PUBLIC	?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEAAV?$xalloc@UFSlideWindowItem@@@@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal
PUBLIC	?deallocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ; xalloc<resptr_core<Shader,resptrcode_shader> >::deallocate
PUBLIC	?_Destroy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Destroy
PUBLIC	?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal
PUBLIC	?deallocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::deallocate
PUBLIC	?_Destroy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Destroy
PUBLIC	?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal
PUBLIC	?deallocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEXPAPAUIDirect3DVertexBuffer9@@I@Z ; xalloc<IDirect3DVertexBuffer9 *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@0@Z ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal
PUBLIC	?deallocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEXPAPAUIDirect3DIndexBuffer9@@I@Z ; xalloc<IDirect3DIndexBuffer9 *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@0@Z ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DIndexBuffer9@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DVertexBuffer9@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEABV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEABV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEABUFSlideWindowItem@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEAAU_REG_INFO@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
PUBLIC	??0?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@ABU?$less@UFS_File@@@1@@Z ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXQAU?$_Tree_node@UFS_File@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Orphan_ptr
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAE?A_TABU_REG_INFO@@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_back_with_unused_capacity<_REG_INFO const &>
PUBLIC	??$emplace_back@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?A_TABU_REG_INFO@@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::emplace_back<_REG_INFO const &>
PUBLIC	?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXABU_REG_INFO@@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back
PUBLIC	?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
PUBLIC	??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
PUBLIC	?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ	; CRegistrator<pureFrame>::Resort
PUBLIC	??0?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::vector<IRender_Portal *,xalloc<IRender_Portal *> >
PUBLIC	?_Tidy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXXZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Tidy
PUBLIC	??0?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
PUBLIC	?begin@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::begin
PUBLIC	?_Tidy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXXZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Tidy
PUBLIC	??0?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	?begin@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@2@XZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::begin
PUBLIC	?_Tidy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXXZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Tidy
PUBLIC	??0?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	?begin@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@2@XZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::begin
PUBLIC	?_Tidy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXXZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Tidy
PUBLIC	??0?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	?begin@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@2@XZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::begin
PUBLIC	?_Tidy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXXZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Tidy
PUBLIC	??0?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	?begin@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@2@XZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::begin
PUBLIC	?_Tidy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXXZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Tidy
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator==
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DIndexBuffer9@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DVertexBuffer9@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEAAUFSlideWindowItem@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >
PUBLIC	??1?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::~_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::end
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::clear
PUBLIC	??0?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::set<FS_File,std::less<FS_File>,xalloc<FS_File> >
PUBLIC	?xform@?$_box3@M@@QAEAAV1@ABU?$_matrix@M@@@Z	; _box3<float>::xform
PUBLIC	?Add@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@HI@Z ; CRegistrator<pureFrame>::Add
PUBLIC	?Remove@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@@Z ; CRegistrator<pureFrame>::Remove
PUBLIC	?end@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ ; std::vector<ISpatial *,xalloc<ISpatial *> >::end
PUBLIC	??1?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::~vector<IRender_Portal *,xalloc<IRender_Portal *> >
PUBLIC	??0?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >
PUBLIC	??1?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
PUBLIC	??0?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
PUBLIC	??A?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEAAUFSlideWindowItem@@I@Z ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::operator[]
PUBLIC	??1?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??0?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??A?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::operator[]
PUBLIC	??1?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??0?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??A?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::operator[]
PUBLIC	??1?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??0?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??A?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEAAPAUIDirect3DVertexBuffer9@@I@Z ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::operator[]
PUBLIC	??1?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??0?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??A?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEAAPAUIDirect3DIndexBuffer9@@I@Z ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::operator[]
PUBLIC	?begin@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEPAU_D3DVERTEXELEMENT9@@XZ ; svector<_D3DVERTEXELEMENT9,65>::begin
PUBLIC	??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@PAVIRender_Glow@@_N@Z ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>
PUBLIC	??1?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@XZ ; resptr_core<IRender_Glow,resptrcode_glow>::~resptr_core<IRender_Glow,resptrcode_glow>
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBEABUFS_File@@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator++
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator!=
PUBLIC	??0ID3DXInclude@@QAE@XZ				; ID3DXInclude::ID3DXInclude
PUBLIC	??0includer@@QAE@XZ				; includer::includer
PUBLIC	?shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z	; CRender::shader_compile
PUBLIC	?Close@includer@@UAGJPBX@Z			; includer::Close
PUBLIC	?Open@includer@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z ; includer::Open
PUBLIC	?Statistics@CRender@@UAEXPAVCGameFont@@@Z	; CRender::Statistics
PUBLIC	?ApplyBlur4@CRender@@QAEXPAUTL4uv@FVF@@IIM@Z	; CRender::ApplyBlur4
PUBLIC	?Render@CRender@@UAEXXZ				; CRender::Render
PUBLIC	?rmNormal@CRender@@UAEXXZ			; CRender::rmNormal
PUBLIC	?rmFar@CRender@@UAEXXZ				; CRender::rmFar
PUBLIC	?rmNear@CRender@@UAEXXZ				; CRender::rmNear
PUBLIC	?Calculate@CRender@@UAEXXZ			; CRender::Calculate
PUBLIC	?pred_sp_sort@@YA_NPAVISpatial@@0@Z		; pred_sp_sort
PUBLIC	??1CRender@@UAE@XZ				; CRender::~CRender
PUBLIC	??1?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~set<FS_File,std::less<FS_File>,xalloc<FS_File> >
PUBLIC	??1?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >
PUBLIC	??0?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >
PUBLIC	??0cl_light_XFORM@@QAE@XZ			; cl_light_XFORM::cl_light_XFORM
PUBLIC	??0cl_light_C@@QAE@XZ				; cl_light_C::cl_light_C
PUBLIC	??0cl_light_PR@@QAE@XZ				; cl_light_PR::cl_light_PR
PUBLIC	??1?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
PUBLIC	??1?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
PUBLIC	??1?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
PUBLIC	??1?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
PUBLIC	??1?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
PUBLIC	??1?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::~xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >
PUBLIC	??_GCRender@@UAEPAXI@Z				; CRender::`scalar deleting destructor'
PUBLIC	??0CRender@@QAE@XZ				; CRender::CRender
PUBLIC	?gm_SetNearer@@YAXH@Z				; gm_SetNearer
PUBLIC	?set_Object@CRender@@UAEXPAVIRenderable@@@Z	; CRender::set_Object
PUBLIC	?add_Occluder@CRender@@UAEXAAV?$_box2@M@@@Z	; CRender::add_Occluder
PUBLIC	?add_SkeletonWallmark@CRender@@UAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z ; CRender::add_SkeletonWallmark
PUBLIC	?add_SkeletonWallmark@CRender@@UAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; CRender::add_SkeletonWallmark
PUBLIC	?clear_static_wallmarks@CRender@@UAEXXZ		; CRender::clear_static_wallmarks
PUBLIC	?add_StaticWallmark@CRender@@UAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@MPAVTRI@CDB@@PAU3@@Z ; CRender::add_StaticWallmark
PUBLIC	?add_Geometry@CRender@@UAEXPAVIRender_Visual@@@Z ; CRender::add_Geometry
PUBLIC	?add_Visual@CRender@@UAEXPAVIRender_Visual@@@Z	; CRender::add_Visual
PUBLIC	?occ_visible@CRender@@UAEHAAV?$_box3@M@@@Z	; CRender::occ_visible
PUBLIC	?occ_visible@CRender@@UAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ; CRender::occ_visible
PUBLIC	?occ_visible@CRender@@UAEHAAUvis_data@@@Z	; CRender::occ_visible
PUBLIC	?flush@CRender@@UAEXXZ				; CRender::flush
PUBLIC	?glow_create@CRender@@UAEPAVIRender_Glow@@XZ	; CRender::glow_create
PUBLIC	?light_create@CRender@@UAEPAVIRender_Light@@XZ	; CRender::light_create
PUBLIC	?getTarget@CRender@@UAEPAVIRender_Target@@XZ	; CRender::getTarget
PUBLIC	?getSector@CRender@@UAEPAVIRender_Sector@@H@Z	; CRender::getSector
PUBLIC	?getShader@CRender@@UAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@H@Z ; CRender::getShader
PUBLIC	?models_Clear@CRender@@UAEXH@Z			; CRender::models_Clear
PUBLIC	?models_Prefetch@CRender@@UAEXXZ		; CRender::models_Prefetch
PUBLIC	?model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z ; CRender::model_CreateParticles
PUBLIC	?model_Delete@CRender@@UAEXAAPAVIRender_DetailModel@@@Z ; CRender::model_Delete
PUBLIC	?model_CreateDM@CRender@@UAEPAVIRender_DetailModel@@PAVIReader@@@Z ; CRender::model_CreateDM
PUBLIC	?model_Delete@CRender@@UAEXAAPAVIRender_Visual@@H@Z ; CRender::model_Delete
PUBLIC	?model_Duplicate@CRender@@UAEPAVIRender_Visual@@PAV2@@Z ; CRender::model_Duplicate
PUBLIC	?model_CreateChild@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z ; CRender::model_CreateChild
PUBLIC	?model_Create@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z ; CRender::model_Create
PUBLIC	?ros_destroy@CRender@@UAEXAAPAVIRender_ObjectSpecific@@@Z ; CRender::ros_destroy
PUBLIC	?ros_create@CRender@@UAEPAVIRender_ObjectSpecific@@PAVIRenderable@@@Z ; CRender::ros_create
PUBLIC	?OnFrame@CRender@@UAEXXZ			; CRender::OnFrame
PUBLIC	?reset_end@CRender@@UAEXXZ			; CRender::reset_end
PUBLIC	?reset_begin@CRender@@UAEXXZ			; CRender::reset_begin
PUBLIC	?destroy@CRender@@UAEXXZ			; CRender::destroy
PUBLIC	?create@CRender@@UAEXXZ				; CRender::create
PUBLIC	?get_sun@CROS_impl@@QAEMXZ			; CROS_impl::get_sun
PUBLIC	?getPortal@CRender@@QAEPAVIRender_Portal@@H@Z	; CRender::getPortal
PUBLIC	?getVisual@CRender@@UAEPAVIRender_Visual@@H@Z	; CRender::getVisual
PUBLIC	?apply_object@CRender@@QAEXPAVIRenderable@@@Z	; CRender::apply_object
PUBLIC	?rimp_select_sh_dynamic@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z ; CRender::rimp_select_sh_dynamic
PUBLIC	?rimp_select_sh_static@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z ; CRender::rimp_select_sh_static
PUBLIC	?model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z ; CRender::model_CreatePE
PUBLIC	?getVB_Format@CRender@@QAEPAU_D3DVERTEXELEMENT9@@H@Z ; CRender::getVB_Format
PUBLIC	?getVB@CRender@@QAEPAUIDirect3DVertexBuffer9@@H@Z ; CRender::getVB
PUBLIC	?getIB@CRender@@QAEPAUIDirect3DIndexBuffer9@@H@Z ; CRender::getIB
PUBLIC	?getSWI@CRender@@QAEPAUFSlideWindowItem@@H@Z	; CRender::getSWI
PUBLIC	?RImplementation@@3VCRender@@A			; RImplementation
EXTRN	??_ER_dsgraph_structure@@UAEPAXI@Z:PROC		; R_dsgraph_structure::`vector deleting destructor'
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECRender@@UAEPAXI@Z:PROC			; CRender::`vector deleting destructor'
?gm_Nearer@@3HA DD 01H DUP (?)				; gm_Nearer
?RImplementation@@3VCRender@@A DB 0458H DUP (?)		; RImplementation
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z$0
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?Render@CRender@@UAEXXZ
	DD	0145H
	DD	0334H
?RImplementation$initializer$@@3P6AXXZA DD FLAT:??__ERImplementation@@YAXXZ ; RImplementation$initializer$
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getSWI@CRender@@QAEPAUFSlideWindowItem@@H@Z PROC	; CRender::getSWI
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR _id$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+884
	lea	eax, DWORD PTR [eax+ecx*8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 181  : FSlideWindowItem*		CRender::getSWI					(int id)			{ VERIFY(id<int(SWIs.size()));		return &SWIs[id];	}

	ret	4
?getSWI@CRender@@QAEPAUFSlideWindowItem@@H@Z ENDP	; CRender::getSWI
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getIB@CRender@@QAEPAUIDirect3DIndexBuffer9@@H@Z PROC	; CRender::getIB
; _this$dead$ = ecx

; 179  : IDirect3DIndexBuffer9*	CRender::getIB					(int id)			{ VERIFY(id<int(IB.size()));		return IB[id];		}

	mov	ecx, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+932
	mov	eax, DWORD PTR [eax+ecx*4]
	ret	4
?getIB@CRender@@QAEPAUIDirect3DIndexBuffer9@@H@Z ENDP	; CRender::getIB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getVB@CRender@@QAEPAUIDirect3DVertexBuffer9@@H@Z PROC	; CRender::getVB
; _this$dead$ = ecx

; 178  : IDirect3DVertexBuffer9*	CRender::getVB					(int id)			{ VERIFY(id<int(VB.size()));		return VB[id];		}

	mov	ecx, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+920
	mov	eax, DWORD PTR [eax+ecx*4]
	ret	4
?getVB@CRender@@QAEPAUIDirect3DVertexBuffer9@@H@Z ENDP	; CRender::getVB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getVB_Format@CRender@@QAEPAU_D3DVERTEXELEMENT9@@H@Z PROC ; CRender::getVB_Format
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR _id$[esp-4], 524
	add	eax, DWORD PTR ?RImplementation@@3VCRender@@A+908
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 177  : D3DVERTEXELEMENT9*		CRender::getVB_Format			(int id)			{ VERIFY(id<int(DCL.size()));		return DCL[id].begin();	}

	ret	4
?getVB_Format@CRender@@QAEPAU_D3DVERTEXELEMENT9@@H@Z ENDP ; CRender::getVB_Format
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_it$1 = -4						; size = 4
_name$ = 8						; size = 4
?model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z PROC ; CRender::model_CreatePE
; _this$dead$ = ecx

; 155  : { 

	push	ecx
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	push	DWORD PTR _name$[esp+4]
	lea	eax, DWORD PTR _it$1[esp+12]
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+956
	push	eax
	call	?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPEDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$1[esp+8]
	cmp	eax, DWORD PTR ?RImplementation@@3VCRender@@A+960
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 62   :     return (it==m_PEDs.end())?0:*it;

	jne	SHORT $LN9@model_Crea
	xor	esi, esi
	jmp	SHORT $LN10@model_Crea
$LN9@model_Crea:
	mov	esi, DWORD PTR [eax]
$LN10@model_Crea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 156  : 	PS::CPEDef*	SE		= PSLibrary.FindPED	(name);		R_ASSERT3(SE,"Particle effect doesn't exist",name);

	cmp	BYTE PTR ?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA, 0
	jne	SHORT $LN2@model_Crea
	test	esi, esi
	jne	SHORT $LN2@model_Crea
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BI@HOANMMBE@CRender?3?3model_CreatePE@
	push	156					; 0000009cH
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	DWORD PTR _name$[esp+20]
	push	OFFSET ??_C@_0BO@PKGKJKHO@Particle?5effect?5doesn?8t?5exist@
	push	OFFSET ??_C@_02ODEKANEE@SE@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD000H0AA_N@Z
$LN2@model_Crea:

; 157  : 	return				Models->CreatePE	(SE);

	push	esi
	call	?CreatePE@CModelPool@@QAEPAVIRender_Visual@@PAVCPEDef@PS@@@Z ; CModelPool::CreatePE
	pop	esi

; 158  : }

	pop	ecx
	ret	4
?model_CreatePE@CRender@@QAEPAVIRender_Visual@@PBD@Z ENDP ; CRender::model_CreatePE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_pVisual$ = 8						; size = 4
_cdist_sq$ = 12						; size = 4
?rimp_select_sh_static@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z PROC ; CRender::rimp_select_sh_static
; _this$ = ecx

; 36   : 	switch (phase)		{

	mov	ecx, DWORD PTR [ecx+292]
	mov	eax, DWORD PTR _pVisual$[esp-4]
	sub	ecx, 0
	je	SHORT $LN4@rimp_selec
	mov	eax, DWORD PTR [eax+64]
	sub	ecx, 1
	je	SHORT $LN5@rimp_selec

; 39   : 	case PHASE_SPOT:	return pVisual->shader->E[SE_R1_LSPOT]._get();

	mov	eax, DWORD PTR [eax+20]

; 40   : 	default:			NODEFAULT;
; 41   : 	}
; 42   : #ifdef DEBUG
; 43   : 	return	0;
; 44   : #endif
; 45   : }

	ret	8
$LN5@rimp_selec:

; 38   : 	case PHASE_POINT:	return pVisual->shader->E[SE_R1_LPOINT]._get();

	mov	eax, DWORD PTR [eax+16]

; 40   : 	default:			NODEFAULT;
; 41   : 	}
; 42   : #ifdef DEBUG
; 43   : 	return	0;
; 44   : #endif
; 45   : }

	ret	8
$LN4@rimp_selec:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, DWORD PTR _cdist_sq$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 37   : 	case PHASE_NORMAL:	return (((_sqrt(cdist_sq) - pVisual->vis.sphere.R)<44)?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	movss	xmm0, DWORD PTR __real@42300000
	subss	xmm1, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+64]
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@rimp_selec
	add	eax, 8
	mov	eax, DWORD PTR [eax]

; 40   : 	default:			NODEFAULT;
; 41   : 	}
; 42   : #ifdef DEBUG
; 43   : 	return	0;
; 44   : #endif
; 45   : }

	ret	8
$LN9@rimp_selec:

; 37   : 	case PHASE_NORMAL:	return (((_sqrt(cdist_sq) - pVisual->vis.sphere.R)<44)?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	add	eax, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]

; 40   : 	default:			NODEFAULT;
; 41   : 	}
; 42   : #ifdef DEBUG
; 43   : 	return	0;
; 44   : #endif
; 45   : }

	ret	8
?rimp_select_sh_static@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z ENDP ; CRender::rimp_select_sh_static
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_pVisual$ = 8						; size = 4
_cdist_sq$dead$ = 12					; size = 4
?rimp_select_sh_dynamic@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z PROC ; CRender::rimp_select_sh_dynamic
; _this$ = ecx

; 23   : 	switch (phase)		{

	mov	eax, DWORD PTR [ecx+292]
	mov	edx, DWORD PTR _pVisual$[esp-4]
	sub	eax, 0
	je	SHORT $LN4@rimp_selec
	sub	eax, 1
	mov	eax, DWORD PTR [edx+64]
	je	SHORT $LN5@rimp_selec

; 26   : 	case PHASE_SPOT:	return pVisual->shader->E[SE_R1_LSPOT]._get();

	mov	eax, DWORD PTR [eax+20]

; 27   : 	default:			NODEFAULT;
; 28   : 	}
; 29   : #ifdef DEBUG
; 30   : 	return	0;
; 31   : #endif
; 32   : }

	ret	8
$LN5@rimp_selec:

; 25   : 	case PHASE_POINT:	return pVisual->shader->E[SE_R1_LPOINT]._get();

	mov	eax, DWORD PTR [eax+16]

; 27   : 	default:			NODEFAULT;
; 28   : 	}
; 29   : #ifdef DEBUG
; 30   : 	return	0;
; 31   : #endif
; 32   : }

	ret	8
$LN4@rimp_selec:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h

; 43   : 	BOOL					shadowing		()			{ return current!=0;	}

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+992
	cmp	DWORD PTR [eax+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 24   : 	case PHASE_NORMAL:	return (RImplementation.L_Projector->shadowing()?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	mov	eax, DWORD PTR [edx+64]
	je	SHORT $LN9@rimp_selec
	add	eax, 8
	mov	eax, DWORD PTR [eax]

; 27   : 	default:			NODEFAULT;
; 28   : 	}
; 29   : #ifdef DEBUG
; 30   : 	return	0;
; 31   : #endif
; 32   : }

	ret	8
$LN9@rimp_selec:

; 24   : 	case PHASE_NORMAL:	return (RImplementation.L_Projector->shadowing()?pVisual->shader->E[SE_R1_NORMAL_HQ]:pVisual->shader->E[SE_R1_NORMAL_LQ])._get();

	add	eax, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]

; 27   : 	default:			NODEFAULT;
; 28   : 	}
; 29   : #ifdef DEBUG
; 30   : 	return	0;
; 31   : #endif
; 32   : }

	ret	8
?rimp_select_sh_dynamic@CRender@@QAEPAUShaderElement@@PAVIRender_Visual@@M@Z ENDP ; CRender::rimp_select_sh_dynamic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_this$1$ = -32						; size = 4
_o_sun$1$ = -28						; size = 4
_o_hemi$1$ = -24					; size = 4
$T1 = -20						; size = 4
_data$2 = -16						; size = 16
_O$ = 8							; size = 4
?apply_object@CRender@@QAEXPAVIRenderable@@@Z PROC	; CRender::apply_object
; _this$dead$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 36					; 00000024H
	push	ebx

; 250  : 	if (0==O)			return	;

	mov	ebx, DWORD PTR _O$[ebp]
	push	esi
	push	edi
	test	ebx, ebx
	je	$LN10@apply_obje

; 251  : 	if (PHASE_NORMAL==phase	&& O->renderable_ROS())		{

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 0
	jne	$LN10@apply_obje
	mov	ecx, ebx
	call	DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	test	eax, eax
	je	$LN10@apply_obje

; 252  : 		CROS_impl& LT		= *((CROS_impl*)O->renderable.pROS);

	mov	esi, DWORD PTR [ebx+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.h

; 66   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	xorps	xmm5, xmm5
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+244]
	cmp	edx, ecx
	je	SHORT $LN117@apply_obje
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [esi+12], ecx

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm3, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm5, xmm3
	jbe	SHORT $LN20@apply_obje
	movaps	xmm3, xmm5
	jmp	SHORT $LN22@apply_obje
$LN20@apply_obje:
	comiss	xmm3, xmm2
	jbe	SHORT $LN22@apply_obje
	movaps	xmm3, xmm2
$LN22@apply_obje:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	movaps	xmm1, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR [esi+1932]
	subss	xmm1, xmm3

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mov	edx, ecx
	mulss	xmm3, DWORD PTR [esi+1940]
	movaps	xmm0, xmm1
	mulss	xmm1, DWORD PTR [esi+1944]
	mulss	xmm0, DWORD PTR [esi+1936]
	addss	xmm3, xmm1
	addss	xmm4, xmm0
	movss	DWORD PTR [esi+1944], xmm3
	movss	DWORD PTR [esi+1936], xmm4
	jmp	SHORT $LN15@apply_obje
$LN117@apply_obje:
	movss	xmm4, DWORD PTR [esi+1936]
$LN15@apply_obje:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 255  : 		float o_hemi		= 0.5f*LT.get_hemi						();

	movss	xmm3, DWORD PTR __real@3f000000
	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 70   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 255  : 		float o_hemi		= 0.5f*LT.get_hemi						();

	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 70   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR [eax+244]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 255  : 		float o_hemi		= 0.5f*LT.get_hemi						();

	movss	DWORD PTR _o_hemi$1$[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 70   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	cmp	edx, eax
	je	SHORT $LN118@apply_obje
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [esi+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm1, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm5, xmm1
	jbe	SHORT $LN32@apply_obje
	movaps	xmm1, xmm5
	jmp	SHORT $LN34@apply_obje
$LN32@apply_obje:
	comiss	xmm1, xmm2
	jbe	SHORT $LN34@apply_obje
	movaps	xmm1, xmm2
$LN34@apply_obje:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm2, xmm1

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [esi+1932]

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm1, DWORD PTR [esi+1940]
	mulss	xmm4, xmm2
	mulss	xmm2, DWORD PTR [esi+1944]
	addss	xmm0, xmm4
	addss	xmm1, xmm2
	movss	DWORD PTR [esi+1936], xmm0
	movss	DWORD PTR [esi+1944], xmm1
	jmp	SHORT $LN27@apply_obje
$LN118@apply_obje:
	movss	xmm1, DWORD PTR [esi+1944]
$LN27@apply_obje:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 257  : 		RCache.set_c		(c_ldynamic_props,o_sun,o_sun,o_sun,o_hemi);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mulss	xmm1, xmm3
	mov	DWORD PTR _this$1$[esp+48], eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 207  : 	ICF	void						set_c(shared_str& n, float x, float y, float z, float w) { if (ctable)	set_c(&*ctable->get(n), x, y, z, w); }

	mov	ecx, DWORD PTR [eax+8864]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 256  : 		float o_sun			= 0.5f*LT.get_sun						();

	movss	DWORD PTR _o_sun$1$[esp+48], xmm1
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 207  : 	ICF	void						set_c(shared_str& n, float x, float y, float z, float w) { if (ctable)	set_c(&*ctable->get(n), x, y, z, w); }

	test	ecx, ecx
	je	$LN37@apply_obje
	push	OFFSET ?RImplementation@@3VCRender@@A+1100
	lea	eax, DWORD PTR $T1[esp+52]
	push	eax
	call	DWORD PTR __imp_?get@R_constant_table@@QAE?AV?$resptr_core@UR_constant@@V?$resptr_base@UR_constant@@@@@@AAVshared_str@@@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	edi, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	test	edi, edi
	je	$LN50@apply_obje
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	xmm0, DWORD PTR _o_sun$1$[esp+48]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	mov	ecx, DWORD PTR _this$1$[esp+48]
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	movzx	eax, WORD PTR [edi+10]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 191  : 	ICF	void						set_c(R_constant* C, float x, float y, float z, float w) { if (C)		constants.set(C, x, y, z, w); }

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$2[esp+48], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	mov	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	movss	DWORD PTR _data$2[esp+52], xmm0
	movss	DWORD PTR _data$2[esp+56], xmm0
	movss	xmm0, DWORD PTR _o_hemi$1$[esp+48]
	movss	DWORD PTR _data$2[esp+60], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 147  : 		if (C->destination & 1) { a_pixel.set(C, C->ps, A); a_pixel.b_dirty = TRUE; }

	test	al, 1
	je	SHORT $LN49@apply_obje
	lea	eax, DWORD PTR _data$2[esp+48]
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	ecx, DWORD PTR _this$1$[esp+48]
	add	ecx, 608				; 00000260H
	mov	DWORD PTR [ecx+4112], 1
	movzx	edx, WORD PTR [edi+10]
$LN49@apply_obje:

; 148  : 		if (C->destination & 2) { a_vertex.set(C, C->vs, A); a_vertex.b_dirty = TRUE; }

	test	dl, 2
	je	SHORT $LN50@apply_obje
	lea	eax, DWORD PTR _data$2[esp+48]
	add	ecx, 4128				; 00001020H
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	edi
	call	?set@R_constant_array@@QAEXPAUR_constant@@AAUR_constant_load@@ABU?$_vector4@M@@@Z ; R_constant_array::set
	mov	eax, DWORD PTR _this$1$[esp+48]
	mov	DWORD PTR [eax+8848], 1
$LN50@apply_obje:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+48]
	call	?_dec@?$resptr_base@UR_constant@@@@IAEXXZ ; resptr_base<R_constant>::_dec
$LN37@apply_obje:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 259  : 		if ((LT.shadow_recv_frame==Device.dwFrame) && O->renderable_ShadowReceive())	

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edx, DWORD PTR [esi+1924]
	cmp	edx, DWORD PTR [eax+244]
	jne	SHORT $LN10@apply_obje
	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN10@apply_obje

; 260  : 			RImplementation.L_Projector->setup	(LT.shadow_recv_slot);

	push	DWORD PTR [esi+1928]
	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+992
	call	?setup@CLightProjector@@QAEXH@Z		; CLightProjector::setup
$LN10@apply_obje:

; 261  : 	}
; 262  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?apply_object@CRender@@QAEXPAVIRenderable@@@Z ENDP	; CRender::apply_object
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getVisual@CRender@@UAEPAVIRender_Visual@@H@Z PROC	; CRender::getVisual
; _this$ = ecx

; 176  : IRender_Visual*			CRender::getVisual				(int id)			{ VERIFY(id<int(Visuals.size()));	return Visuals[id];	}

	mov	ecx, DWORD PTR [ecx+944]
	mov	eax, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4]
	ret	4
?getVisual@CRender@@UAEPAVIRender_Visual@@H@Z ENDP	; CRender::getVisual
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getPortal@CRender@@QAEPAVIRender_Portal@@H@Z PROC	; CRender::getPortal
; _this$dead$ = ecx

; 173  : IRender_Portal*			CRender::getPortal				(int id)			{ VERIFY(id<int(Portals.size()));	return Portals[id];	}

	mov	ecx, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+660
	mov	eax, DWORD PTR [eax+ecx*4]
	ret	4
?getPortal@CRender@@QAEPAVIRender_Portal@@H@Z ENDP	; CRender::getPortal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h
;	COMDAT ?get_sun@CROS_impl@@QAEMXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?get_sun@CROS_impl@@QAEMXZ PROC				; CROS_impl::get_sun, COMDAT
; _this$ = ecx

; 69   : 	ICF	float				get_sun				()	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 70   : 		if (dwFrameSmooth!=Device.dwFrame)		update_smooth();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	sub	esp, 8
	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+12], eax
	je	SHORT $LN14@get_sun
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 260  : 	dwFrameSmooth			=	Device.dwFrame					;

	mov	DWORD PTR [ecx+12], eax

; 261  : 	if (O && (0==result_count))	update(O)						;	// First time only
; 262  : 	float	l_f				=	Device.fTimeDelta*ps_r2_lt_smooth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm2, DWORD PTR [eax+468]
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm2
	jbe	SHORT $LN9@get_sun
	movaps	xmm2, xmm0
	jmp	SHORT $LN11@get_sun
$LN9@get_sun:
	comiss	xmm2, xmm3
	jbe	SHORT $LN11@get_sun
	movaps	xmm2, xmm3
$LN11@get_sun:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 264  : 	float	l_i				=	1.f-l_f							;

	subss	xmm3, xmm2

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movaps	xmm1, xmm2

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	mulss	xmm2, DWORD PTR [ecx+1940]
	mulss	xmm1, DWORD PTR [ecx+1932]
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR [ecx+1944]
	mulss	xmm0, DWORD PTR [ecx+1936]
	addss	xmm2, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR $T1[esp+8], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 72   : 	}

	fld	DWORD PTR $T1[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 265  : 	hemi_smooth				=	hemi_value*l_f + hemi_smooth*l_i;

	movss	DWORD PTR [ecx+1936], xmm1

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	movss	DWORD PTR [ecx+1944], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 72   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@get_sun:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 266  : 	sun_smooth				=	sun_value *l_f + sun_smooth *l_i;

	movss	xmm0, DWORD PTR [ecx+1944]
	movss	DWORD PTR $T1[esp+8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\lighttrack.h

; 72   : 	}

	fld	DWORD PTR $T1[esp+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?get_sun@CROS_impl@@QAEMXZ ENDP				; CROS_impl::get_sun
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
;	COMDAT ??__ERImplementation@@YAXXZ
text$di	SEGMENT
??__ERImplementation@@YAXXZ PROC			; `dynamic initializer for 'RImplementation'', COMDAT

; 282  : {

	call	??0R_dsgraph_structure@@QAE@XZ		; R_dsgraph_structure::R_dsgraph_structure
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+684
	mov	DWORD PTR ?RImplementation@@3VCRender@@A, OFFSET ??_7CRender@@6BIRender_interface@@@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+256, OFFSET ??_7CRender@@6BpureFrame@@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+660, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+664, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+668, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+672, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+676, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+680, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 282  : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 31   : {

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+712
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+876
	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 32   : 	bEnabled		= FALSE;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+744, 0

; 33   : 	m_pModel		= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+736, 0

; 34   : 	m_pTris			= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+740, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+884, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+888, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+892, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+896, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+900, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+904, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+908, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+912, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+916, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+920, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+924, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+928, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+932, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+936, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+940, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+944, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+948, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+952, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+956, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+960, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+964, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+968, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+972, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+976, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 282  : {

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1088, OFFSET ??_7cl_light_PR@@6B@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1092, OFFSET ??_7cl_light_C@@6B@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1096, OFFSET ??_7cl_light_XFORM@@6B@
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1100, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1104, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1108, 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 18   : CRender													RImplementation;

	push	OFFSET ??__FRImplementation@@YAXXZ	; `dynamic atexit destructor for 'RImplementation''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1104, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 18   : CRender													RImplementation;

	call	_atexit
	pop	ecx
	ret	0
??__ERImplementation@@YAXXZ ENDP			; `dynamic initializer for 'RImplementation''
text$di	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__FRImplementation@@YAXXZ
text$yd	SEGMENT
??__FRImplementation@@YAXXZ PROC			; `dynamic atexit destructor for 'RImplementation'', COMDAT
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	jmp	??1CRender@@UAE@XZ			; CRender::~CRender
??__FRImplementation@@YAXXZ ENDP			; `dynamic atexit destructor for 'RImplementation''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrRender_console.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_I$1 = -12						; size = 12
?create@CRender@@UAEXXZ PROC				; CRender::create
; _this$ = ecx

; 49   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 54   : 		I.Prio = priority;

	mov	DWORD PTR _I$1[esp+20], 1164413355	; 456789abH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 49   : {

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 55   : 		I.Flags = flags;

	mov	DWORD PTR _I$1[esp+32], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 50   : 	L_DB				= 0;

	mov	DWORD PTR [ebx+980], 0

; 51   : 	L_Shadows			= 0;
; 52   : 	L_Projector			= 0;
; 53   : 
; 54   : 	Device.seqFrame.Add	(this,REG_PRIORITY_HIGH+0x12345678);

	lea	ecx, DWORD PTR [ebx+256]
	mov	DWORD PTR [ebx+988], 0
	mov	DWORD PTR [ebx+992], 0
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	esi, 372				; 00000174H
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 53   : 		I.Object = obj;

	mov	DWORD PTR _I$1[esp+24], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN15@create
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 1164413355		; 456789abH
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 12			; 0000000cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN14@create
$LN15@create:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _I$1[esp+24]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
$LN14@create:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 58   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN9@create
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	jmp	SHORT $LN10@create
$LN9@create:

; 59   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ ; CRegistrator<pureFrame>::Resort
$LN10@create:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 57   : 	::Device.Resources->RegisterConstantSetup("L_dynamic_pos",		&r1_dlight_binder_PR);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	eax, DWORD PTR [ebx+1088]
	push	eax
	push	OFFSET ??_C@_0O@MLKAHID@L_dynamic_pos@
	mov	ecx, DWORD PTR [ecx+432]
	call	DWORD PTR __imp_?RegisterConstantSetup@CResourceManager@@QAEXPBDPAVR_constant_setup@@@Z

; 58   : 	::Device.Resources->RegisterConstantSetup("L_dynamic_color",	&r1_dlight_binder_color);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	eax, DWORD PTR [ebx+1092]
	push	eax
	push	OFFSET ??_C@_0BA@FNHAPCAE@L_dynamic_color@
	mov	ecx, DWORD PTR [ecx+432]
	call	DWORD PTR __imp_?RegisterConstantSetup@CResourceManager@@QAEXPBDPAVR_constant_setup@@@Z

; 59   : 	::Device.Resources->RegisterConstantSetup("L_dynamic_xform",	&r1_dlight_binder_xform);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	eax, DWORD PTR [ebx+1096]
	push	eax
	push	OFFSET ??_C@_0BA@PCGAPDHO@L_dynamic_xform@
	mov	ecx, DWORD PTR [ecx+432]
	call	DWORD PTR __imp_?RegisterConstantSetup@CResourceManager@@QAEXPBDPAVR_constant_setup@@@Z

; 62   : 	u32		v_dev	= CAP_VERSION(HW.Caps.raster_major, HW.Caps.raster_minor);

	mov	edx, DWORD PTR __imp_?HW@@3VCHW@@A
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	mov	esi, DWORD PTR __imp__strstr
	push	OFFSET ??_C@_0L@CBIMIPPL@?9nodistort@
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 62   : 	u32		v_dev	= CAP_VERSION(HW.Caps.raster_major, HW.Caps.raster_minor);

	movzx	eax, WORD PTR [edx+60]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx+62]
	lea	edi, DWORD PTR [eax+ecx*2]

; 63   : 	u32		v_need	= CAP_VERSION(1,4);

	mov	ecx, DWORD PTR [ebx+628]

; 66   : 	if (strstr(Core.Params,"-nodistort"))		o.distortion = FALSE;

	mov	eax, ecx
	or	ecx, 2
	and	eax, -3					; fffffffdH
	cmp	edi, 14					; 0000000eH
	cmovb	ecx, eax
	mov	DWORD PTR [ebx+628], ecx
	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1232				; 000004d0H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	eax
	call	esi
	mov	ecx, DWORD PTR [ebx+628]
	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 66   : 	if (strstr(Core.Params,"-nodistort"))		o.distortion = FALSE;

	test	eax, eax
	je	SHORT $LN126@create
	and	ecx, -3					; fffffffdH
	mov	DWORD PTR [ebx+628], ecx
$LN126@create:

; 67   : 	Msg				("* distortion: %s, dev(%d),need(%d)",o.distortion?"used":"unavailable",v_dev,v_need);

	test	cl, 2
	mov	eax, OFFSET ??_C@_04DOOIMPEH@used@
	push	14					; 0000000eH
	mov	ecx, OFFSET ??_C@_0M@JGJOANLK@unavailable@
	push	edi
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_0CD@DCBDPIBM@?$CK?5distortion?3?5?$CFs?0?5dev?$CI?$CFd?$CJ?0need?$CI@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 68   : 	m_skinning					= -1;

	mov	DWORD PTR [ebx+4], -1

; 71   : 	o.disasm					= (strstr(Core.Params,"-disasm"))?		TRUE	:FALSE	;

	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1232				; 000004d0H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	OFFSET ??_C@_07BDKAKIOP@?9disasm@
	push	eax
	call	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 71   : 	o.disasm					= (strstr(Core.Params,"-disasm"))?		TRUE	:FALSE	;

	mov	ecx, DWORD PTR [ebx+628]
	neg	eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	OFFSET ??_C@_06MLLEPAHM@?9skinw@
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 71   : 	o.disasm					= (strstr(Core.Params,"-disasm"))?		TRUE	:FALSE	;

	sbb	eax, eax
	and	ecx, -5					; fffffffbH
	and	eax, 4
	or	ecx, eax
	mov	DWORD PTR [ebx+628], ecx

; 72   : 	o.forceskinw				= (strstr(Core.Params,"-skinw"))?		TRUE	:FALSE	;

	mov	eax, DWORD PTR __imp_?Core@@3VxrCore@@A
	add	eax, 1232				; 000004d0H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	push	eax
	call	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 72   : 	o.forceskinw				= (strstr(Core.Params,"-skinw"))?		TRUE	:FALSE	;

	mov	ecx, DWORD PTR [ebx+628]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

	add	esp, 32					; 00000020H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 72   : 	o.forceskinw				= (strstr(Core.Params,"-skinw"))?		TRUE	:FALSE	;

	neg	eax
	sbb	eax, eax
	and	ecx, -9					; fffffff7H
	and	eax, 8
	or	ecx, eax
	mov	DWORD PTR [ebx+628], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	ecx, DWORD PTR __imp_?g_pStringContainer@@3PAVstr_container@@A
	push	OFFSET ??_C@_0BA@FMJGKLOA@L_dynamic_props@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?dock@str_container@@QAEPAUstr_value@@PBD@Z
	test	eax, eax
	je	SHORT $LN32@create
	inc	DWORD PTR [eax]
$LN32@create:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	ecx, DWORD PTR [ebx+1100]
	test	ecx, ecx
	je	SHORT $LN36@create
	dec	DWORD PTR [ecx]
$LN36@create:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	DWORD PTR [ebx+1100], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 76   : 	Target						= xr_new<CRenderTarget>		();

	call	??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ ; xr_new<CRenderTarget>
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 76   : 	Target						= xr_new<CRenderTarget>		();

	mov	DWORD PTR [ebx+1012], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	56					; 00000038H
	call	edi

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 192  : {

	mov	DWORD PTR [esi], OFFSET ??_7CModelPool@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	push	24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi+28], eax

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi+36], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 193  : 	bLogging				= TRUE;

	mov	DWORD PTR [esi+44], 1

; 194  :     bForceDiscard 			= FALSE;

	mov	DWORD PTR [esi+48], 0

; 195  :     bAllowChildrenDuplicate	= TRUE; 

	mov	DWORD PTR [esi+52], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	DWORD PTR __imp_??0motions_container@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 196  : 	g_pMotionsContainer		= xr_new<motions_container>();

	mov	ecx, DWORD PTR __imp_?g_pMotionsContainer@@3PAVmotions_container@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	52					; 00000034H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 196  : 	g_pMotionsContainer		= xr_new<motions_container>();

	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 79   : 	Models						= xr_new<CModelPool>		();

	mov	DWORD PTR [ebx+1008], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 322  : {

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7CLightR_Manager@@6B@
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+28], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 81   : 	PSLibrary.OnCreate			();

	lea	ecx, DWORD PTR [ebx+956]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 80   : 	L_Dynamic					= xr_new<CLightR_Manager>	();

	mov	DWORD PTR [ebx+984], esi

; 81   : 	PSLibrary.OnCreate			();

	call	?OnCreate@CPSLibrary@@QAEXXZ		; CPSLibrary::OnCreate
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrRender_console.cpp

; 760  : 	Console->Execute("r__tf_aniso");

	mov	ecx, DWORD PTR __imp_?Console@@3PAVCConsole@@A
	mov	esi, DWORD PTR __imp_?Execute@CConsole@@QAEXPBD@Z
	push	OFFSET ??_C@_0M@JGACHMFM@r__tf_aniso@
	mov	ecx, DWORD PTR [ecx]
	call	esi

; 761  : #if RENDER==R_R1
; 762  : 	Console->Execute("r1_tf_mipbias");

	mov	ecx, DWORD PTR __imp_?Console@@3PAVCConsole@@A
	push	OFFSET ??_C@_0O@DIJFHNPN@r1_tf_mipbias@
	mov	ecx, DWORD PTR [ecx]
	call	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__sector_traversal.cpp

; 68   : 	f_shader.create					("portal");

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06JAELEMPN@portal@
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	call	DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z

; 69   : 	f_geom.create					(FVF::F_L, RCache.Vertex.Buffer(), 0);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	push	DWORD PTR [eax]
	push	66					; 00000042H
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+180
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
	pop	edi
	pop	esi
	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 86   : }

	add	esp, 12					; 0000000cH
	ret	0
?create@CRender@@UAEXXZ ENDP				; CRender::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?destroy@CRender@@UAEXXZ PROC				; CRender::destroy
; _this$ = ecx

; 89   : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+180
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 89   : {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A+176
	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+180, 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 92   : 	PSLibrary.OnDestroy			();

	lea	ecx, DWORD PTR [esi+956]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+176, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 92   : 	PSLibrary.OnDestroy			();

	call	?OnDestroy@CPSLibrary@@QAEXXZ		; CPSLibrary::OnDestroy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi+984]
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN18@destroy

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi+984]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+984], 0
$LN18@destroy:

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi+1008]
	test	eax, eax
	je	SHORT $LN23@destroy

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi+1008]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+1008], 0
$LN23@destroy:

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi+1012]
	test	eax, eax
	je	SHORT $LN28@destroy

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi+1012]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+48]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+1012], 0
$LN28@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 99   : 	Device.seqFrame.Remove		(this);

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	eax, DWORD PTR [esi+256]
	mov	ebp, esi
	neg	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edx+372]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 99   : 	Device.seqFrame.Remove		(this);

	sbb	ebp, ebp
	add	edx, 372				; 00000174H
	and	ebp, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	test	eax, eax
	je	SHORT $LN34@destroy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	edi, edi
$LL35@destroy:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 64   : 			if (R[i].Object == obj) R[i].Prio = REG_PRIORITY_INVALID;

	cmp	DWORD PTR [edi+ecx], ebp
	lea	eax, DWORD PTR [edi+ecx]
	jne	SHORT $LN33@destroy
	mov	DWORD PTR [eax+4], -1
	mov	ecx, DWORD PTR [edx]
$LN33@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	add	edi, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	cmp	ebx, eax
	jb	SHORT $LL35@destroy
$LN34@destroy:

; 65   : 		}
; 66   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [edx+12]
	test	al, 1
	je	SHORT $LN37@destroy
	or	eax, 2
	mov	DWORD PTR [edx+12], eax
	jmp	SHORT $LN38@destroy
$LN37@destroy:

; 67   : 		else Resort();

	mov	ecx, edx
	call	?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ ; CRegistrator<pureFrame>::Resort
$LN38@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 102  : 		nrmVS.clear				();

	mov	eax, DWORD PTR [esi+400]

; 103  : 		nrmPS.clear				();
; 104  : 		nrmCS.clear				();
; 105  : 		nrmStates.clear			();
; 106  : 		nrmTextures.clear		();
; 107  : 		nrmTexturesTemp.clear	();
; 108  : 
; 109  : 		matVS.clear				();
; 110  : 		matPS.clear				();
; 111  : 		matCS.clear				();
; 112  : 		matStates.clear			();
; 113  : 		matTextures.clear		();
; 114  : 		matTexturesTemp.clear	();
; 115  : 
; 116  : 		lstLODs.clear			();
; 117  : 		lstLODgroups.clear		();
; 118  : 		lstRenderables.clear	();
; 119  : 		lstSpatial.clear		();
; 120  : 		lstVisuals.clear		();
; 121  : 
; 122  : 		lstRecorded.clear		();
; 123  : 
; 124  : 		mapNormal[0].destroy	();

	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR [esi+404], eax
	mov	eax, DWORD PTR [esi+412]
	mov	DWORD PTR [esi+416], eax
	mov	eax, DWORD PTR [esi+424]
	mov	DWORD PTR [esi+428], eax
	mov	eax, DWORD PTR [esi+436]
	mov	DWORD PTR [esi+440], eax
	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [esi+452], eax
	mov	eax, DWORD PTR [esi+460]
	mov	DWORD PTR [esi+464], eax
	mov	eax, DWORD PTR [esi+472]
	mov	DWORD PTR [esi+476], eax
	mov	eax, DWORD PTR [esi+484]
	mov	DWORD PTR [esi+488], eax
	mov	eax, DWORD PTR [esi+496]
	mov	DWORD PTR [esi+500], eax
	mov	eax, DWORD PTR [esi+508]
	mov	DWORD PTR [esi+512], eax
	mov	eax, DWORD PTR [esi+520]
	mov	DWORD PTR [esi+524], eax
	mov	eax, DWORD PTR [esi+532]
	mov	DWORD PTR [esi+536], eax
	mov	eax, DWORD PTR [esi+544]
	mov	DWORD PTR [esi+548], eax
	mov	eax, DWORD PTR [esi+556]
	mov	DWORD PTR [esi+560], eax
	mov	eax, DWORD PTR [esi+568]
	mov	DWORD PTR [esi+572], eax
	mov	eax, DWORD PTR [esi+580]
	mov	DWORD PTR [esi+584], eax
	mov	eax, DWORD PTR [esi+592]
	mov	DWORD PTR [esi+596], eax
	mov	eax, DWORD PTR [esi+604]
	mov	DWORD PTR [esi+608], eax
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy

; 125  : 		mapNormal[1].destroy	();

	lea	ecx, DWORD PTR [esi+316]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy

; 126  : 		mapMatrix[0].destroy	();

	lea	ecx, DWORD PTR [esi+328]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy

; 127  : 		mapMatrix[1].destroy	();

	lea	ecx, DWORD PTR [esi+340]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+352]
	test	ecx, ecx
	je	SHORT $LN84@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+352], 0
$LN84@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+364]
	test	ecx, ecx
	je	SHORT $LN94@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+364], 0
$LN94@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+376]
	test	ecx, ecx
	je	SHORT $LN104@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+376], 0
$LN104@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+388]
	test	ecx, ecx
	je	SHORT $LN114@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+388], 0
$LN114@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 102  : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?destroy@CRender@@UAEXXZ ENDP				; CRender::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?reset_begin@CRender@@UAEXXZ PROC			; CRender::reset_begin
; _this$ = ecx

; 105  : {

	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi+1012]
	test	eax, eax
	je	SHORT $LN4@reset_begi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi+1012]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+48]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi+1012], 0
	pop	esi
$LN4@reset_begi:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 108  : }

	ret	0
?reset_begin@CRender@@UAEXXZ ENDP			; CRender::reset_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrRender_console.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?reset_end@CRender@@UAEXXZ PROC				; CRender::reset_end
; _this$ = ecx

; 111  : {

	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrRender_console.cpp

; 760  : 	Console->Execute("r__tf_aniso");

	mov	ecx, DWORD PTR __imp_?Console@@3PAVCConsole@@A
	push	OFFSET ??_C@_0M@JGACHMFM@r__tf_aniso@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?Execute@CConsole@@QAEXPBD@Z

; 761  : #if RENDER==R_R1
; 762  : 	Console->Execute("r1_tf_mipbias");

	mov	ecx, DWORD PTR __imp_?Console@@3PAVCConsole@@A
	push	OFFSET ??_C@_0O@DIJFHNPN@r1_tf_mipbias@
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?Execute@CConsole@@QAEXPBD@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 114  : 	Target						=	xr_new<CRenderTarget>	();

	call	??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ ; xr_new<CRenderTarget>

; 115  : 	if (L_Projector)			L_Projector->invalidate		();

	mov	ecx, DWORD PTR [edi+992]
	mov	DWORD PTR [edi+1012], eax
	pop	edi
	test	ecx, ecx
	jne	?invalidate@CLightProjector@@QAEXXZ	; CLightProjector::invalidate

; 116  : }

	ret	0
?reset_end@CRender@@UAEXXZ ENDP				; CRender::reset_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?OnFrame@CRender@@UAEXXZ PROC				; CRender::OnFrame
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi

; 120  : 	Models->DeleteQueue	();

	mov	esi, DWORD PTR [ecx+752]
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 315  : 	for (u32 it=0; it<ModelsToDelete.size(); it++)

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 315  : 	for (u32 it=0; it<ModelsToDelete.size(); it++)

	test	eax, eax
	je	SHORT $LN33@OnFrame
	npad	1
$LL6@OnFrame:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 316  : 		DeleteInternal(ModelsToDelete[it]);

	mov	ecx, esi
	push	0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	eax, DWORD PTR [eax+edi*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 316  : 		DeleteInternal(ModelsToDelete[it]);

	push	eax
	call	?DeleteInternal@CModelPool@@QAEXAAPAVIRender_Visual@@H@Z ; CModelPool::DeleteInternal
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 315  : 	for (u32 it=0; it<ModelsToDelete.size(); it++)

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 315  : 	for (u32 it=0; it<ModelsToDelete.size(); it++)

	cmp	edi, eax
	jb	SHORT $LL6@OnFrame
$LN33@OnFrame:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 129  : }

	pop	edi
	mov	DWORD PTR [esi+20], ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?OnFrame@CRender@@UAEXXZ ENDP				; CRender::OnFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?ros_create@CRender@@UAEPAVIRender_ObjectSpecific@@PAVIRenderable@@@Z PROC ; CRender::ros_create
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 132  : IRender_ObjectSpecific*	CRender::ros_create				(IRenderable* parent)					{ return xr_new<CROS_impl>();			}

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	1960					; 000007a8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	mov	edx, 26					; 0000001aH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [esi], OFFSET ??_7CROS_impl@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	eax, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	npad	1
$LL26@ros_create:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax-16], 0
	lea	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [eax-80], 0
	mov	DWORD PTR [eax-76], 0
	mov	DWORD PTR [eax-72], 0
	mov	DWORD PTR [eax-68], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 34   : 			range = 0;

	mov	DWORD PTR [eax-64], 0

; 35   : 			result = FALSE;

	mov	DWORD PTR [eax-60], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-24], 0
	sub	edx, 1
	jne	$LL26@ros_create
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	ecx, DWORD PTR [esi+1836]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1948], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 132  : IRender_ObjectSpecific*	CRender::ros_create				(IRenderable* parent)					{ return xr_new<CROS_impl>();			}

	mov	eax, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1952], 0
	mov	DWORD PTR [esi+1956], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 23   : 	dwFrame				= u32(-1);

	mov	DWORD PTR [esi+8], -1

; 24   : 	shadow_recv_frame	= u32(-1);

	mov	DWORD PTR [esi+1924], -1

; 25   : 	shadow_recv_slot	= -1;

	mov	DWORD PTR [esi+1928], -1

; 26   : 
; 27   : 	result_count		= 0;

	mov	DWORD PTR [esi+1904], 0

; 28   : 	result_iterator		= 0;

	mov	DWORD PTR [esi+1908], 0

; 29   : 	result_frame		= u32(-1);

	mov	DWORD PTR [esi+1912], -1

; 30   : 	result_sun			= 0;

	mov	DWORD PTR [esi+1916], 0

; 31   : 	hemi_value			= 0.5f;

	mov	DWORD PTR [esi+1932], 1056964608	; 3f000000H

; 32   : 	hemi_smooth			= 0.5f;

	mov	DWORD PTR [esi+1936], 1056964608	; 3f000000H

; 33   : 	sun_value			= 0.2f;

	mov	DWORD PTR [esi+1940], 1045220557	; 3e4ccccdH

; 34   : 	sun_smooth			= 0.2f;

	mov	DWORD PTR [esi+1944], 1045220557	; 3e4ccccdH

; 35   : 
; 36   : #if RENDER==R_R1
; 37   : 	MODE				= IRender_ObjectSpecific::TRACE_ALL											;

	mov	DWORD PTR [esi+4], 7
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 132  : IRender_ObjectSpecific*	CRender::ros_create				(IRenderable* parent)					{ return xr_new<CROS_impl>();			}

	pop	esi
	ret	4
?ros_create@CRender@@UAEPAVIRender_ObjectSpecific@@PAVIRenderable@@@Z ENDP ; CRender::ros_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ros_destroy@CRender@@UAEXAAPAVIRender_ObjectSpecific@@@Z PROC ; CRender::ros_destroy
; _this$ = ecx

; 133  : void					CRender::ros_destroy			(IRender_ObjectSpecific* &p)			{ xr_delete(p);							}

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	edi, DWORD PTR _p$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@ros_destro

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+12]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN4@ros_destro:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 133  : void					CRender::ros_destroy			(IRender_ObjectSpecific* &p)			{ xr_delete(p);							}

	ret	4
?ros_destroy@CRender@@UAEXAAPAVIRender_ObjectSpecific@@@Z ENDP ; CRender::ros_destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_data$ = 12						; size = 4
?model_Create@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z PROC ; CRender::model_Create
; _this$ = ecx

; 134  : IRender_Visual*			CRender::model_Create			(LPCSTR name, IReader* data)			{ return Models->Create(name,data);		}

	mov	ecx, DWORD PTR [ecx+1008]
	jmp	?Create@CModelPool@@QAEPAVIRender_Visual@@PBDPAVIReader@@@Z ; CModelPool::Create
?model_Create@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z ENDP ; CRender::model_Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_H$1 = -300						; size = 44
_low_name$2 = -256					; size = 256
_name$ = 8						; size = 4
_data$ = 12						; size = 4
?model_CreateChild@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z PROC ; CRender::model_CreateChild
; _this$ = ecx

; 135  : IRender_Visual*			CRender::model_CreateChild		(LPCSTR name, IReader* data)			{ return Models->CreateChild(name,data);}

	sub	esp, 300				; 0000012cH
	lea	edx, DWORD PTR _low_name$2[esp+300]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+1008]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 262  : 	strcpy(low_name,name);	strlwr	(low_name);

	mov	ecx, DWORD PTR _name$[esp+308]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 135  : IRender_Visual*			CRender::model_CreateChild		(LPCSTR name, IReader* data)			{ return Models->CreateChild(name,data);}

	sub	edx, ecx
	npad	4
$LL12@model_Crea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 262  : 	strcpy(low_name,name);	strlwr	(low_name);

	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx+ecx-1], al
	test	al, al
	jne	SHORT $LL12@model_Crea
	lea	eax, DWORD PTR _low_name$2[esp+312]
	push	eax
	call	DWORD PTR __imp__strlwr
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 171  : {	return (char*) strrchr(S,'.');	}

	mov	esi, DWORD PTR __imp__strrchr
	lea	eax, DWORD PTR _low_name$2[esp+316]
	push	46					; 0000002eH
	push	eax
	call	esi
	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 263  : 	if (strext(low_name))	*strext	(low_name) = 0;

	test	eax, eax
	je	SHORT $LN7@model_Crea
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 171  : {	return (char*) strrchr(S,'.');	}

	lea	eax, DWORD PTR _low_name$2[esp+312]
	push	46					; 0000002eH
	push	eax
	call	esi
	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 263  : 	if (strext(low_name))	*strext	(low_name) = 0;

	mov	BYTE PTR [eax], 0
$LN7@model_Crea:

; 264  : 
; 265  : 	// 1. Search for already loaded model
; 266  : 	IRender_Visual* Base	= Instance_Find(low_name);

	lea	eax, DWORD PTR _low_name$2[esp+312]
	mov	ecx, edi
	push	eax
	call	?Instance_Find@CModelPool@@QAEPAVIRender_Visual@@PBD@Z ; CModelPool::Instance_Find
	mov	esi, eax

; 267  : //.	if (0==Base) Base	 	= Instance_Load(name,data,FALSE);
; 268  : 	if(0==Base)

	test	esi, esi
	jne	SHORT $LN10@model_Crea

; 269  : 	{
; 270  : 		if (data)		Base = Instance_Load	(low_name,data,FALSE);

	mov	ebx, DWORD PTR _data$[esp+308]
	test	ebx, ebx
	je	SHORT $LN9@model_Crea

; 142  : 	data->r_chunk_safe	(OGF_HEADER,&H,sizeof(H));

	push	44					; 0000002cH
	lea	eax, DWORD PTR _H$1[esp+316]
	mov	ecx, ebx
	push	eax
	push	1
	call	DWORD PTR __imp_?r_chunk_safe@?$IReaderBase@VIReader@@@@QAEHIPAXI@Z

; 143  : 	V = Instance_Create (H.type);

	movzx	eax, BYTE PTR _H$1[esp+313]
	push	eax
	call	?Instance_Create@CModelPool@@QAEPAVIRender_Visual@@I@Z ; CModelPool::Instance_Create
	mov	esi, eax

; 144  : 	V->Load				(name,data,0);

	lea	ecx, DWORD PTR _low_name$2[esp+312]
	push	0
	push	ebx
	push	ecx
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 270  : 		if (data)		Base = Instance_Load	(low_name,data,FALSE);

	jmp	SHORT $LN10@model_Crea
$LN9@model_Crea:

; 271  : 		else			Base = Instance_Load	(low_name,FALSE);

	push	0
	lea	eax, DWORD PTR _low_name$2[esp+316]
	mov	ecx, edi
	push	eax
	call	?Instance_Load@CModelPool@@QAEPAVIRender_Visual@@PBDH@Z ; CModelPool::Instance_Load
	mov	esi, eax
$LN10@model_Crea:

; 272  : 	}
; 273  : 
; 274  :     IRender_Visual* Model	= bAllowChildrenDuplicate?Instance_Duplicate(Base):Base;

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN13@model_Crea

; 83   : 	R_ASSERT(V);

	cmp	BYTE PTR ?ignore_always@?3??Instance_Duplicate@CModelPool@@QAEPAVIRender_Visual@@PAV3@@Z@4_NA, 0
	jne	SHORT $LN23@model_Crea
	test	esi, esi
	jne	SHORT $LN23@model_Crea
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Instance_Duplicate@CModelPool@@QAEPAVIRender_Visual@@PAV3@@Z@4_NA
	push	OFFSET ??_C@_0BP@KMCMNMJD@CModelPool?3?3Instance_Duplicate@
	push	83					; 00000053H
	push	OFFSET ??_C@_0DJ@HJNKECDB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_01FCMHBHNC@V@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN23@model_Crea:

; 84   : 	IRender_Visual* N		= Instance_Create(V->Type);

	push	DWORD PTR [esi+4]
	call	?Instance_Create@CModelPool@@QAEPAVIRender_Visual@@I@Z ; CModelPool::Instance_Create
	mov	ebx, eax

; 85   : 	N->Copy			(V);

	push	esi
	mov	ecx, ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+12]

; 86   : 	N->Spawn		();

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 88   : 	for (xr_vector<ModelDef>::iterator I=Models.begin(); I!=Models.end(); I++) 

	je	SHORT $LN27@model_Crea
$LL28@model_Crea:

; 89   : 		if (I->model==V){ I->refs++; break;}

	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN54@model_Crea
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	eax, 12					; 0000000cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 88   : 	for (xr_vector<ModelDef>::iterator I=Models.begin(); I!=Models.end(); I++) 

	jne	SHORT $LL28@model_Crea
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 135  : IRender_Visual*			CRender::model_CreateChild		(LPCSTR name, IReader* data)			{ return Models->CreateChild(name,data);}

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	add	esp, 300				; 0000012cH
	ret	8
$LN54@model_Crea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 89   : 		if (I->model==V){ I->refs++; break;}

	inc	DWORD PTR [eax+8]
$LN27@model_Crea:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 135  : IRender_Visual*			CRender::model_CreateChild		(LPCSTR name, IReader* data)			{ return Models->CreateChild(name,data);}

	pop	esi
	mov	eax, ebx
	pop	ebx
	add	esp, 300				; 0000012cH
	ret	8
$LN13@model_Crea:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	ret	8
?model_CreateChild@CRender@@UAEPAVIRender_Visual@@PBDPAVIReader@@@Z ENDP ; CRender::model_CreateChild
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_V$ = 8							; size = 4
?model_Duplicate@CRender@@UAEPAVIRender_Visual@@PAV2@@Z PROC ; CRender::model_Duplicate
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 83   : 	R_ASSERT(V);

	cmp	BYTE PTR ?ignore_always@?3??Instance_Duplicate@CModelPool@@QAEPAVIRender_Visual@@PAV3@@Z@4_NA, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 136  : IRender_Visual*			CRender::model_Duplicate		(IRender_Visual* V)						{ return Models->Instance_Duplicate(V);	}

	push	ebx
	mov	ebx, DWORD PTR [ecx+1008]
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 83   : 	R_ASSERT(V);

	mov	esi, DWORD PTR _V$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 136  : IRender_Visual*			CRender::model_Duplicate		(IRender_Visual* V)						{ return Models->Instance_Duplicate(V);	}

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 83   : 	R_ASSERT(V);

	jne	SHORT $LN4@model_Dupl
	test	esi, esi
	jne	SHORT $LN4@model_Dupl
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Instance_Duplicate@CModelPool@@QAEPAVIRender_Visual@@PAV3@@Z@4_NA
	push	OFFSET ??_C@_0BP@KMCMNMJD@CModelPool?3?3Instance_Duplicate@
	push	83					; 00000053H
	push	OFFSET ??_C@_0DJ@HJNKECDB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_01FCMHBHNC@V@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
$LN4@model_Dupl:

; 84   : 	IRender_Visual* N		= Instance_Create(V->Type);

	push	DWORD PTR [esi+4]
	call	?Instance_Create@CModelPool@@QAEPAVIRender_Visual@@I@Z ; CModelPool::Instance_Create
	mov	edi, eax

; 85   : 	N->Copy			(V);

	push	esi
	mov	ecx, edi
	mov	edx, DWORD PTR [edi]
	call	DWORD PTR [edx+12]

; 86   : 	N->Spawn		();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR [ebx+4]

; 150  :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR [ebx+8]
	cmp	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 88   : 	for (xr_vector<ModelDef>::iterator I=Models.begin(); I!=Models.end(); I++) 

	je	SHORT $LN38@model_Dupl
	npad	1
$LL9@model_Dupl:

; 89   : 		if (I->model==V){ I->refs++; break;}

	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN34@model_Dupl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	eax, 12					; 0000000cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 88   : 	for (xr_vector<ModelDef>::iterator I=Models.begin(); I!=Models.end(); I++) 

	jne	SHORT $LL9@model_Dupl
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 136  : IRender_Visual*			CRender::model_Duplicate		(IRender_Visual* V)						{ return Models->Instance_Duplicate(V);	}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN34@model_Dupl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 89   : 		if (I->model==V){ I->refs++; break;}

	inc	DWORD PTR [eax+8]
$LN38@model_Dupl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 136  : IRender_Visual*			CRender::model_Duplicate		(IRender_Visual* V)						{ return Models->Instance_Duplicate(V);	}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
?model_Duplicate@CRender@@UAEPAVIRender_Visual@@PAV2@@Z ENDP ; CRender::model_Duplicate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_V$ = 8							; size = 4
_bDiscard$ = 12						; size = 4
?model_Delete@CRender@@UAEXAAPAVIRender_Visual@@H@Z PROC ; CRender::model_Delete
; _this$ = ecx

; 137  : void					CRender::model_Delete			(IRender_Visual* &V, BOOL bDiscard)		{ Models->Delete(V,bDiscard);			}

	mov	ecx, DWORD PTR [ecx+1008]
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 303  : 	if (NULL==V)				return;

	mov	esi, DWORD PTR _V$[esp]
	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN3@model_Dele

; 304  : 	if (g_bRendering){

	mov	eax, DWORD PTR __imp_?g_bRendering@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@model_Dele
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 306  : 		ModelsToDelete.push_back(V);

	add	ecx, 16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN14@model_Dele

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 310  : 	V							=	NULL;

	mov	DWORD PTR [esi], 0
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 137  : void					CRender::model_Delete			(IRender_Visual* &V, BOOL bDiscard)		{ Models->Delete(V,bDiscard);			}

	ret	8
$LN14@model_Dele:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	esi
	push	eax
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 310  : 	V							=	NULL;

	mov	DWORD PTR [esi], 0
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 137  : void					CRender::model_Delete			(IRender_Visual* &V, BOOL bDiscard)		{ Models->Delete(V,bDiscard);			}

	ret	8
$LN8@model_Dele:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 308  : 		DeleteInternal			(V,bDiscard);

	push	DWORD PTR _bDiscard$[esp]
	push	esi
	call	?DeleteInternal@CModelPool@@QAEXAAPAVIRender_Visual@@H@Z ; CModelPool::DeleteInternal

; 310  : 	V							=	NULL;

	mov	DWORD PTR [esi], 0
$LN3@model_Dele:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 137  : void					CRender::model_Delete			(IRender_Visual* &V, BOOL bDiscard)		{ Models->Delete(V,bDiscard);			}

	ret	8
?model_Delete@CRender@@UAEXAAPAVIRender_Visual@@H@Z ENDP ; CRender::model_Delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_F$ = 8							; size = 4
?model_CreateDM@CRender@@UAEPAVIRender_DetailModel@@PAVIReader@@@Z PROC ; CRender::model_CreateDM
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 139  : {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	76					; 0000004cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	push	76					; 0000004cH
	mov	esi, eax
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	call	DWORD PTR __imp_??0IRender_DetailModel@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 141  : 	D->Load				(F);

	push	DWORD PTR _F$[esp]
	mov	ecx, esi
	mov	DWORD PTR [esi], OFFSET ??_7CDetail@@6B@
	call	?Load@CDetail@@QAEXPAVIReader@@@Z	; CDetail::Load

; 142  : 	return D;

	mov	eax, esi
	pop	esi

; 143  : }

	ret	4
?model_CreateDM@CRender@@UAEPAVIRender_DetailModel@@PAVIReader@@@Z ENDP ; CRender::model_CreateDM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_F$ = 8							; size = 4
?model_Delete@CRender@@UAEXAAPAVIRender_DetailModel@@@Z PROC ; CRender::model_Delete
; _this$ = ecx

; 145  : {

	push	ebx

; 146  : 	if (F)

	mov	ebx, DWORD PTR _F$[esp]
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN2@model_Dele

; 147  : 	{
; 148  : 		CDetail*	D	= (CDetail*)F;
; 149  : 		D->Unload		();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	esi
	call	DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	edi
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	edx, DWORD PTR [edi]
	add	esp, 4
	mov	ecx, edi
	mov	esi, eax
	push	0
	call	DWORD PTR [edx+8]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 151  : 		F				= NULL;

	mov	DWORD PTR [ebx], 0
	pop	esi
$LN2@model_Dele:

; 152  : 	}
; 153  : }

	pop	edi
	pop	ebx
	ret	4
?model_Delete@CRender@@UAEXAAPAVIRender_DetailModel@@@Z ENDP ; CRender::model_Delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_it$1 = 8						; size = 4
_it$2 = 8						; size = 4
_name$ = 8						; size = 4
?model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z PROC ; CRender::model_CreateParticles
; _this$ = ecx

; 161  : { 

	push	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	mov	ebx, DWORD PTR _name$[esp]
	lea	eax, DWORD PTR _it$2[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 161  : { 

	push	esi

; 162  : 	PS::CPEDef*	SE		= PSLibrary.FindPED	(name);

	lea	esi, DWORD PTR [ecx+956]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 61   : 	PS::PEDIt it = FindPEDIt(Name);

	push	ebx
	push	eax
	mov	ecx, esi
	call	?FindPEDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPEDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$2[esp+4]
	cmp	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 62   :     return (it==m_PEDs.end())?0:*it;

	je	SHORT $LN5@model_Crea
	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 163  : 	if (SE) return		Models->CreatePE	(SE);

	test	eax, eax
	je	SHORT $LN5@model_Crea

; 167  : 	}
; 168  : }

	pop	esi
	pop	ebx

; 163  : 	if (SE) return		Models->CreatePE	(SE);

	mov	DWORD PTR _name$[esp-4], eax
	jmp	?CreatePE@CModelPool@@QAEPAVIRender_Visual@@PAVCPEDef@PS@@@Z ; CModelPool::CreatePE
$LN5@model_Crea:
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 81   : 	PS::PGDIt it = FindPGDIt(Name);

	push	ebx
	lea	eax, DWORD PTR _it$1[esp+12]
	mov	ecx, esi
	push	eax
	call	?FindPGDIt@CPSLibrary@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@@std@@PBD@Z ; CPSLibrary::FindPGDIt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR _it$1[esp+8]
	cmp	eax, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.cpp

; 82   :     return (it==m_PGDs.end())?0:*it;

	jne	SHORT $LN23@model_Crea
	xor	edi, edi
	jmp	SHORT $LN24@model_Crea
$LN23@model_Crea:
	mov	edi, DWORD PTR [eax]
$LN24@model_Crea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 165  : 		PS::CPGDef*	SG	= PSLibrary.FindPGD	(name);		R_ASSERT3(SG,"Particle effect or group doesn't exist",name);

	cmp	BYTE PTR ?ignore_always@?7??model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z@4_NA, 0
	jne	SHORT $LN2@model_Crea
	test	edi, edi
	jne	SHORT $LN2@model_Crea
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z@4_NA
	push	OFFSET ??_C@_0BP@GFBDPMDM@CRender?3?3model_CreateParticles@
	push	165					; 000000a5H
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	ebx
	push	OFFSET ??_C@_0CH@CNEGHEIB@Particle?5effect?5or?5group?5doesn?8@
	push	OFFSET ??_C@_02NBHMGPMG@SG@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD000H0AA_N@Z
$LN2@model_Crea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	108					; 0000006cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ParticleGroup.cpp

; 367  : {

	mov	ecx, esi
	call	DWORD PTR __imp_??0IParticleCustom@@QAE@XZ
	mov	DWORD PTR [esi], OFFSET ??_7CParticleGroup@PS@@6B@
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 403  : 	V->Compile		(source);

	mov	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 15   :     IC	SelfRef	zero	()											{ flags=T(0);	return *this;	}

	mov	BYTE PTR [esi+104], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 403  : 	V->Compile		(source);

	push	edi

; 77   : 	V->Type		= type;

	mov	DWORD PTR [esi+4], 9

; 403  : 	V->Compile		(source);

	call	?Compile@CParticleGroup@PS@@QAEHPAVCPGDef@2@@Z ; PS::CParticleGroup::Compile
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 166  : 		return			Models->CreatePG	(SG);

	pop	edi
	mov	eax, esi
	pop	esi

; 167  : 	}
; 168  : }

	pop	ebx
	ret	4
?model_CreateParticles@CRender@@UAEPAVIRender_Visual@@PBD@Z ENDP ; CRender::model_CreateParticles
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_V$1 = -260						; size = 4
_section$2 = -256					; size = 256
?models_Prefetch@CRender@@UAEXXZ PROC			; CRender::models_Prefetch
; _this$ = ecx

; 169  : void					CRender::models_Prefetch		()					{ Models->Prefetch	();}

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 373  : 	strconcat				(sizeof(section),section,"prefetch_visuals_",g_pGamePersistent->m_game_params.m_game_type);

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 169  : void					CRender::models_Prefetch		()					{ Models->Prefetch	();}

	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+1008]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 370  : 	Logging					(FALSE);

	mov	DWORD PTR [edi+44], 0

; 373  : 	strconcat				(sizeof(section),section,"prefetch_visuals_",g_pGamePersistent->m_game_params.m_game_type);

	mov	eax, DWORD PTR [eax]
	add	eax, 292				; 00000124H
	push	eax
	push	OFFSET ??_C@_0BC@DJGLAOAH@prefetch_visuals_@
	lea	eax, DWORD PTR _section$2[esp+280]
	push	eax
	push	256					; 00000100H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD1@Z

; 374  : 	CInifile::Sect& sect	= pSettings->r_section(section);

	mov	ecx, DWORD PTR __imp_?pSettings@@3PAVCInifile@@A
	lea	eax, DWORD PTR _section$2[esp+288]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?r_section@CInifile@@QAEAAUSect@1@PBD@Z
	mov	ebx, eax

; 375  : 	for (CInifile::SectCIt I=sect.Data.begin(); I!=sect.Data.end(); I++)	{

	mov	esi, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 375  : 	for (CInifile::SectCIt I=sect.Data.begin(); I!=sect.Data.end(); I++)	{

	je	SHORT $LN51@models_Pre
	npad	2
$LL6@models_Pre:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 377  : 		IRender_Visual* V	= Create(item.first.c_str());

	push	0
	lea	eax, DWORD PTR [ecx+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
	mov	ecx, edi
	call	?Create@CModelPool@@QAEPAVIRender_Visual@@PBDPAVIReader@@@Z ; CModelPool::Create
	mov	edx, eax
	mov	DWORD PTR _V$1[esp+272], edx

; 303  : 	if (NULL==V)				return;

	test	edx, edx
	je	SHORT $LN4@models_Pre

; 304  : 	if (g_bRendering){

	mov	ecx, DWORD PTR __imp_?g_bRendering@@3HA
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN37@models_Pre
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 306  : 		ModelsToDelete.push_back(V);

	lea	ecx, DWORD PTR [edi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN43@models_Pre

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN4@models_Pre
$LN43@models_Pre:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _V$1[esp+272]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVIRender_Visual@@@?$vector@PAVIRender_Visual@@V?$xalloc@PAVIRender_Visual@@@@@std@@QAEPAPAVIRender_Visual@@QAPAV2@ABQAV2@@Z ; std::vector<IRender_Visual *,xalloc<IRender_Visual *> >::_Emplace_reallocate<IRender_Visual * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 307  : 	} else {

	jmp	SHORT $LN4@models_Pre
$LN37@models_Pre:

; 308  : 		DeleteInternal			(V,bDiscard);

	push	0
	lea	eax, DWORD PTR _V$1[esp+276]
	mov	ecx, edi
	push	eax
	call	?DeleteInternal@CModelPool@@QAEXAAPAVIRender_Visual@@H@Z ; CModelPool::DeleteInternal
$LN4@models_Pre:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 8

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 375  : 	for (CInifile::SectCIt I=sect.Data.begin(); I!=sect.Data.end(); I++)	{

	jne	SHORT $LL6@models_Pre
$LN51@models_Pre:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 169  : void					CRender::models_Prefetch		()					{ Models->Prefetch	();}

	mov	DWORD PTR [edi+44], 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?models_Prefetch@CRender@@UAEXXZ ENDP			; CRender::models_Prefetch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
__I$1 = -4						; size = 4
_b_complete$ = 8					; size = 4
?models_Clear@CRender@@UAEXH@Z PROC			; CRender::models_Clear
; _this$ = ecx

; 170  : void					CRender::models_Clear			(BOOL b_complete)	{ Models->ClearPool	(b_complete);}

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR [ecx+1008]
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1135 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	esi, DWORD PTR [ebx+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 170  : void					CRender::models_Clear			(BOOL b_complete)	{ Models->ClearPool	(b_complete);}

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1135 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	lea	edi, DWORD PTR [ebx+36]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __I$1[esp+16], eax
	cmp	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 387  : 	for (;_I!=_E;_I++)	{

	je	SHORT $LN5@models_Cle
	push	ebp
	mov	ebp, DWORD PTR _b_complete$[esp+16]
	npad	1
$LL6@models_Cle:

; 388  : 		Discard	(_I->second, b_complete)	;

	push	ebp
	add	eax, 20					; 00000014H
	mov	ecx, ebx
	push	eax
	call	?Discard@CModelPool@@QAEXAAPAVIRender_Visual@@H@Z ; CModelPool::Discard
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 199  :         _Mybase::operator++();

	lea	ecx, DWORD PTR __I$1[esp+20]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVshared_str@@PAVIRender_Visual@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<shared_str const ,IRender_Visual *> > >,std::_Iterator_base0>::operator++

; 233  :         return this->_Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __I$1[esp+20]
	cmp	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 387  : 	for (;_I!=_E;_I++)	{

	jne	SHORT $LL6@models_Cle
	pop	ebp
$LN5@models_Cle:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1342 :         auto _Head = _Scary->_Myhead;

	mov	esi, DWORD PTR [edi]

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	ecx, edi
	push	DWORD PTR [esi+4]
	push	edi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@U?$pair@$$CBVshared_str@@PAVIRender_Visual@@@std@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVshared_str@@PAVIRender_Visual@@@std@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@U?$pair@$$CBVshared_str@@PAVIRender_Visual@@@std@@PAX@std@@@@PAU?$_Tree_node@U?$pair@$$CBVshared_str@@PAVIRender_Visual@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<shared_str const ,IRender_Visual *> > >::_Erase_tree<xalloc<std::_Tree_node<std::pair<shared_str const ,IRender_Visual *>,void *> > >

; 1344 :         _Head->_Parent  = _Head;

	mov	DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

	mov	DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

	mov	DWORD PTR [esi+8], esi

; 1347 :         _Scary->_Mysize = 0;

	mov	DWORD PTR [edi+4], 0
	pop	edi
	pop	esi
	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 170  : void					CRender::models_Clear			(BOOL b_complete)	{ Models->ClearPool	(b_complete);}

	pop	ecx
	ret	4
?models_Clear@CRender@@UAEXH@Z ENDP			; CRender::models_Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_id$ = 12						; size = 4
?getShader@CRender@@UAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@H@Z PROC ; CRender::getShader
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _id$[esp-4]
	mov	ecx, DWORD PTR [ecx+896]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN25@getShader
	inc	DWORD PTR [ecx]
$LN25@getShader:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 172  : ref_shader				CRender::getShader				(int id)			{ VERIFY(id<int(Shaders.size()));	return Shaders[id];	}

	ret	8
?getShader@CRender@@UAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@H@Z ENDP ; CRender::getShader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?getSector@CRender@@UAEPAVIRender_Sector@@H@Z PROC	; CRender::getSector
; _this$ = ecx

; 174  : IRender_Sector*			CRender::getSector				(int id)			{ VERIFY(id<int(Sectors.size()));	return Sectors[id];	}

	mov	ecx, DWORD PTR [ecx+672]
	mov	eax, DWORD PTR _id$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4]
	ret	4
?getSector@CRender@@UAEPAVIRender_Sector@@H@Z ENDP	; CRender::getSector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?getTarget@CRender@@UAEPAVIRender_Target@@XZ PROC	; CRender::getTarget
; _this$ = ecx

; 180  : IRender_Target*			CRender::getTarget				()					{ return Target;										}

	mov	eax, DWORD PTR [ecx+1012]
	ret	0
?getTarget@CRender@@UAEPAVIRender_Target@@XZ ENDP	; CRender::getTarget
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?light_create@CRender@@UAEPAVIRender_Light@@XZ PROC	; CRender::light_create
; _this$ = ecx

; 183  : IRender_Light*			CRender::light_create			()					{ return L_DB->Create();								}

	jmp	?Create@CLight_DB@@QAEPAVlight@@XZ	; CLight_DB::Create
?light_create@CRender@@UAEPAVIRender_Light@@XZ ENDP	; CRender::light_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?glow_create@CRender@@UAEPAVIRender_Glow@@XZ PROC	; CRender::glow_create
; _this$ = ecx

; 185  : IRender_Glow*			CRender::glow_create			()					{ return xr_new<CGlow>();								}

	jmp	??$xr_new@VCGlow@@@@YAPAVCGlow@@XZ	; xr_new<CGlow>
?glow_create@CRender@@UAEPAVIRender_Glow@@XZ ENDP	; CRender::glow_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?flush@CRender@@UAEXXZ PROC				; CRender::flush
; _this$ = ecx

; 187  : void					CRender::flush					()					{ r_dsgraph_render_graph	(0);						}

	push	1
	push	0
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph
	ret	0
?flush@CRender@@UAEXXZ ENDP				; CRender::flush
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_P$ = 8							; size = 4
?occ_visible@CRender@@UAEHAAUvis_data@@@Z PROC		; CRender::occ_visible
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	esi, DWORD PTR _P$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	edi, DWORD PTR [eax+244]
	cmp	edi, DWORD PTR [esi+48]
	jae	SHORT $LN4@occ_visibl
$LN154@occ_visibl:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	mov	eax, 1
	pop	esi
	ret	4
$LN4@occ_visibl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 289  : 	if (!bEnabled)						return TRUE;				// return - everything visible

	cmp	DWORD PTR [ecx+744], 0
	je	SHORT $LN154@occ_visibl

; 290  : 	
; 291  : 	// Now, the test time comes
; 292  : 	// 0. The object was hidden, and we must prove that each frame	- test		| frame-old, tested-new, hom_res = false;
; 293  : 	// 1. The object was visible, but we must to re-check it		- test		| frame-new, tested-???, hom_res = true;
; 294  : 	// 2. New object slides into view								- delay test| frame-old, tested-old, hom_res = ???;
; 295  : 	u32 frame_current	= Device.dwFrame;
; 296  : 	// u32	frame_prev		= frame_current-1;
; 297  : 
; 298  : #ifdef DEBUG
; 299  : 	Device.Statistic->RenderCALC_HOM.Begin	();
; 300  : #endif
; 301  : 	BOOL result			= _visible			(vis.box,m_xform_01);

	lea	edx, DWORD PTR [ecx+812]
	push	ebx
	lea	ecx, DWORD PTR [esi+16]
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible
	mov	ebx, eax

; 302  : 	u32  delay			= 1;

	mov	edx, 1

; 303  : 	if (result)

	test	ebx, ebx
	je	SHORT $LN6@occ_visibl
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx

; 34   : 	IC 	s32		randI	(s32 min, s32 max)			{ return min+randI(max-min); }

	add	edx, 10					; 0000000aH
$LN6@occ_visibl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	mov	eax, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 311  : 	vis.hom_tested			= frame_current	;

	mov	DWORD PTR [esi+52], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	lea	ecx, DWORD PTR [edx+edi]
	pop	edi
	mov	DWORD PTR [esi+48], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 189  : BOOL					CRender::occ_visible			(vis_data& P)		{ return HOM.visible(P);								}

	pop	esi
	ret	4
?occ_visible@CRender@@UAEHAAUvis_data@@@Z ENDP		; CRender::occ_visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_P$ = 8							; size = 4
?occ_visible@CRender@@UAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z PROC ; CRender::occ_visible
; _this$ = ecx

; 190  : BOOL					CRender::occ_visible			(sPoly& P)			{ return HOM.visible(P);								}

	add	ecx, 712				; 000002c8H
	jmp	?visible@CHOM@@QAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ; CHOM::visible
?occ_visible@CRender@@UAEHAAV?$svector@U?$_vector3@M@@$0DA@@@@Z ENDP ; CRender::occ_visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_P$ = 8							; size = 4
?occ_visible@CRender@@UAEHAAV?$_box3@M@@@Z PROC		; CRender::occ_visible
; _this$ = ecx

; 191  : BOOL					CRender::occ_visible			(Fbox& P)			{ return HOM.visible(P);								}

	mov	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 275  : 	if (!bEnabled)							return TRUE;

	cmp	DWORD PTR [edx+744], 0
	jne	SHORT $LN4@occ_visibl
$LN176@occ_visibl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 191  : BOOL					CRender::occ_visible			(Fbox& P)			{ return HOM.visible(P);								}

	mov	eax, 1
	ret	4
$LN4@occ_visibl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 276  : 	if (B.contains(Device.vCameraPosition))	return TRUE;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	mov	ecx, DWORD PTR _P$[esp-4]

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+488]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN5@occ_visibl
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@occ_visibl

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+492]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN5@occ_visibl
	movss	xmm0, DWORD PTR [ecx+16]
	comiss	xmm0, xmm1
	jb	SHORT $LN5@occ_visibl

; 50   : 	ICF	BOOL	contains	(const Tvector &p)	const		{ return contains(p.x,p.y,p.z);	};

	movss	xmm1, DWORD PTR [eax+496]

; 49   : 	ICF	BOOL	contains	(T x, T y, T z)		const		{ return (x>=x1) && (x<=x2) && (y>=y1) && (y<=y2) && (z>=z1) && (z<=z2); };

	comiss	xmm1, DWORD PTR [ecx+8]
	jb	SHORT $LN5@occ_visibl
	movss	xmm0, DWORD PTR [ecx+20]
	comiss	xmm0, xmm1
	jae	SHORT $LN176@occ_visibl
$LN5@occ_visibl:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 277  : 	return _visible		(B,m_xform_01)		;

	add	edx, 812				; 0000032cH
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 191  : BOOL					CRender::occ_visible			(Fbox& P)			{ return HOM.visible(P);								}

	ret	4
?occ_visible@CRender@@UAEHAAV?$_box3@M@@@Z ENDP		; CRender::occ_visible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_Tpos$2 = -12						; size = 12
_V$ = 8							; size = 4
?add_Visual@CRender@@UAEXPAVIRender_Visual@@@Z PROC	; CRender::add_Visual
; _this$ = ecx

; 194  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 280  : 	if (0==pVisual)				return;

	mov	ebp, DWORD PTR _V$[esp+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 194  : {

	mov	ebx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 280  : 	if (0==pVisual)				return;

	test	ebp, ebp
	je	$LN6@add_Visual

; 281  : 
; 282  : 	// Visual is 100% visible - simply add it
; 283  : 	xr_vector<IRender_Visual*>::iterator I,E;	// it may be useful for 'hierrarhy' visual
; 284  : 
; 285  : 	switch (pVisual->Type) {

	mov	eax, DWORD PTR [ebp+4]
	dec	eax
	push	esi
	push	edi
	cmp	eax, 9
	ja	$LN34@add_Visual
	movzx	eax, BYTE PTR $LN177@add_Visual[eax]
	jmp	DWORD PTR $LN178@add_Visual[eax*4]
$LN25@add_Visual:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [ebp+92]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	je	$LN179@add_Visual
	npad	4
$LL11@add_Visual:

; 291  : 				PS::CParticleGroup::SItem&			I		= *i_it;
; 292  : 				if (I._effect)		add_leafs_Dynamic		(I._effect);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN26@add_Visual
	push	eax
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
$LN26@add_Visual:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN175@add_Visual
$LL14@add_Visual:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 293  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_related.begin();	pit!=I._children_related.end(); pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL14@add_Visual
$LN175@add_Visual:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+16]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	je	SHORT $LN9@add_Visual
	npad	1
$LL17@add_Visual:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 294  : 				for (xr_vector<IRender_Visual*>::iterator pit = I._children_free.begin();		pit!=I._children_free.end();	pit++)	add_leafs_Dynamic(*pit);

	jne	SHORT $LL17@add_Visual
$LN9@add_Visual:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	edi, 28					; 0000001cH

; 150  :         return _Ptr == _Right._Ptr;

	cmp	edi, DWORD PTR [ebp+96]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 290  : 			for (PS::CParticleGroup::SItemVecIt i_it=pG->items.begin(); i_it!=pG->items.end(); i_it++)	{

	jne	SHORT $LL11@add_Visual
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 197  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN27@add_Visual:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 303  : 			E = pV->children.end	();

	mov	edi, DWORD PTR [ebp+72]

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN179@add_Visual
$LL20@add_Visual:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 304  : 			for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL20@add_Visual
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 197  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN28@add_Visual:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 313  : 			if (pV->m_lod)				

	mov	edx, DWORD PTR [ebp+84]
	test	edx, edx
	je	$LN32@add_Visual

; 314  : 			{
; 315  : 				Fvector							Tpos;	float		D;
; 316  : 				val_pTransform->transform_tiny	(Tpos, pV->vis.sphere.P);

	mov	ecx, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ebp+12]
	movss	xmm6, DWORD PTR [ebp+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [ebp+16]
	movaps	xmm1, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm1, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm3, DWORD PTR [eax+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [ecx+36]
	addss	xmm0, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm6, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+16]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm4, DWORD PTR [ecx+24]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm5

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [ecx+40]
	mulss	xmm0, DWORD PTR [ecx+32]
	addss	xmm6, xmm4
	addss	xmm5, DWORD PTR [ecx+56]
	addss	xmm0, DWORD PTR [ecx+48]
	addss	xmm6, xmm5
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, xmm6
	subss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 317  : 				float		ssa		=	CalcSSA	(D,Tpos,pV->vis.sphere.R/2.f);	// assume dynamics never consume full sphere

	movss	xmm1, DWORD PTR [ebp+20]
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 31   : 	distSQ	= Device.vCameraPosition.distance_to_sqr(C)+EPS;

	addss	xmm0, DWORD PTR __real@3727c5ac
	addss	xmm2, xmm3
	addss	xmm2, xmm0

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA

; 32   : 	return	R/distSQ;

	divss	xmm1, xmm2

; 318  : 				if (ssa<r_ssaLOD_A)	_use_lod	= TRUE;

	comiss	xmm0, xmm1
	jbe	SHORT $LN32@add_Visual

; 319  : 			}
; 320  : 			if (_use_lod)				
; 321  : 			{
; 322  : 				add_leafs_Dynamic			(pV->m_lod)		;

	push	edx
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
	pop	edi
	pop	esi
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 197  : }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN32@add_Visual:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 324  : 				pV->CalculateBones			(TRUE);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	push	1
	call	DWORD PTR [eax+64]

; 325  : 				pV->CalculateWallmarks		();		//. bug?

	mov	ecx, ebp
	call	DWORD PTR __imp_?CalculateWallmarks@CKinematics@@QAEXXZ

; 326  : 				I = pV->children.begin		();
; 327  : 				E = pV->children.end		();

	mov	edi, DWORD PTR [ebp+72]

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	mov	esi, DWORD PTR [ebp+68]
	cmp	esi, edi
	je	$LN179@add_Visual
$LL23@add_Visual:
	push	DWORD PTR [esi]
	mov	ecx, ebx
	call	?add_leafs_Dynamic@CRender@@AAEXPAVIRender_Visual@@@Z ; CRender::add_leafs_Dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 328  : 				for (; I!=E; I++)	add_leafs_Dynamic	(*I);

	cmp	esi, edi
	jne	SHORT $LL23@add_Visual
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 197  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN34@add_Visual:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 337  : 			val_pTransform->transform_tiny	(Tpos, pVisual->vis.sphere.P);

	mov	eax, DWORD PTR [ebx+264]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ebp+12]
	movss	xmm4, DWORD PTR [ebp+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [ebp+16]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+20]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [eax+24]
	movss	DWORD PTR _Tpos$2[esp+28], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	lea	eax, DWORD PTR _Tpos$2[esp+28]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm4, xmm3
	movss	DWORD PTR _Tpos$2[esp+40], xmm1
	movss	DWORD PTR _Tpos$2[esp+44], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_build.cpp

; 338  : 			r_dsgraph_insert_dynamic		(pVisual,Tpos);

	call	?r_dsgraph_insert_dynamic@R_dsgraph_structure@@QAEXPAVIRender_Visual@@AAU?$_vector3@M@@@Z ; R_dsgraph_structure::r_dsgraph_insert_dynamic
$LN179@add_Visual:
	pop	edi
	pop	esi
$LN6@add_Visual:
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 197  : }

	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN178@add_Visual:
	DD	$LN27@add_Visual
	DD	$LN28@add_Visual
	DD	$LN25@add_Visual
	DD	$LN34@add_Visual
$LN177@add_Visual:
	DB	0
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	1
?add_Visual@CRender@@UAEXPAVIRender_Visual@@@Z ENDP	; CRender::add_Visual
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\frustum.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\frustum.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_V$ = 8							; size = 4
?add_Geometry@CRender@@UAEXPAVIRender_Visual@@@Z PROC	; CRender::add_Geometry
; _this$ = ecx

; 198  : void					CRender::add_Geometry			(IRender_Visual* V ){ add_Static(V,View->getMask());						}

	mov	edx, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\frustum.h

; 78   : 	u32				getMask() const { return (1 << p_count) - 1; }

	mov	eax, 1
	mov	ecx, DWORD PTR [edx+252]
	mov	ecx, DWORD PTR [ecx+240]
	shl	eax, cl
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 198  : void					CRender::add_Geometry			(IRender_Visual* V ){ add_Static(V,View->getMask());						}

	mov	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\frustum.h

; 78   : 	u32				getMask() const { return (1 << p_count) - 1; }

	dec	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 198  : void					CRender::add_Geometry			(IRender_Visual* V ){ add_Static(V,View->getMask());						}

	push	eax
	push	DWORD PTR _V$[esp]
	call	?add_Static@CRender@@AAEXPAVIRender_Visual@@I@Z ; CRender::add_Static
	ret	4
?add_Geometry@CRender@@UAEXPAVIRender_Visual@@@Z ENDP	; CRender::add_Geometry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_S$ = 8							; size = 4
_P$ = 12						; size = 4
_s$ = 16						; size = 4
$T1 = 20						; size = 4
_T$ = 20						; size = 4
_verts$ = 24						; size = 4
?add_StaticWallmark@CRender@@UAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@MPAVTRI@CDB@@PAU3@@Z PROC ; CRender::add_StaticWallmark
; _this$ = ecx

; 200  : {

	push	ebx
	push	ebp
	push	esi

; 201  : 	if (T->suppress_wm)	return;

	mov	esi, DWORD PTR _T$[esp+8]
	push	edi
	test	DWORD PTR [esi+12], 32768		; 00008000H
	jne	$LN13@add_Static

; 203  : 	Wallmarks->AddStaticWallmark	(T,verts,P,&*S,s);

	mov	eax, DWORD PTR _S$[esp+12]
	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+12], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN10@add_Static
	inc	DWORD PTR [eax]
$LN10@add_Static:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	ebx, DWORD PTR _P$[esp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 265  : 	if (contact_point.distance_to_sqr(Device.vCameraPosition) > _sqr(100.f))	return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 203  : 	Wallmarks->AddStaticWallmark	(T,verts,P,&*S,s);

	mov	ebp, DWORD PTR [ecx+1000]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [ebx+4]
	movss	xmm2, DWORD PTR [ebx]
	subss	xmm2, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [eax+492]
	movss	xmm0, DWORD PTR [ebx+8]
	subss	xmm0, DWORD PTR [eax+496]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 265  : 	if (contact_point.distance_to_sqr(Device.vCameraPosition) > _sqr(100.f))	return;

	comiss	xmm2, DWORD PTR __real@461c4000
	ja	SHORT $LN218@add_Static

; 266  : 
; 267  : 	// Physics may add wallmarks in parallel with rendering
; 268  : 	lock.Enter				();

	lea	ecx, DWORD PTR [ebp+1504]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR $T1[esp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 269  : 	AddWallmark_internal	(pTri,pVerts,contact_point,hShader,sz);

	sub	esp, 8
	fld	DWORD PTR _s$[esp+20]
	mov	ecx, esp
	fstp	DWORD PTR [esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR $T1[esp+20]
	test	eax, eax
	je	SHORT $LN24@add_Static
	inc	DWORD PTR [eax]
$LN24@add_Static:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 269  : 	AddWallmark_internal	(pTri,pVerts,contact_point,hShader,sz);

	push	ebx
	push	DWORD PTR _verts$[esp+24]
	mov	ecx, ebp
	push	esi
	call	?AddWallmark_internal@CWallmarksEngine@@AAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ; CWallmarksEngine::AddWallmark_internal

; 270  : 	lock.Leave				();

	lea	ecx, DWORD PTR [ebp+1504]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
$LN218@add_Static:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 204  : }

	lea	ecx, DWORD PTR $T1[esp+12]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
$LN13@add_Static:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	20					; 00000014H
?add_StaticWallmark@CRender@@UAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@MPAVTRI@CDB@@PAU3@@Z ENDP ; CRender::add_StaticWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
?clear_static_wallmarks@CRender@@UAEXXZ PROC		; CRender::clear_static_wallmarks
; _this$ = ecx

; 208  : 	Wallmarks->clear				();

	mov	ecx, DWORD PTR [ecx+1000]
	jmp	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
?clear_static_wallmarks@CRender@@UAEXXZ ENDP		; CRender::clear_static_wallmarks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_wm$ = 8						; size = 4
?add_SkeletonWallmark@CRender@@UAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; CRender::add_SkeletonWallmark
; _this$ = ecx

; 212  : {

	push	ecx
	mov	eax, DWORD PTR _wm$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR $T1[esp+20], esi

; 115  : 	if (m_object == rhs.m_object)

	test	eax, eax
	je	SHORT $LN58@add_Skelet

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
	mov	esi, eax
	mov	edi, eax
	mov	DWORD PTR $T1[esp+20], esi
	mov	eax, DWORD PTR _wm$[esp+16]
$LN58@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 287  : 	if(0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL) return;

	cmp	DWORD PTR ?g_r@@3IA, 0			; g_r
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 213  : 	Wallmarks->AddSkeletonWallmark				(wm);

	mov	ebx, DWORD PTR [ecx+1000]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 287  : 	if(0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL) return;

	je	SHORT $LN15@add_Skelet
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 0
	jne	SHORT $LN15@add_Skelet

; 288  : 
; 289  : 	if (!::RImplementation.val_bHUD)

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	jne	SHORT $LN15@add_Skelet

; 290  : 	{
; 291  : 		lock.Enter			();

	lea	ecx, DWORD PTR [ebx+1504]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ

; 292  : 		// search if similar wallmark exists
; 293  : 		wm_slot* slot		= FindSlot	(wm->Shader());

	push	ecx
	push	esp
	mov	ecx, esi
	call	DWORD PTR __imp_?Shader@CSkeletonWallmark@@QAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
	mov	ecx, ebx
	call	?FindSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::FindSlot

; 294  : 		if (0==slot) slot	= AppendSlot(wm->Shader());

	test	eax, eax
	jne	SHORT $LN17@add_Skelet
	push	ecx
	push	esp
	mov	ecx, esi
	call	DWORD PTR __imp_?Shader@CSkeletonWallmark@@QAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
	mov	ecx, ebx
	call	?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::AppendSlot
$LN17@add_Skelet:

; 295  : 		// no similar - register _new_
; 296  : 		slot->skeleton_items.push_back(wm);

	lea	ecx, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN28@add_Skelet
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [eax], 0

; 115  : 	if (m_object == rhs.m_object)

	test	esi, esi
	je	SHORT $LN38@add_Skelet

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [eax], esi

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [esi]
$LN38@add_Skelet:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN27@add_Skelet
$LN28@add_Skelet:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T1[esp+20]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
$LN27@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 300  : 		lock.Leave			();

	lea	ecx, DWORD PTR [ebx+1504]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
	mov	eax, DWORD PTR _wm$[esp+16]
$LN15@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 44   : 	if (!m_object)

	test	edi, edi
	je	SHORT $LN23@add_Skelet
	add	DWORD PTR [esi], -1
	jne	SHORT $LN59@add_Skelet
	push	esi
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN59@add_Skelet:
	mov	eax, DWORD PTR _wm$[esp+16]
$LN23@add_Skelet:
	test	eax, eax
	je	SHORT $LN56@add_Skelet

; 45   : 		return;
; 46   : 	
; 47   : 	--m_object->base_type::m_ref_count;

	add	DWORD PTR [eax], -1

; 48   : 	if (!m_object->base_type::m_ref_count)

	jne	SHORT $LN56@add_Skelet

; 49   : 		m_object->base_type::_release	(m_object);

	push	DWORD PTR _wm$[esp+16]
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN56@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 214  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?add_SkeletonWallmark@CRender@@UAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; CRender::add_SkeletonWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_xf$ = 8						; size = 4
_obj$ = 12						; size = 4
_sh$ = 16						; size = 4
_start$ = 20						; size = 4
_dir$ = 24						; size = 4
_size$ = 28						; size = 4
?add_SkeletonWallmark@CRender@@UAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z PROC ; CRender::add_SkeletonWallmark
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 275  : 	if( 0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL)				return;

	cmp	DWORD PTR ?g_r@@3IA, 0			; g_r
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 216  : {

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 275  : 	if( 0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL)				return;

	je	$LN8@add_Skelet
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 0
	jne	$LN8@add_Skelet

; 277  : 	if (xf->c.distance_to_sqr(Device.vCameraPosition) > _sqr(50.f))				return;

	mov	edi, DWORD PTR _xf$[esp+4]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [edi+52]
	movss	xmm2, DWORD PTR [edi+48]
	subss	xmm2, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [eax+492]
	movss	xmm0, DWORD PTR [edi+56]
	subss	xmm0, DWORD PTR [eax+496]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 277  : 	if (xf->c.distance_to_sqr(Device.vCameraPosition) > _sqr(50.f))				return;

	comiss	xmm2, DWORD PTR __real@451c4000
	ja	SHORT $LN8@add_Skelet
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 217  : 	Wallmarks->AddSkeletonWallmark				(xf, obj, sh, start, dir, size);

	mov	esi, DWORD PTR [ecx+1000]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 280  : 	lock.Enter				();

	lea	ecx, DWORD PTR [esi+1504]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _sh$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	sub	esp, 8
	fld	DWORD PTR _size$[esp+12]
	mov	ecx, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	fstp	DWORD PTR [esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN17@add_Skelet
	inc	DWORD PTR [eax]
$LN17@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	push	DWORD PTR _dir$[esp+12]
	mov	ecx, DWORD PTR _obj$[esp+16]
	push	DWORD PTR _start$[esp+16]
	push	edi
	call	DWORD PTR __imp_?AddWallmark@CKinematics@@QAEXPBU?$_matrix@M@@ABU?$_vector3@M@@1V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z

; 282  : 	lock.Leave				();

	lea	ecx, DWORD PTR [esi+1504]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
$LN8@add_Skelet:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 218  : }

	pop	edi
	pop	esi
	ret	24					; 00000018H
?add_SkeletonWallmark@CRender@@UAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z ENDP ; CRender::add_SkeletonWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_bb_screenspace$ = 8					; size = 4
?add_Occluder@CRender@@UAEXAAV?$_box2@M@@@Z PROC	; CRender::add_Occluder
; _this$ = ecx

; 221  : 	VERIFY					(_valid(bb_screenspace));
; 222  : 	HOM.occlude				(bb_screenspace);
; 223  : }

	ret	4
?add_Occluder@CRender@@UAEXAAV?$_box2@M@@@Z ENDP	; CRender::add_Occluder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
$T2 = -20						; size = 4
_cs$3 = -20						; size = 4
_D$1$ = -16						; size = 4
_C$4 = -12						; size = 12
tv1587 = 8						; size = 4
_O$ = 8							; size = 4
?set_Object@CRender@@UAEXPAVIRenderable@@@Z PROC	; CRender::set_Object
; _this$ = ecx

; 227  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	edi

; 228  : 	VERIFY					(g_bRendering);
; 229  : 	val_pObject				= O;		// NULL is OK, trust me :)

	mov	edi, DWORD PTR _O$[esp+28]

; 230  : 	if (val_pObject)		{
; 231  : 		VERIFY(dynamic_cast<CObject*>(O)||dynamic_cast<CPS_Instance*>(O));
; 232  : 		if (O->renderable.pROS) { VERIFY(dynamic_cast<CROS_impl*>(O->renderable.pROS)); }
; 233  : 	}
; 234  : 	if (PHASE_NORMAL==phase)	{

	cmp	DWORD PTR [ebp+292], 0
	mov	ebx, DWORD PTR [ebp+988]
	mov	DWORD PTR [ebp+260], edi
	jne	$LN13@set_Object

; 235  : 		if (L_Shadows)

	push	esi
	mov	esi, DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	mov	DWORD PTR tv1587[esp+32], esi
	test	ebx, ebx
	je	$LN27@set_Object
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 86   : 	if (0==O)	current		= 0;

	test	edi, edi
	je	$LN24@set_Object

; 87   : 	else 
; 88   : 	{
; 89   : 		if (!O->renderable_ShadowGenerate()	|| RImplementation.val_bHUD || ((CROS_impl*)O->renderable_ROS())->shadow_gen_frame==Device.dwFrame)

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	$LN24@set_Object
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	jne	$LN24@set_Object
	mov	ecx, edi
	call	esi
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+1920]
	cmp	eax, DWORD PTR [ecx+244]
	je	$LN24@set_Object

; 90   : 		{
; 91   : 			current		= 0;
; 92   : 			return;
; 93   : 		}
; 94   : 
; 95   : 		Fvector		C;	O->renderable.xform.transform_tiny		(C,O->renderable.visual->vis.sphere.P);

	mov	eax, DWORD PTR [edi+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm1, DWORD PTR [eax+12]
	movss	xmm5, DWORD PTR [eax+8]
	movaps	xmm4, xmm1
	mulss	xmm4, DWORD PTR [edi+20]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edi+4]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm3, xmm5
	movss	xmm2, DWORD PTR [eax+16]
	mulss	xmm3, DWORD PTR [edi+8]
	addss	xmm4, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [edi+12]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edi+36]
	addss	xmm0, DWORD PTR [edi+52]
	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edi+24]
	mulss	xmm1, DWORD PTR [edi+28]
	addss	xmm3, xmm0
	movss	DWORD PTR _C$4[esp+36], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [ecx+488]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm1
	mulss	xmm0, DWORD PTR [edi+40]
	mulss	xmm2, DWORD PTR [edi+44]
	addss	xmm0, DWORD PTR [edi+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm2, DWORD PTR [edi+60]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 100  : 		float		_priority		= (D/S_distance)*(S_ideal_size/(R+EPS));

	movss	xmm1, DWORD PTR __real@3daaaaab
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 96   : 		float		R				= O->renderable.visual->vis.sphere.R;

	movss	xmm0, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
	movss	DWORD PTR _C$4[esp+40], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [ecx+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movss	DWORD PTR _C$4[esp+44], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm5, DWORD PTR [ecx+496]
	mulss	xmm3, xmm3
	mulss	xmm5, xmm5
	addss	xmm4, xmm3
	addss	xmm4, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 97   : 		float		D				= C.distance_to(Device.vCameraPosition)+R;

	addss	xmm2, xmm0

; 100  : 		float		_priority		= (D/S_distance)*(S_ideal_size/(R+EPS));

	addss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR _D$1$[esp+36], xmm2
	divss	xmm1, xmm0

; 101  : 		if (_priority<1.f)		current	= O;

	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	$LN24@set_Object
	mov	DWORD PTR [ebx], edi

; 102  : 		else					current = 0;
; 103  : 		
; 104  : 		if (current)
; 105  : 		{
; 106  : 			((CROS_impl*)O->renderable_ROS())->shadow_gen_frame	=	Device.dwFrame;

	mov	ecx, edi
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	call	DWORD PTR tv1587[esp+32]
	lea	ecx, DWORD PTR [eax+1920]
	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 110  : 			if (casters_pool.empty())	cs	= xr_new<caster> ();

	jne	SHORT $LN28@set_Object
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 110  : 			if (casters_pool.empty())	cs	= xr_new<caster> ();

	jmp	SHORT $LN29@set_Object
$LN28@set_Object:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ebx+8]
	add	eax, -4					; fffffffcH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 112  : 				cs	= casters_pool.back	();

	mov	esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	mov	DWORD PTR [ebx+8], eax
$LN29@set_Object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightShadows.cpp

; 117  : 			casters.push_back	(cs);

	lea	eax, DWORD PTR _cs$3[esp+36]
	mov	DWORD PTR _cs$3[esp+36], esi
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	?push_back@?$vector@PAUcaster@CLightShadows@@V?$xalloc@PAUcaster@CLightShadows@@@@@std@@QAEXABQAUcaster@CLightShadows@@@Z ; std::vector<CLightShadows::caster *,xalloc<CLightShadows::caster *> >::push_back

; 118  : 			cs->O				= current;

	mov	eax, DWORD PTR [ebx]

; 119  : 			cs->C				= C;
; 120  : 			cs->D				= D;

	movss	xmm0, DWORD PTR _D$1$[esp+36]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _C$4[esp+36]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _C$4[esp+40]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _C$4[esp+44]
	mov	DWORD PTR [esi+12], eax
	movss	DWORD PTR [esi+16], xmm0

; 121  : 			cs->nodes.clear		();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax
	jmp	SHORT $LN27@set_Object
$LN24@set_Object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 238  : 		if (L_Projector)

	mov	DWORD PTR [ebx], 0
$LN27@set_Object:
	mov	esi, DWORD PTR [ebp+992]
	test	esi, esi
	je	$LN125@set_Object
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	test	edi, edi
	je	$LN62@set_Object
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [ebx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	cmp	eax, 100				; 00000064H
	jae	$LN62@set_Object

; 55   : 	else
; 56   : 	{
; 57   : 		if (!O->renderable_ShadowReceive() || RImplementation.val_bInvisible || ((CROS_impl*)O->renderable_ROS())->shadow_recv_frame==Device.dwFrame)	

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+12]
	test	eax, eax
	je	$LN62@set_Object
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+272, 0
	jne	$LN62@set_Object
	mov	ecx, edi
	call	DWORD PTR tv1587[esp+32]
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+1924]
	cmp	eax, DWORD PTR [ecx+244]
	je	$LN62@set_Object

; 58   : 		{
; 59   : 			current		= 0;
; 60   : 			return;
; 61   : 		}
; 62   : 
; 63   : 		Fvector		C;	O->renderable.xform.transform_tiny		(C,O->renderable.visual->vis.sphere.P);

	mov	eax, DWORD PTR [edi+68]

; 22   : float	clipD		(float R)		{ return P_distance*(R/P_ideal_size); }

	lea	ebp, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [eax+12]
	movss	xmm5, DWORD PTR [eax+8]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edi+24]
	movaps	xmm4, xmm5
	mulss	xmm4, DWORD PTR [edi+8]
	movaps	xmm1, xmm2
	movss	xmm3, DWORD PTR [eax+16]
	mulss	xmm1, DWORD PTR [edi+20]
	addss	xmm4, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm2, DWORD PTR [edi+28]
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 64   : 		float		R	= O->renderable.visual->vis.sphere.R;

	movss	xmm6, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm0, DWORD PTR [edi+40]
	addss	xmm0, DWORD PTR [edi+56]
	addss	xmm4, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [edi+4]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm4, DWORD PTR [ecx+492]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [edi+36]

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm5, xmm2
	mulss	xmm3, DWORD PTR [edi+44]
	addss	xmm0, DWORD PTR [edi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm4, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm3, DWORD PTR [edi+60]
	addss	xmm1, xmm0
	addss	xmm5, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm1, DWORD PTR [ecx+488]
	subss	xmm5, DWORD PTR [ecx+496]
	mulss	xmm1, xmm1
	mulss	xmm5, xmm5
	addss	xmm1, xmm4
	addss	xmm1, xmm5
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 65   : 		float		D	= C.distance_to	(Device.vCameraPosition)+R;

	addss	xmm0, xmm6

; 22   : float	clipD		(float R)		{ return P_distance*(R/P_ideal_size); }

	mulss	xmm6, DWORD PTR __real@42480000

; 67   : 		if (D < clipD(R))	current	= O;

	comiss	xmm6, xmm0
	jbe	$LN65@set_Object

; 68   : 		else				current = 0;
; 69   : 		
; 70   : 		if (current)				{
; 71   : 			ISpatial*	spatial		= dynamic_cast<ISpatial*>	(O);

	push	0
	push	OFFSET ??_R0?AVISpatial@@@8
	push	OFFSET ??_R0?AVIRenderable@@@8
	push	0
	push	edi
	mov	DWORD PTR [ebp], edi
	call	___RTDynamicCast
	mov	esi, eax
	add	esp, 20					; 00000014H

; 72   : 			if	(0==spatial) current= 0;

	test	esi, esi
	je	$LN65@set_Object
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h

; 87   : 		if (0 == (spatial.type & STYPEFLAG_INVALIDSECTOR))	return;

	test	DWORD PTR [esi+4], 65536		; 00010000H
	je	SHORT $LN90@set_Object

; 88   : 		spatial_updatesector_internal();

	mov	ecx, esi
	call	DWORD PTR __imp_?spatial_updatesector_internal@ISpatial@@QAEXXZ
$LN90@set_Object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 75   : 				if (0==spatial->spatial.sector)	{

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN70@set_Object

; 76   : 					CObject*		obj = dynamic_cast<CObject*>(O);

	push	0
	push	OFFSET ??_R0?AVCObject@@@8
	push	OFFSET ??_R0?AVIRenderable@@@8
	push	0
	push	edi
	call	___RTDynamicCast
	add	esp, 20					; 00000014H

; 77   : 					if (obj)		Msg	("! Invalid object '%s' position. Outside of sector structure.",obj->cName().c_str());

	test	eax, eax
	je	SHORT $LN65@set_Object
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	esi, DWORD PTR [eax+168]
	lea	ecx, DWORD PTR $T2[esp+36]

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	DWORD PTR $T2[esp+36], 0

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	esi, esi
	je	SHORT $LN121@set_Object
	inc	DWORD PTR [esi]
	call	?_dec@shared_str@@IAEXXZ		; shared_str::_dec
	mov	ecx, esi
	lea	eax, DWORD PTR [esi+12]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, eax
	push	ecx
	push	OFFSET ??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	dec	DWORD PTR [esi]
	jmp	SHORT $LN65@set_Object
$LN121@set_Object:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	call	?_dec@shared_str@@IAEXXZ		; shared_str::_dec
	lea	eax, DWORD PTR [esi+12]
	neg	esi
	sbb	esi, esi
	and	esi, eax
	push	esi
	push	OFFSET ??_C@_0DN@FFEDFBLH@?$CB?5Invalid?5object?5?8?$CFs?8?5position?4@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8
$LN65@set_Object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 82   : 		if (current)				{

	mov	DWORD PTR [ebp], 0
$LN70@set_Object:
	mov	ecx, DWORD PTR [ebp]
	test	ecx, ecx
	je	SHORT $LN125@set_Object

; 83   : 			CROS_impl*	LT			= (CROS_impl*)current->renderable_ROS	();

	call	DWORD PTR tv1587[esp+32]

; 84   : 			LT->shadow_recv_frame	= Device.dwFrame;

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR [ecx+244]
	mov	DWORD PTR [eax+1924], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, DWORD PTR [ebx+8]
	je	SHORT $LN117@set_Object

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ecx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+4], 4
$LN125@set_Object:
	pop	esi
$LN18@set_Object:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 247  : }

	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN117@set_Object:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ebp
	push	ecx
	mov	ecx, ebx
	call	??$_Emplace_reallocate@ABQAVIRenderable@@@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEPAPAVIRenderable@@QAPAV2@ABQAV2@@Z ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Emplace_reallocate<IRenderable * const &>
	pop	esi
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 247  : }

	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN62@set_Object:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightProjector.cpp

; 54   : 	if ((0==O) || (receivers.size()>=P_o_count))	current		= 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 247  : }

	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN13@set_Object:

; 239  : 			L_Projector->set_object	(O);
; 240  : 	} else {
; 241  : 		if (L_Shadows)

	test	ebx, ebx
	je	SHORT $LN17@set_Object

; 242  : 			L_Shadows->set_object(0);

	push	0
	mov	ecx, ebx
	call	?set_object@CLightShadows@@QAEXPAVIRenderable@@@Z ; CLightShadows::set_object
$LN17@set_Object:

; 243  : 
; 244  : 		if (L_Projector)

	mov	ecx, DWORD PTR [ebp+992]
	test	ecx, ecx
	je	SHORT $LN18@set_Object

; 247  : }

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H

; 245  : 			L_Projector->set_object	(0);

	mov	DWORD PTR _O$[esp-4], 0
	jmp	?set_object@CLightProjector@@QAEXPAVIRenderable@@@Z ; CLightProjector::set_object
?set_Object@CRender@@UAEXPAVIRenderable@@@Z ENDP	; CRender::set_Object
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
;	COMDAT ?gm_SetNearer@@YAXH@Z
_TEXT	SEGMENT
_VP$1 = -28						; size = 24
?gm_SetNearer@@YAXH@Z PROC				; gm_SetNearer, COMDAT
; _bNearer$dead$ = ecx

; 269  : {

	sub	esp, 32					; 00000020H

; 270  : 	if (bNearer	!= gm_Nearer)

	cmp	DWORD PTR ?gm_Nearer@@3HA, 0
	push	esi
	je	SHORT $LN4@gm_SetNear

; 500  : 	IRender_Target* T	=	getTarget	();

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation

; 271  : 	{
; 272  : 		gm_Nearer	= bNearer;

	mov	DWORD PTR ?gm_Nearer@@3HA, 0

; 500  : 	IRender_Target* T	=	getTarget	();

	call	DWORD PTR [eax+60]
	mov	esi, eax

; 501  : 	D3DVIEWPORT9 VP		= {0,0,T->get_width(),T->get_height(),0,1.f };

	mov	DWORD PTR _VP$1[esp+36], 0
	mov	DWORD PTR _VP$1[esp+40], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+40]
	mov	DWORD PTR _VP$1[esp+44], eax
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR _VP$1[esp+48], eax

; 502  : 	CHK_DX				(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$1[esp+36]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _VP$1[esp+52], 0
	mov	DWORD PTR _VP$1[esp+56], 1065353216	; 3f800000H
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]
$LN4@gm_SetNear:

; 273  : 		if (gm_Nearer)	RImplementation.rmNear	();
; 274  : 		else			RImplementation.rmNormal();
; 275  : 	}
; 276  : }

	pop	esi
	add	esp, 32					; 00000020H
	ret	0
?gm_SetNearer@@YAXH@Z ENDP				; gm_SetNearer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
??0CRender@@QAE@XZ PROC					; CRender::CRender
; _this$dead$ = ecx

; 282  : {

	call	??0R_dsgraph_structure@@QAE@XZ		; R_dsgraph_structure::R_dsgraph_structure
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+684
	mov	DWORD PTR ?RImplementation@@3VCRender@@A, OFFSET ??_7CRender@@6BIRender_interface@@@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+256, OFFSET ??_7CRender@@6BpureFrame@@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+660, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+664, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+668, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+672, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+676, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+680, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 282  : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 31   : {

	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+712
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+876
	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 32   : 	bEnabled		= FALSE;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+744, 0

; 33   : 	m_pModel		= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+736, 0

; 34   : 	m_pTris			= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+740, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+884, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+888, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+892, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+896, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+900, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+904, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+908, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+912, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+916, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+920, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+924, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+928, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+932, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+936, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+940, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+944, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+948, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+952, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+956, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+960, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+964, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+968, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+972, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+976, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 282  : {

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1088, OFFSET ??_7cl_light_PR@@6B@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1092, OFFSET ??_7cl_light_C@@6B@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1096, OFFSET ??_7cl_light_XFORM@@6B@
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1100, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1104, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1108, 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+1104, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 283  : }

	mov	eax, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	ret	0
??0CRender@@QAE@XZ ENDP					; CRender::CRender
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GCRender@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRender@@UAEPAXI@Z PROC				; CRender::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CRender@@UAE@XZ			; CRender::~CRender
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	1112					; 00000458H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCRender@@UAEPAXI@Z ENDP				; CRender::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ PROC ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::~xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::~xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ PROC ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ ENDP ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ PROC ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ ENDP ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ PROC ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ ENDP ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0cl_light_PR@@QAE@XZ
_TEXT	SEGMENT
??0cl_light_PR@@QAE@XZ PROC				; cl_light_PR::cl_light_PR, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7cl_light_PR@@6B@
	mov	eax, ecx
	ret	0
??0cl_light_PR@@QAE@XZ ENDP				; cl_light_PR::cl_light_PR
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0cl_light_C@@QAE@XZ
_TEXT	SEGMENT
??0cl_light_C@@QAE@XZ PROC				; cl_light_C::cl_light_C, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7cl_light_C@@6B@
	mov	eax, ecx
	ret	0
??0cl_light_C@@QAE@XZ ENDP				; cl_light_C::cl_light_C
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0cl_light_XFORM@@QAE@XZ
_TEXT	SEGMENT
??0cl_light_XFORM@@QAE@XZ PROC				; cl_light_XFORM::cl_light_XFORM, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7cl_light_XFORM@@6B@
	mov	eax, ecx
	ret	0
??0cl_light_XFORM@@QAE@XZ ENDP				; cl_light_XFORM::cl_light_XFORM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ PROC ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	esi
	ret	0
??0?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ ENDP ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??1?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ PROC ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN16@xr_set
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN16@xr_set:
	ret	0
??1?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@QAE@XZ ENDP ; xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~xr_set<FS_File,std::less<FS_File>,xalloc<FS_File> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??1?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ PROC ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~set<FS_File,std::less<FS_File>,xalloc<FS_File> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN14@set
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN14@set:
	ret	0
??1?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ ENDP ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::~set<FS_File,std::less<FS_File>,xalloc<FS_File> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
??1CRender@@UAE@XZ PROC					; CRender::~CRender
; _this$ = ecx

; 286  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 287  : }

	lea	esi, DWORD PTR [edi+1104]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 286  : {

	mov	DWORD PTR [edi], OFFSET ??_7CRender@@6BIRender_interface@@@
	mov	DWORD PTR [edi+256], OFFSET ??_7CRender@@6BpureFrame@@@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN18@CRender
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
$LN18@CRender:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	eax, DWORD PTR [edi+1100]
	test	eax, eax
	je	SHORT $LN24@CRender
	dec	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+1100]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN24@CRender
	mov	DWORD PTR [edi+1100], 0
$LN24@CRender:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+968]
	test	eax, eax
	je	SHORT $LN33@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+968], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+972], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+976], 0
$LN33@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+956]
	test	eax, eax
	je	SHORT $LN45@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+956], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+960], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+964], 0
$LN45@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+944]
	test	eax, eax
	je	SHORT $LN57@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+944], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+948], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+952], 0
$LN57@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+932]
	test	eax, eax
	je	SHORT $LN69@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+932], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+936], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+940], 0
$LN69@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+920]
	test	eax, eax
	je	SHORT $LN81@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+920], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+924], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+928], 0
$LN81@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+908]
	test	eax, eax
	je	SHORT $LN93@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+908], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+912], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+916], 0
$LN93@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+896]
	test	eax, eax
	je	SHORT $LN105@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+896], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+900], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+904], 0
$LN105@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+884]
	test	eax, eax
	je	SHORT $LN117@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+884], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+888], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+892], 0
$LN117@CRender:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 45   : }

	lea	ecx, DWORD PTR [edi+876]
	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1xrXRC@@QAE@XZ
	lea	ecx, DWORD PTR [edi+712]
	call	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 287  : }

	lea	ecx, DWORD PTR [edi+684]
	call	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+672]
	test	eax, eax
	je	SHORT $LN131@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+672], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+676], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+680], 0
$LN131@CRender:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi+660]
	test	eax, eax
	je	SHORT $LN143@CRender
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [edi+660], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [edi+664], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [edi+668], 0
$LN143@CRender:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 287  : }

	mov	ecx, edi
	pop	edi
	pop	esi
	pop	ebx
	jmp	??1R_dsgraph_structure@@UAE@XZ
??1CRender@@UAE@XZ ENDP					; CRender::~CRender
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
;	COMDAT ?pred_sp_sort@@YA_NPAVISpatial@@0@Z
_TEXT	SEGMENT
__1$ = 8						; size = 4
__2$ = 12						; size = 4
?pred_sp_sort@@YA_NPAVISpatial@@0@Z PROC		; pred_sp_sort, COMDAT

; 297  : 	float	d1		= _1->spatial.sphere.P.distance_to_sqr(Device.vCameraPosition);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR __1$[esp-4]

; 298  : 	float	d2		= _2->spatial.sphere.P.distance_to_sqr(Device.vCameraPosition);

	mov	edx, DWORD PTR __2$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [ecx+492]
	movss	xmm5, DWORD PTR [eax+12]
	movss	xmm4, DWORD PTR [edx+12]
	subss	xmm5, xmm2
	movss	xmm1, DWORD PTR [ecx+488]
	subss	xmm4, xmm2
	movss	xmm6, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [edx+8]
	subss	xmm6, xmm1
	movss	xmm0, DWORD PTR [ecx+496]
	subss	xmm2, xmm1
	movss	xmm3, DWORD PTR [eax+16]
	movss	xmm1, DWORD PTR [edx+16]
	subss	xmm3, xmm0
	subss	xmm1, xmm0
	mulss	xmm5, xmm5
	mulss	xmm6, xmm6
	mulss	xmm2, xmm2
	mulss	xmm4, xmm4
	addss	xmm6, xmm5
	mulss	xmm3, xmm3
	addss	xmm2, xmm4
	mulss	xmm1, xmm1
	addss	xmm6, xmm3
	addss	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 299  : 	return	d1<d2;

	comiss	xmm2, xmm6
	jbe	SHORT $LN3@pred_sp_so
	mov	al, 1

; 300  : }

	ret	0
$LN3@pred_sp_so:

; 299  : 	return	d1<d2;

	xor	al, al

; 300  : }

	ret	0
?pred_sp_sort@@YA_NPAVISpatial@@0@Z ENDP		; pred_sp_sort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_object.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_vz$3$ = -148						; size = 4
_v_it$1$ = -148						; size = 4
_s_it$1$ = -148						; size = 4
$T1 = -148						; size = 4
_vz$1$ = -144						; size = 4
tv4164 = -144						; size = 4
$T2 = -144						; size = 4
_o_it$1$ = -140						; size = 4
_v_it$1$ = -140						; size = 4
_K$1$ = -140						; size = 4
_a$1$ = -136						; size = 4
_uID_LTRACK$1$ = -136					; size = 4
_root$1$ = -136						; size = 4
tv1824 = -136						; size = 4
_renderable$1$ = -132					; size = 4
tv3995 = -132						; size = 4
_L$ = -132						; size = 4
_result$1$ = -128					; size = 4
tv4155 = -128						; size = 4
_v_copy$3 = -124					; size = 56
_vy$4 = -68						; size = 12
tv3982 = -56						; size = 4
_v_orig$1$ = -52					; size = 4
tv4534 = -52						; size = 4
_vx$5 = -48						; size = 12
_VP$6 = -48						; size = 24
_box_radius$7 = -48					; size = 12
_vz$8 = -24						; size = 12
_b$1$ = -12						; size = 4
_v_copy$7$ = -8						; size = 4
tv3986 = -4						; size = 4
?Calculate@CRender@@UAEXXZ PROC				; CRender::Calculate
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 304  : 	Device.Statistic->RenderCALC.Begin();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+436]
	mov	ebx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 304  : 	Device.Statistic->RenderCALC.Begin();

	add	esi, 1272				; 000004f8H
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN55@Calculate
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN55@Calculate

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN55@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 307  : 	IRender_Target* T				=	getTarget	();

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+60]

; 308  : 	float	fov_factor				=	_sqr		(90.f / Device.fFOV);

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edi, eax
	fld	DWORD PTR __real@42b40000
	fdiv	DWORD PTR [ecx+792]

; 309  : 	g_fSCREEN						=	float(T->get_width()*T->get_height())*fov_factor*(EPS_S+ps_r__LOD);

	mov	ecx, edi
	mov	edx, DWORD PTR [edi]
	fstp	DWORD PTR _a$1$[esp+160]
	call	DWORD PTR [edx+44]
	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	mov	esi, eax
	call	DWORD PTR [edx+40]
	imul	esi, eax
	mov	DWORD PTR tv4534[esp+160], esi
	fild	DWORD PTR tv4534[esp+160]
	test	esi, esi
	jns	SHORT $LN965@Calculate
	fadd	DWORD PTR __real@4f800000
$LN965@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 95   : template <class T>	IC T		_sqr	(T a)		{ return a*a;		}

	fld	DWORD PTR _a$1$[esp+160]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 319  : 	ViewBase.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_LRTB|FRUSTUM_P_FAR);

	lea	edi, DWORD PTR [ebx+8]
	movss	xmm1, DWORD PTR ?ps_r__LOD@@3MA
	mov	ecx, edi
	addss	xmm1, DWORD PTR __real@33d6bf95
	movss	xmm0, DWORD PTR __real@41440000
	movss	xmm2, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 95   : template <class T>	IC T		_sqr	(T a)		{ return a*a;		}

	fmul	ST(0), ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 319  : 	ViewBase.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_LRTB|FRUSTUM_P_FAR);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	47					; 0000002fH
	add	eax, 664				; 00000298H
	push	eax
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR tv1824[esp+168]
	mulss	xmm1, DWORD PTR tv1824[esp+168]
	divss	xmm0, xmm1
	divss	xmm2, xmm1
	movss	DWORD PTR ?r_ssaDISCARD@@3MA, xmm0
	movss	xmm0, DWORD PTR ?ps_r1_ssaLOD_A@@3MA
	mulss	xmm0, DWORD PTR __real@3eaaaaab
	movss	DWORD PTR ?g_fSCREEN@@3MA, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 95   : template <class T>	IC T		_sqr	(T a)		{ return a*a;		}

	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 312  : 	r_ssaLOD_A						=	_sqr(ps_r1_ssaLOD_A/3)		/g_fSCREEN;

	mulss	xmm0, xmm2
	movss	DWORD PTR ?r_ssaLOD_A@@3MA, xmm0

; 313  : 	r_ssaLOD_B						=	_sqr(ps_r1_ssaLOD_B/3)		/g_fSCREEN;

	movss	xmm0, DWORD PTR ?ps_r1_ssaLOD_B@@3MA
	mulss	xmm0, DWORD PTR __real@3eaaaaab
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 95   : template <class T>	IC T		_sqr	(T a)		{ return a*a;		}

	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 313  : 	r_ssaLOD_B						=	_sqr(ps_r1_ssaLOD_B/3)		/g_fSCREEN;

	mulss	xmm0, xmm2
	movss	DWORD PTR ?r_ssaLOD_B@@3MA, xmm0

; 314  : 	r_ssaGLOD_start					=	_sqr(ps_r__GLOD_ssa_start/3)/g_fSCREEN;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@45e38e3a
	movss	DWORD PTR ?r_ssaGLOD_start@@3MA, xmm0

; 315  : 	r_ssaGLOD_end					=	_sqr(ps_r__GLOD_ssa_end/3)	/g_fSCREEN;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@43e38e3a

; 316  : 	r_ssaHZBvsTEX					=	_sqr(ps_r__ssaHZBvsTEX/3)	/g_fSCREEN;

	mulss	xmm2, DWORD PTR __real@44800000
	movss	DWORD PTR ?r_ssaGLOD_end@@3MA, xmm0
	movss	DWORD PTR ?r_ssaHZBvsTEX@@3MA, xmm2

; 319  : 	ViewBase.CreateFromMatrix		(Device.mFullTransform,FRUSTUM_P_LRTB|FRUSTUM_P_FAR);

	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 320  : 	View							= 0;

	mov	DWORD PTR [ebx+252], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	cmp	DWORD PTR [ebx+736], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 321  : 	HOM.Enable						();

	lea	ecx, DWORD PTR [ebx+712]

; 322  : 	HOM.Render						(ViewBase);

	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	setne	al
	mov	DWORD PTR [ebx+744], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 322  : 	HOM.Render						(ViewBase);

	call	?Render@CHOM@@QAEXAAVCFrustum@@@Z	; CHOM::Render

; 270  : 	if (bNearer	!= gm_Nearer)

	cmp	DWORD PTR ?gm_Nearer@@3HA, 0
	je	SHORT $LN82@Calculate

; 500  : 	IRender_Target* T	=	getTarget	();

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation

; 272  : 		gm_Nearer	= bNearer;

	mov	DWORD PTR ?gm_Nearer@@3HA, 0

; 500  : 	IRender_Target* T	=	getTarget	();

	call	DWORD PTR [eax+60]
	mov	esi, eax

; 501  : 	D3DVIEWPORT9 VP		= {0,0,T->get_width(),T->get_height(),0,1.f };

	mov	DWORD PTR _VP$6[esp+160], 0
	mov	DWORD PTR _VP$6[esp+164], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+40]
	mov	DWORD PTR _VP$6[esp+168], eax
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR _VP$6[esp+172], eax

; 502  : 	CHK_DX				(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$6[esp+160]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _VP$6[esp+176], 0
	mov	DWORD PTR _VP$6[esp+180], 1065353216	; 3f800000H
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]
$LN82@Calculate:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm1, DWORD PTR __real@33d6bf95
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 324  : 	phase							= PHASE_NORMAL;

	mov	DWORD PTR [ebx+292], 0

; 327  : 	if (!vLastCameraPos.similar(Device.vCameraPosition,EPS_S)) 

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [ebx+644]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 327  : 	if (!vLastCameraPos.similar(Device.vCameraPosition,EPS_S)) 

	add	ecx, 488				; 000001e8H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	subss	xmm0, DWORD PTR [ecx]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm1, xmm0
	jbe	SHORT $LN90@Calculate
	movss	xmm0, DWORD PTR [ebx+648]
	subss	xmm0, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm1, xmm0
	jbe	SHORT $LN90@Calculate
	movss	xmm0, DWORD PTR [ebx+652]
	subss	xmm0, DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm1, xmm0
	ja	SHORT $LN26@Calculate
$LN90@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 329  : 		CSector* pSector		= (CSector*)detectSector(Device.vCameraPosition);

	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [eax+56]

; 330  : 		if (0==pSector) pSector = pLastSector;

	test	eax, eax
	jne	SHORT $LN960@Calculate
	mov	eax, DWORD PTR [ebx+640]
$LN960@Calculate:

; 331  : 		pLastSector				= pSector;

	mov	DWORD PTR [ebx+640], eax

; 332  : 		vLastCameraPos.set		(Device.vCameraPosition);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [eax+488]
	fstp	DWORD PTR [ebx+644]
	fld	DWORD PTR [eax+492]
	fstp	DWORD PTR [ebx+648]
	fld	DWORD PTR [eax+496]
	fstp	DWORD PTR [ebx+652]
$LN26@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 336  : 	if (rmPortals) 

	mov	edx, DWORD PTR [ebx+708]
	test	edx, edx
	je	$LN3@Calculate

; 340  : 		Sectors_xrc.box_query	(rmPortals,Device.vCameraPosition,box_radius);

	lea	eax, DWORD PTR _box_radius$7[esp+160]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 148  : 		ICF void		box_options		(u32 f)	{	box_mode = f;		}

	mov	DWORD PTR [ebx+688], 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 340  : 		Sectors_xrc.box_query	(rmPortals,Device.vCameraPosition,box_radius);

	push	eax
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	ecx, DWORD PTR [ebx+684]
	add	eax, 488				; 000001e8H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _box_radius$7[esp+164], 990057071 ; 3b03126fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 340  : 		Sectors_xrc.box_query	(rmPortals,Device.vCameraPosition,box_radius);

	push	eax
	push	edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _box_radius$7[esp+176], 990057071 ; 3b03126fH
	mov	DWORD PTR _box_radius$7[esp+180], 990057071 ; 3b03126fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 340  : 		Sectors_xrc.box_query	(rmPortals,Device.vCameraPosition,box_radius);

	call	DWORD PTR __imp_?box_query@xrXRC@@QAEXPBVMODEL@CDB@@ABU?$_vector3@M@@1@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+700]
	sub	eax, DWORD PTR [ebx+696]
	sar	eax, 3
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 341  : 		for (int K=0; K<Sectors_xrc.r_count(); K++)

	mov	DWORD PTR _K$1$[esp+160], 0
	test	eax, eax
	jle	SHORT $LN3@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	xor	edi, edi
	npad	12
$LL4@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	eax, DWORD PTR [ebx+708]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 343  : 			CPortal*	pPortal		= (CPortal*) Portals[rmPortals->get_tris()[Sectors_xrc.r_begin()[K].id].dummy];

	lea	ecx, DWORD PTR [ebx+684]
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	esi, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 343  : 			CPortal*	pPortal		= (CPortal*) Portals[rmPortals->get_tris()[Sectors_xrc.r_begin()[K].id].dummy];

	call	DWORD PTR __imp_?r_begin@xrXRC@@QAEPAURESULT@CDB@@XZ
	lea	edi, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [eax+edi-16]
	add	eax, eax
	mov	ecx, DWORD PTR [esi+eax*8+12]

; 344  : 			pPortal->bDualRender	= TRUE;

	mov	eax, DWORD PTR [ebx+660]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _K$1$[esp+160]
	inc	ecx
	mov	DWORD PTR _K$1$[esp+160], ecx
	mov	DWORD PTR [eax+148], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+700]
	sub	eax, DWORD PTR [ebx+696]
	sar	eax, 3
	imul	eax, eax, -1227133513
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 341  : 		for (int K=0; K<Sectors_xrc.r_count(); K++)

	cmp	ecx, eax
	jl	SHORT $LL4@Calculate
	lea	edi, DWORD PTR [ebx+8]
$LN3@Calculate:

; 345  : 		}
; 346  : 	}
; 347  : 	//
; 348  : 	if (L_DB)

	mov	ecx, DWORD PTR [ebx+980]
	test	ecx, ecx
	je	SHORT $LN29@Calculate

; 349  : 		L_DB->Update();

	call	?Update@CLight_DB@@QAEXXZ		; CLight_DB::Update
$LN29@Calculate:

; 350  : 
; 351  : 	// Main process
; 352  : 	marker	++;

	inc	DWORD PTR [ebx+296]

; 353  : 	if (pLastSector)

	mov	edx, DWORD PTR [ebx+640]
	test	edx, edx
	je	$LN30@Calculate

; 354  : 	{
; 355  : 		// Traverse sector/portal structure
; 356  : 		PortalTraverser.traverse	

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	11					; 0000000bH
	lea	eax, DWORD PTR [ecx+664]
	push	eax
	lea	eax, DWORD PTR [ecx+488]
	mov	ecx, OFFSET ?PortalTraverser@@3VCPortalTraverser@@A ; PortalTraverser
	push	eax
	push	edi
	push	edx
	call	?traverse@CPortalTraverser@@QAEXPAVIRender_Sector@@AAVCFrustum@@AAU?$_vector3@M@@AAU?$_matrix@M@@I@Z ; CPortalTraverser::traverse
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	mov	eax, DWORD PTR __imp_?psDeviceFlags@@3U?$_flags@I@@A
	test	DWORD PTR [eax], 512			; 00000200H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 366  : 		if  (psDeviceFlags.test(rsDrawStatic))	{

	je	$LN6@Calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 367  : 			for (u32 s_it=0; s_it<PortalTraverser.r_sectors.size(); s_it++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+152
	sub	ecx, edi
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 367  : 			for (u32 s_it=0; s_it<PortalTraverser.r_sectors.size(); s_it++)

	mov	DWORD PTR _s_it$1$[esp+160], edx
	test	ecx, ecx
	je	$LN964@Calculate
	npad	1
$LL7@Calculate:

; 368  : 			{
; 369  : 				CSector*	sector		= (CSector*)PortalTraverser.r_sectors[s_it];

	mov	esi, DWORD PTR [edi+edx*4]

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	DWORD PTR _v_it$1$[esp+160], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+24]
	sub	eax, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 370  : 				IRender_Visual*	root	= sector->root();

	mov	ecx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1056139499
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 370  : 				IRender_Visual*	root	= sector->root();

	mov	DWORD PTR _root$1$[esp+160], ecx

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	test	eax, eax
	je	SHORT $LN5@Calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	xor	edi, edi
	npad	9
$LL10@Calculate:
	mov	eax, DWORD PTR [esi+20]
	add	eax, edi
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 192  : 	IC		void					set_Frustum(CFrustum* O) { VERIFY(O);	View = O; }

	mov	DWORD PTR [ebx+252], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 374  : 					add_Geometry		(root);

	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [eax+96]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	add	edi, 244				; 000000f4H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	ecx, DWORD PTR _v_it$1$[esp+160]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	imul	eax, eax, -1056139499
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 371  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	DWORD PTR _v_it$1$[esp+160], ecx
	cmp	ecx, eax
	mov	ecx, DWORD PTR _root$1$[esp+160]
	jb	SHORT $LL10@Calculate
	mov	edi, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+152
	mov	edx, DWORD PTR _s_it$1$[esp+160]
$LN5@Calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A+156
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 367  : 			for (u32 s_it=0; s_it<PortalTraverser.r_sectors.size(); s_it++)

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 367  : 			for (u32 s_it=0; s_it<PortalTraverser.r_sectors.size(); s_it++)

	mov	DWORD PTR _s_it$1$[esp+160], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 367  : 			for (u32 s_it=0; s_it<PortalTraverser.r_sectors.size(); s_it++)

	cmp	edx, eax
	jb	$LL7@Calculate
	mov	eax, DWORD PTR __imp_?psDeviceFlags@@3U?$_flags@I@@A
$LN964@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	lea	edi, DWORD PTR [ebx+8]
$LN6@Calculate:
	test	DWORD PTR [eax], 1024			; 00000400H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 380  : 		if  (psDeviceFlags.test(rsDrawDynamic))	{

	je	$LN12@Calculate

; 381  : 			g_SpatialSpace->q_frustum

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	edi
	push	3
	push	4
	mov	ecx, DWORD PTR [ecx]
	lea	edi, DWORD PTR [ebx+568]
	push	edi
	call	DWORD PTR __imp_?q_frustum@ISpatial_DB@@QAEXAAV?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@IIABVCFrustum@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);

	mov	edx, DWORD PTR [ebx+572]

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?pred_sp_sort@@YA_NPAVISpatial@@0@Z ; pred_sp_sort
	push	eax
	call	??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 393  : 			set_Object							(0);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 393  : 			set_Object							(0);

	mov	ecx, ebx
	push	0
	call	DWORD PTR [eax+84]

; 394  : 			g_pGameLevel->pHUD->Render_First	( );	// R1 shadows

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+280]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 395  : 			g_pGameLevel->pHUD->Render_Last		( );	

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+280]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]

; 396  : 			u32 uID_LTRACK						= 0xffffffff;
; 397  : 			if (phase==PHASE_NORMAL)			{

	cmp	DWORD PTR [ebx+292], 0
	mov	DWORD PTR _uID_LTRACK$1$[esp+160], -1
	jne	SHORT $LN37@Calculate

; 398  : 				uLastLTRACK	++;

	mov	eax, DWORD PTR [ebx+656]
	inc	eax
	mov	DWORD PTR [ebx+656], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+4]
	sub	ecx, DWORD PTR [edi]
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 399  : 				if (lstRenderables.size())		uID_LTRACK	= uLastLTRACK%lstRenderables.size();

	test	ecx, ecx
	je	SHORT $LN35@Calculate
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _uID_LTRACK$1$[esp+160], edx
$LN35@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 403  : 				if (O)		{

	test	eax, eax
	je	SHORT $LN37@Calculate
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_object.h

; 118  : 	IC IRender_ObjectSpecific* ROS() { return renderable_ROS(); }

	lea	esi, DWORD PTR [eax+76]
	mov	ecx, esi
	call	DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 405  : 					if (R)		R->update			(O);

	test	eax, eax
	je	SHORT $LN37@Calculate
	push	esi
	mov	ecx, eax
	call	?update@CROS_impl@@QAEXPAVIRenderable@@@Z ; CROS_impl::update
$LN37@Calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 408  : 			for (u32 o_it=0; o_it<lstRenderables.size(); o_it++)

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 408  : 			for (u32 o_it=0; o_it<lstRenderables.size(); o_it++)

	mov	DWORD PTR _o_it$1$[esp+160], edx
	test	eax, eax
	je	$LN12@Calculate
$LL13@Calculate:

; 409  : 			{
; 410  : 				ISpatial*	spatial		= lstRenderables[o_it];		spatial->spatial_updatesector	();

	mov	esi, DWORD PTR [ecx+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\ispatial.h

; 87   : 		if (0 == (spatial.type & STYPEFLAG_INVALIDSECTOR))	return;

	test	DWORD PTR [esi+4], 65536		; 00010000H
	je	SHORT $LN721@Calculate

; 88   : 		spatial_updatesector_internal();

	mov	ecx, esi
	call	DWORD PTR __imp_?spatial_updatesector_internal@ISpatial@@QAEXXZ
	mov	edx, DWORD PTR _o_it$1$[esp+160]
$LN721@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 411  : 				CSector*	sector		= (CSector*)spatial->spatial.sector	;

	mov	edi, DWORD PTR [esi+44]

; 412  : 				if	(0==sector)										continue;	// disassociated from S/P structure

	test	edi, edi
	je	$LN11@Calculate

; 413  : 				if	(PortalTraverser.i_marker != sector->r_marker)	continue;	// inactive (untouched) sector

	mov	eax, DWORD PTR ?PortalTraverser@@3VCPortalTraverser@@A
	cmp	eax, DWORD PTR [edi+64]
	jne	$LN11@Calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1056139499
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 414  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	DWORD PTR _v_it$1$[esp+160], 0
	test	eax, eax
	je	$LN912@Calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	xor	edx, edx
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv4164[esp+160], edx
	npad	4
$LL16@Calculate:

; 119  :         _Ptr += _Off;

	add	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\render.h

; 192  : 	IC		void					set_Frustum(CFrustum* O) { VERIFY(O);	View = O; }

	mov	DWORD PTR [ebx+252], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 417  : 					if (!View->testSphere_dirty(spatial->spatial.sphere.P,spatial->spatial.sphere.R))	continue;

	fld	DWORD PTR [esi+20]
	push	ecx
	fstp	DWORD PTR [esp]
	push	eax
	call	DWORD PTR __imp_?testSphere_dirty@CFrustum@@QBEHAAU?$_vector3@M@@M@Z
	test	eax, eax
	jne	SHORT $LN40@Calculate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+20]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 414  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	edx, DWORD PTR tv4164[esp+160]
	inc	DWORD PTR _v_it$1$[esp+160]
	add	edx, 244				; 000000f4H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
	imul	eax, eax, -1056139499
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 414  : 				for (u32 v_it=0; v_it<sector->r_frustums.size(); v_it++)

	mov	DWORD PTR tv4164[esp+160], edx
	cmp	DWORD PTR _v_it$1$[esp+160], eax
	lea	eax, DWORD PTR [esi+8]
	jb	SHORT $LL16@Calculate

; 341  : 		for (int K=0; K<Sectors_xrc.r_count(); K++)

	jmp	$LN912@Calculate
$LN40@Calculate:

; 418  : 
; 419  : 					if (spatial->spatial.type & STYPE_RENDERABLE)

	test	BYTE PTR [esi+4], 1
	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	je	$LN22@Calculate

; 420  : 					{
; 421  : 						// renderable
; 422  : 						IRenderable*	renderable		= spatial->dcast_Renderable	();

	call	DWORD PTR [eax+24]
	mov	DWORD PTR _renderable$1$[esp+160], eax

; 423  : 						if (0==renderable)	{

	test	eax, eax
	jne	$LN43@Calculate

; 425  : 							CGlow*		glow				= dynamic_cast<CGlow*>(spatial);

	push	eax
	push	OFFSET ??_R0?AVCGlow@@@8
	push	OFFSET ??_R0?AVISpatial@@@8
	push	eax
	push	esi
	call	___RTDynamicCast
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	ecx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 425  : 							CGlow*		glow				= dynamic_cast<CGlow*>(spatial);

	add	esp, 20					; 00000014H
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+160], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN753@Calculate
	inc	DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T1[esp+160]
$LN753@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 146  : 	if (G->dwFrame	==Device.dwFrame)		return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 427  : 							L_Glows->add					(glow);

	mov	edx, DWORD PTR [ebx+996]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 146  : 	if (G->dwFrame	==Device.dwFrame)		return;

	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [ecx+72], eax
	je	$LN763@Calculate

; 147  : 	G->dwFrame		= Device.dwFrame;

	mov	DWORD PTR [ecx+72], eax

; 152  : 	float	dt		= Device.fTimeDelta;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 156  : 	if (range < dlim2) 

	movss	xmm5, DWORD PTR [ecx+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+492]
	movss	xmm3, DWORD PTR [eax+488]
	movss	xmm1, DWORD PTR [eax+496]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 152  : 	float	dt		= Device.fTimeDelta;

	movss	xmm4, DWORD PTR [eax+468]

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [ecx+16]
	subss	xmm2, DWORD PTR [ecx+20]
	subss	xmm1, DWORD PTR [ecx+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax+1116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax+440]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	movss	xmm0, DWORD PTR [eax+64]
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 156  : 	if (range < dlim2) 

	comiss	xmm0, xmm3
	jbe	$LN758@Calculate

; 157  : 	{
; 158  : 		// 2. Use result of test
; 159  : 		if (G->bTestResult) {

	cmp	DWORD PTR [ecx+120], 0
	je	SHORT $LN759@Calculate

; 160  : 			G->fade -= dt*FADE_SCALE_DOWN;

	mulss	xmm4, DWORD PTR __real@44800000

; 161  : 			if (G->fade<1.)		G->fade = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm5, xmm4
	comiss	xmm0, xmm5
	movss	DWORD PTR [ecx+64], xmm5
	jbe	SHORT $LN762@Calculate
	mov	DWORD PTR [ecx+64], 1065353216		; 3f800000H

; 162  : 		} else {

	jmp	SHORT $LN762@Calculate
$LN759@Calculate:

; 163  : 			G->fade	+= dt*FADE_SCALE_UP;

	mulss	xmm4, DWORD PTR __real@45800000
	addss	xmm4, xmm5

; 164  : 			if (G->fade>255.f)	G->fade = 255.f;

	comiss	xmm4, DWORD PTR __real@437f0000
	movss	DWORD PTR [ecx+64], xmm4
	jbe	SHORT $LN762@Calculate
	mov	DWORD PTR [ecx+64], 1132396544		; 437f0000H
$LN762@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T2[esp+160], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	inc	DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 167  : 		Selected.push_back(G);

	lea	ecx, DWORD PTR [edx+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN784@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR $T2[esp+160]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR $T2[esp+160]
	test	eax, eax
	je	SHORT $LN794@Calculate
	inc	DWORD PTR [eax+4]
$LN794@Calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN783@Calculate
$LN784@Calculate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T2[esp+160]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >
$LN783@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T2[esp+160]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	lea	ecx, DWORD PTR $T1[esp+160]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 168  : 		return;

	jmp	$LN912@Calculate
$LN758@Calculate:

; 169  : 	}
; 170  : 	G->fade -= dt*FADE_SCALE_DOWN;

	mulss	xmm4, DWORD PTR __real@44800000

; 171  : 	if (G->fade<1.) G->fade = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm5, xmm4
	comiss	xmm0, xmm5
	movss	DWORD PTR [ecx+64], xmm5
	jbe	SHORT $LN763@Calculate
	mov	DWORD PTR [ecx+64], 1065353216		; 3f800000H
$LN763@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+160]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 428  : 						} else {

	jmp	$LN912@Calculate
$LN43@Calculate:

; 429  : 							// Occlusion
; 430  : 							vis_data&		v_orig			= renderable->renderable.visual->vis;

	mov	edx, DWORD PTR [eax+68]

; 431  : 							vis_data		v_copy			= v_orig;

	lea	edi, DWORD PTR _v_copy$3[esp+160]
	add	edx, 8
	mov	ecx, 14					; 0000000eH
	mov	esi, edx
	mov	DWORD PTR _v_orig$1$[esp+160], edx
	rep movsd
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mov	esi, DWORD PTR _renderable$1$[esp+160]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm6, DWORD PTR _v_copy$3[esp+176]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	movss	xmm0, DWORD PTR _v_copy$3[esp+188]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm7, DWORD PTR _v_copy$3[esp+180]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 64   : 		vx.mul				(m.i, B.max.x-B.min.x);	

	subss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm4, DWORD PTR [esi+8]
	movss	xmm5, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	movss	xmm2, DWORD PTR _v_copy$3[esp+192]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 65   : 		vy.mul				(m.j, B.max.y-B.min.y);	

	subss	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _b$1$[esp+160], xmm6
	movss	DWORD PTR _v_copy$7$[esp+160], xmm7

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv3982[esp+160], xmm1
	movss	DWORD PTR _vx$5[esp+160], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm7, DWORD PTR [esi+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv3986[esp+160], xmm1
	movss	DWORD PTR _vx$5[esp+164], xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, xmm0
	movss	DWORD PTR tv4155[esp+160], xmm1
	movss	DWORD PTR _vx$5[esp+168], xmm1
	movss	xmm1, DWORD PTR [esi+20]
	mulss	xmm1, xmm2
	movss	DWORD PTR tv3995[esp+160], xmm1
	movss	DWORD PTR _vy$4[esp+160], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [esi+24]
	mulss	xmm2, DWORD PTR [esi+28]
	movss	DWORD PTR _vy$4[esp+164], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm1, DWORD PTR _v_copy$3[esp+196]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vy$4[esp+168], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 66   : 		vz.mul				(m.k, B.max.z-B.min.z);	

	movss	xmm2, DWORD PTR _v_copy$3[esp+184]
	subss	xmm1, xmm2
	movss	DWORD PTR _vz$3$[esp+160], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm1, DWORD PTR [esi+36]
	movss	xmm6, DWORD PTR _vz$3$[esp+160]
	movaps	xmm3, xmm1
	mulss	xmm3, xmm6
	movss	DWORD PTR _vz$1$[esp+160], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$1$[esp+160], xmm3
	movss	DWORD PTR _vz$8[esp+160], xmm3
	movaps	xmm3, xmm6
	mulss	xmm6, DWORD PTR [esi+44]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, DWORD PTR [esi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm3, DWORD PTR [esi+40]
	movss	DWORD PTR _vz$3$[esp+160], xmm6
	movss	DWORD PTR _vz$8[esp+168], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm6, DWORD PTR _b$1$[esp+160]
	movaps	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$8[esp+164], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [esi+4]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm4, xmm6
	addss	xmm7, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm5, xmm6
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR [esi+44]
	mulss	xmm0, DWORD PTR [esi+40]
	addss	xmm7, xmm1
	movss	xmm1, DWORD PTR _v_copy$7$[esp+160]
	addss	xmm2, DWORD PTR [esi+60]
	addss	xmm0, DWORD PTR [esi+56]
	movaps	xmm3, xmm1
	mulss	xmm1, DWORD PTR [esi+28]
	mulss	xmm3, DWORD PTR [esi+24]
	movss	DWORD PTR _v_copy$3[esp+176], xmm7
	addss	xmm1, xmm5
	addss	xmm3, xmm4
	addss	xmm3, xmm0
	movaps	xmm4, xmm3
	movss	DWORD PTR _v_copy$3[esp+180], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$5[esp+160], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movaps	xmm0, xmm7
	movss	DWORD PTR _v_copy$3[esp+188], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm2, xmm1
	movss	DWORD PTR _v_copy$3[esp+184], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN812@Calculate
	addss	xmm7, DWORD PTR tv3982[esp+160]
	movss	DWORD PTR _v_copy$3[esp+176], xmm7
	jmp	SHORT $LN813@Calculate
$LN812@Calculate:
	movaps	xmm0, xmm7
	addss	xmm0, DWORD PTR tv3982[esp+160]
	movss	DWORD PTR _v_copy$3[esp+188], xmm0
$LN813@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$5[esp+164], -2147483648	; 80000000H
	movaps	xmm5, xmm3
	addss	xmm5, DWORD PTR tv3986[esp+160]
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	je	SHORT $LN814@Calculate
	movaps	xmm4, xmm5
	movss	DWORD PTR _v_copy$3[esp+180], xmm4
	jmp	SHORT $LN966@Calculate
$LN814@Calculate:
	movaps	xmm3, xmm5
$LN966@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$5[esp+168], -2147483648	; 80000000H
	movss	xmm5, DWORD PTR tv4155[esp+160]
	movss	DWORD PTR _v_copy$3[esp+192], xmm3
	addss	xmm5, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	je	SHORT $LN816@Calculate
	movaps	xmm2, xmm5
	movss	DWORD PTR _v_copy$3[esp+184], xmm2
	jmp	SHORT $LN967@Calculate
$LN816@Calculate:
	movaps	xmm1, xmm5
$LN967@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$4[esp+160], -2147483648	; 80000000H
	movss	DWORD PTR _v_copy$3[esp+196], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	je	SHORT $LN818@Calculate
	addss	xmm7, DWORD PTR tv3995[esp+160]
	movss	DWORD PTR _v_copy$3[esp+176], xmm7
	jmp	SHORT $LN819@Calculate
$LN818@Calculate:
	addss	xmm0, DWORD PTR tv3995[esp+160]
	movss	DWORD PTR _v_copy$3[esp+188], xmm0
$LN819@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$4[esp+164], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	je	SHORT $LN820@Calculate
	addss	xmm4, DWORD PTR _vy$4[esp+164]
	movss	DWORD PTR _v_copy$3[esp+180], xmm4
	jmp	SHORT $LN821@Calculate
$LN820@Calculate:
	addss	xmm3, DWORD PTR _vy$4[esp+164]
	movss	DWORD PTR _v_copy$3[esp+192], xmm3
$LN821@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$4[esp+168], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN822@Calculate
	addss	xmm2, DWORD PTR _vy$4[esp+168]
	movss	DWORD PTR _v_copy$3[esp+184], xmm2
	jmp	SHORT $LN823@Calculate
$LN822@Calculate:
	addss	xmm1, DWORD PTR _vy$4[esp+168]
	movss	DWORD PTR _v_copy$3[esp+196], xmm1
$LN823@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$8[esp+160], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN824@Calculate
	addss	xmm7, DWORD PTR _vz$1$[esp+160]
	movss	DWORD PTR _v_copy$3[esp+176], xmm7
	jmp	SHORT $LN825@Calculate
$LN824@Calculate:
	addss	xmm0, DWORD PTR _vz$1$[esp+160]
	movss	DWORD PTR _v_copy$3[esp+188], xmm0
$LN825@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$8[esp+164], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	je	SHORT $LN826@Calculate
	addss	xmm4, DWORD PTR _vz$8[esp+164]
	movss	DWORD PTR _v_copy$3[esp+180], xmm4
	jmp	SHORT $LN827@Calculate
$LN826@Calculate:
	addss	xmm3, DWORD PTR _vz$8[esp+164]
	movss	DWORD PTR _v_copy$3[esp+192], xmm3
$LN827@Calculate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$8[esp+168], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	je	SHORT $LN828@Calculate
	addss	xmm2, DWORD PTR _vz$3$[esp+160]
	movss	DWORD PTR _v_copy$3[esp+184], xmm2
	jmp	SHORT $LN829@Calculate
$LN828@Calculate:
	addss	xmm1, DWORD PTR _vz$3$[esp+160]
	movss	DWORD PTR _v_copy$3[esp+196], xmm1
$LN829@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edi, DWORD PTR [eax+244]
	cmp	edi, DWORD PTR _v_copy$3[esp+208]
	jae	SHORT $LN860@Calculate
$LN968@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 441  : 							if (o_it==uID_LTRACK && renderable->renderable_ROS())	{

	mov	eax, DWORD PTR _v_copy$3[esp+204]
	mov	DWORD PTR [edx+44], eax
	mov	eax, DWORD PTR _v_copy$3[esp+200]
	mov	DWORD PTR [edx+40], eax
	mov	eax, DWORD PTR _v_copy$3[esp+208]
	mov	DWORD PTR [edx+48], eax
	mov	eax, DWORD PTR _v_copy$3[esp+212]
	mov	DWORD PTR [edx+52], eax
	jmp	SHORT $LN962@Calculate
$LN860@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 289  : 	if (!bEnabled)						return TRUE;				// return - everything visible

	cmp	DWORD PTR [ebx+744], 0
	je	SHORT $LN968@Calculate

; 290  : 	
; 291  : 	// Now, the test time comes
; 292  : 	// 0. The object was hidden, and we must prove that each frame	- test		| frame-old, tested-new, hom_res = false;
; 293  : 	// 1. The object was visible, but we must to re-check it		- test		| frame-new, tested-???, hom_res = true;
; 294  : 	// 2. New object slides into view								- delay test| frame-old, tested-old, hom_res = ???;
; 295  : 	u32 frame_current	= Device.dwFrame;
; 296  : 	// u32	frame_prev		= frame_current-1;
; 297  : 
; 298  : #ifdef DEBUG
; 299  : 	Device.Statistic->RenderCALC_HOM.Begin	();
; 300  : #endif
; 301  : 	BOOL result			= _visible			(vis.box,m_xform_01);

	lea	edx, DWORD PTR [ebx+812]
	lea	ecx, DWORD PTR _v_copy$3[esp+176]
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible
	mov	DWORD PTR _result$1$[esp+160], eax

; 302  : 	u32  delay			= 1;

	mov	edx, 1

; 303  : 	if (result)

	test	eax, eax
	je	SHORT $LN862@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx

; 34   : 	IC 	s32		randI	(s32 min, s32 max)			{ return min+randI(max-min); }

	add	edx, 10					; 0000000aH
$LN862@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 438  : 							if (!bVisible)					break;	// exit loop on frustums

	cmp	DWORD PTR _result$1$[esp+160], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	lea	eax, DWORD PTR [edx+edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 434  : 							v_orig.accept_frame				= v_copy.accept_frame;

	mov	ecx, DWORD PTR _v_orig$1$[esp+160]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	mov	DWORD PTR _v_copy$3[esp+208], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 434  : 							v_orig.accept_frame				= v_copy.accept_frame;

	mov	eax, DWORD PTR _v_copy$3[esp+204]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 311  : 	vis.hom_tested			= frame_current	;

	mov	DWORD PTR _v_copy$3[esp+212], edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 434  : 							v_orig.accept_frame				= v_copy.accept_frame;

	mov	DWORD PTR [ecx+44], eax

; 435  : 							v_orig.marker					= v_copy.marker;

	mov	eax, DWORD PTR _v_copy$3[esp+200]
	mov	DWORD PTR [ecx+40], eax

; 436  : 							v_orig.hom_frame				= v_copy.hom_frame;

	mov	eax, DWORD PTR _v_copy$3[esp+208]
	mov	DWORD PTR [ecx+48], eax

; 437  : 							v_orig.hom_tested				= v_copy.hom_tested;

	mov	eax, DWORD PTR _v_copy$3[esp+212]
	mov	DWORD PTR [ecx+52], eax

; 438  : 							if (!bVisible)					break;	// exit loop on frustums

	je	$LN912@Calculate
$LN962@Calculate:

; 441  : 							if (o_it==uID_LTRACK && renderable->renderable_ROS())	{

	mov	eax, DWORD PTR _uID_LTRACK$1$[esp+160]
	cmp	DWORD PTR _o_it$1$[esp+160], eax
	jne	SHORT $LN46@Calculate
	mov	edi, DWORD PTR __imp_?renderable_ROS@IRenderable@@QAEPAVIRender_ObjectSpecific@@XZ
	mov	ecx, esi
	call	edi
	test	eax, eax
	je	SHORT $LN46@Calculate

; 442  : 								// track lighting environment
; 443  : 								CROS_impl*		T = (CROS_impl*)renderable->renderable_ROS();

	mov	ecx, esi
	call	edi

; 444  : 								T->update			(renderable);

	push	esi
	mov	ecx, eax
	call	?update@CROS_impl@@QAEXPAVIRenderable@@@Z ; CROS_impl::update
$LN46@Calculate:

; 445  : 							}
; 446  : 							set_Object						(renderable);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	esi
	call	DWORD PTR [eax+84]

; 447  : 							renderable->renderable_Render	();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]

; 448  : 							set_Object						(0);	//? is it needed at all

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	0
	call	DWORD PTR [eax+84]

; 449  : 						}
; 450  : 					} else {

	jmp	$LN912@Calculate
$LN22@Calculate:

; 451  : 						VERIFY								(spatial->spatial.type & STYPE_LIGHTSOURCE);
; 452  : 						// lightsource
; 453  : 						light*			L					= (light*)	spatial->dcast_Light	();

	call	DWORD PTR [eax+28]
	mov	esi, eax

; 454  : 						VERIFY								(L);
; 455  : 						if (L->spatial.sector)				{

	cmp	DWORD PTR [esi+52], 0
	je	$LN912@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 171  : 	hom.box.set		(spatial.sphere.P,spatial.sphere.P);

	lea	ecx, DWORD PTR [esi+140]
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h

; 9    : 	IC void		set(const _vector3<T> &_P, T _R)	{ P.set(_P); R = _R; }

	movss	xmm6, DWORD PTR [esi+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [esi+124]
	fld	DWORD PTR [esi+20]
	fstp	DWORD PTR [esi+128]
	fld	DWORD PTR [esi+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h

; 9    : 	IC void		set(const _vector3<T> &_P, T _R)	{ P.set(_P); R = _R; }

	movss	DWORD PTR [esi+136], xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [esi+132]
	movss	xmm5, DWORD PTR [esi+16]
	movss	DWORD PTR [ecx], xmm5

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm5, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR [esi+20]
	movss	DWORD PTR [ecx+4], xmm4

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm4, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [esi+24]
	movss	DWORD PTR [ecx+8], xmm0

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm0, xmm6

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm3, DWORD PTR [esi+16]
	movss	DWORD PTR [ecx+12], xmm3
	movss	xmm2, DWORD PTR [esi+20]
	movss	DWORD PTR [ecx+16], xmm2
	movss	xmm1, DWORD PTR [esi+24]

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [ecx+8], xmm0

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movaps	xmm0, xmm6
	addss	xmm0, xmm3

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	DWORD PTR [ecx], xmm5
	movss	DWORD PTR [ecx+4], xmm4

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movss	DWORD PTR [ecx+12], xmm0
	movaps	xmm0, xmm6
	addss	xmm0, xmm2
	addss	xmm6, xmm1
	movss	DWORD PTR [ecx+16], xmm0
	movss	DWORD PTR [ecx+20], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 288  : 	if (Device.dwFrame<vis.hom_frame)	return TRUE;				// not at this time :)

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	edi, DWORD PTR [eax+244]
	cmp	edi, DWORD PTR [esi+172]
	jb	SHORT $LN958@Calculate

; 289  : 	if (!bEnabled)						return TRUE;				// return - everything visible

	cmp	DWORD PTR [ebx+744], 0
	je	SHORT $LN958@Calculate

; 290  : 	
; 291  : 	// Now, the test time comes
; 292  : 	// 0. The object was hidden, and we must prove that each frame	- test		| frame-old, tested-new, hom_res = false;
; 293  : 	// 1. The object was visible, but we must to re-check it		- test		| frame-new, tested-???, hom_res = true;
; 294  : 	// 2. New object slides into view								- delay test| frame-old, tested-old, hom_res = ???;
; 295  : 	u32 frame_current	= Device.dwFrame;
; 296  : 	// u32	frame_prev		= frame_current-1;
; 297  : 
; 298  : #ifdef DEBUG
; 299  : 	Device.Statistic->RenderCALC_HOM.Begin	();
; 300  : #endif
; 301  : 	BOOL result			= _visible			(vis.box,m_xform_01);

	lea	edx, DWORD PTR [ebx+812]
	call	?_visible@@YAHAAV?$_box3@M@@AAU?$_matrix@M@@@Z ; _visible

; 303  : 	if (result)

	test	eax, eax
	je	SHORT $LN893@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 33   : 	IC 	s32		randI	(s32 max)					{ VERIFY(max);  return randI()%max; }

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	cdq
	mov	ecx, 15					; 0000000fH
	idiv	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 306  : 		delay			= ::Random.randI	(5*2,5*5);

	lea	eax, DWORD PTR [edi+10]
	mov	DWORD PTR [esi+176], edi
	add	eax, edx
	mov	DWORD PTR [esi+172], eax
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN958@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 120  : 	if (Device.dwFrame==L->frame_render)	return;

	mov	eax, DWORD PTR [eax+244]
	cmp	eax, DWORD PTR [esi+180]
	je	SHORT $LN912@Calculate

; 121  : 	L->frame_render							=	Device.dwFrame;

	mov	DWORD PTR [esi+180], eax

; 122  : 	if (L->flags.bStatic)					return;	// skip static lighting, 'cause they are in lmaps

	mov	eax, DWORD PTR [esi+60]
	test	al, 16					; 00000010H
	jne	SHORT $LN912@Calculate
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	test	BYTE PTR ?ps_r1_flags@@3U?$_flags@I@@A, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 123  : 	if (ps_r1_flags.test(R1FLAG_DLIGHTS))	RImplementation.L_Dynamic->add	(L);

	je	SHORT $LN912@Calculate
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 308  : 	if (L->range<0.1f)				return;

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [esi+100]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 123  : 	if (ps_r1_flags.test(R1FLAG_DLIGHTS))	RImplementation.L_Dynamic->add	(L);

	mov	ecx, DWORD PTR ?RImplementation@@3VCRender@@A+984
	mov	DWORD PTR _L$[esp+160], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 308  : 	if (L->range<0.1f)				return;

	ja	SHORT $LN912@Calculate

; 309  : 	if (0==L->spatial.sector)		return;

	cmp	DWORD PTR [esi+52], 0
	je	SHORT $LN912@Calculate

; 310  : 	if (IRender_Light::POINT==L->flags.type)

	and	eax, 15					; 0000000fH
	cmp	al, 1
	jne	SHORT $LN916@Calculate

; 311  : 	{
; 312  : 		// PPA
; 313  : 		selected_point.push_back	(L);

	add	ecx, 28					; 0000001cH

; 314  : 	} else {

	jmp	SHORT $LN971@Calculate
$LN893@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 310  : 	vis.hom_frame			= frame_current + delay;

	lea	eax, DWORD PTR [edi+1]

; 311  : 	vis.hom_tested			= frame_current	;

	mov	DWORD PTR [esi+176], edi
	mov	DWORD PTR [esi+172], eax
	jmp	SHORT $LN912@Calculate
$LN916@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 316  : 		selected_spot.push_back		(L);

	add	ecx, 40					; 00000028H
$LN971@Calculate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN929@Calculate
	mov	DWORD PTR [eax], esi

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN912@Calculate
$LN929@Calculate:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _L$[esp+160]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>
$LN912@Calculate:
	mov	edx, DWORD PTR _o_it$1$[esp+160]
$LN11@Calculate:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+572]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 408  : 			for (u32 o_it=0; o_it<lstRenderables.size(); o_it++)

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+568]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 408  : 			for (u32 o_it=0; o_it<lstRenderables.size(); o_it++)

	mov	DWORD PTR _o_it$1$[esp+160], edx
	cmp	edx, eax
	jb	$LL13@Calculate
$LN12@Calculate:

; 456  : 							vis_data&		vis		= L->get_homdata	( );
; 457  : 							if	(HOM.visible(vis))	L_DB->add_light		(L);
; 458  : 						}
; 459  : 					}
; 460  : 					break;	// exit loop on frustums
; 461  : 				}
; 462  : 			}
; 463  : 		}
; 464  : 
; 465  : 		// Calculate miscelaneous stuff
; 466  : 		L_Shadows->calculate								();

	mov	ecx, DWORD PTR [ebx+988]
	call	?calculate@CLightShadows@@QAEXXZ	; CLightShadows::calculate

; 467  : 		L_Projector->calculate								();

	mov	ecx, DWORD PTR [ebx+992]
	call	?calculate@CLightProjector@@QAEXXZ	; CLightProjector::calculate

; 468  : 	}

	jmp	SHORT $LN31@Calculate
$LN30@Calculate:

; 469  : 	else
; 470  : 	{
; 471  : 		set_Object											(0);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	0
	call	DWORD PTR [eax+84]
$LN31@Calculate:

; 472  : 		/*
; 473  : 		g_pGameLevel->pHUD->Render_First					();	
; 474  : 		g_pGameLevel->pHUD->Render_Last						();	
; 475  : 
; 476  : 		// Calculate miscelaneous stuff
; 477  : 		L_Shadows->calculate								();
; 478  : 		L_Projector->calculate								();
; 479  : 		*/
; 480  : 	}
; 481  : 
; 482  : 	// End calc
; 483  : 	Device.Statistic->RenderCALC.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN933@Calculate
	lea	ecx, DWORD PTR [esi+1272]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+1328], eax
	adc	DWORD PTR [esi+1332], edx
$LN933@Calculate:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 484  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Calculate@CRender@@UAEXXZ ENDP				; CRender::Calculate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_VP$ = -28						; size = 24
?rmNear@CRender@@UAEXXZ PROC				; CRender::rmNear
; _this$ = ecx

; 487  : {

	sub	esp, 32					; 00000020H

; 488  : 	IRender_Target* T	=	getTarget	();

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+60]
	mov	esi, eax

; 489  : 	D3DVIEWPORT9 VP		=	{0,0,T->get_width(),T->get_height(),0,0.02f };

	mov	DWORD PTR _VP$[esp+36], 0
	mov	DWORD PTR _VP$[esp+40], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+40]
	mov	DWORD PTR _VP$[esp+44], eax
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR _VP$[esp+48], eax

; 490  : 	CHK_DX				(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$[esp+36]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _VP$[esp+52], 0
	mov	DWORD PTR _VP$[esp+56], 1017370378	; 3ca3d70aH
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]

; 491  : }

	pop	esi
	add	esp, 32					; 00000020H
	ret	0
?rmNear@CRender@@UAEXXZ ENDP				; CRender::rmNear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_VP$ = -24						; size = 24
?rmFar@CRender@@UAEXXZ PROC				; CRender::rmFar
; _this$ = ecx

; 493  : {

	sub	esp, 24					; 00000018H

; 494  : 	IRender_Target* T	=	getTarget	();

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+60]
	mov	esi, eax

; 495  : 	D3DVIEWPORT9 VP		=	{0,0,T->get_width(),T->get_height(),0.99999f,1.f };

	mov	DWORD PTR _VP$[esp+28], 0
	mov	DWORD PTR _VP$[esp+32], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+40]
	mov	DWORD PTR _VP$[esp+36], eax
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR _VP$[esp+40], eax

; 496  : 	CHK_DX				(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$[esp+28]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _VP$[esp+44], 1065353048	; 3f7fff58H
	mov	DWORD PTR _VP$[esp+48], 1065353216	; 3f800000H
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]
	pop	esi

; 497  : }

	add	esp, 24					; 00000018H
	ret	0
?rmFar@CRender@@UAEXXZ ENDP				; CRender::rmFar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_VP$ = -28						; size = 24
?rmNormal@CRender@@UAEXXZ PROC				; CRender::rmNormal
; _this$ = ecx

; 499  : {

	sub	esp, 32					; 00000020H

; 500  : 	IRender_Target* T	=	getTarget	();

	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+60]
	mov	esi, eax

; 501  : 	D3DVIEWPORT9 VP		= {0,0,T->get_width(),T->get_height(),0,1.f };

	mov	DWORD PTR _VP$[esp+36], 0
	mov	DWORD PTR _VP$[esp+40], 0
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+40]
	mov	DWORD PTR _VP$[esp+44], eax
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR _VP$[esp+48], eax

; 502  : 	CHK_DX				(HW.pDevice->SetViewport(&VP));

	lea	edx, DWORD PTR _VP$[esp+36]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	DWORD PTR _VP$[esp+52], 0
	mov	DWORD PTR _VP$[esp+56], 1065353216	; 3f800000H
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+188]

; 503  : }

	pop	esi
	add	esp, 32					; 00000020H
	ret	0
?rmNormal@CRender@@UAEXXZ ENDP				; CRender::rmNormal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_o_main$1$ = -36					; size = 4
_range$1 = -32						; size = 4
_this$1$ = -28						; size = 4
_dir$2 = -24						; size = 12
_start$3 = -12						; size = 12
?Render@CRender@@UAEXXZ PROC				; CRender::Render
; _this$ = ecx

; 507  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 40					; 00000028H

; 509  : 	Device.Statistic->RenderDUMP.Begin();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	ebp, DWORD PTR __imp_?QPC@CPU@@YA_KXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 507  : {

	push	esi

; 509  : 	Device.Statistic->RenderDUMP.Begin();

	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 509  : 	Device.Statistic->RenderDUMP.Begin();

	add	esi, 1512				; 000005e8H
	push	edi
	mov	edi, ecx
	mov	DWORD PTR ?g_r@@3IA, 1			; g_r
	mov	DWORD PTR _this$1$[esp+56], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN11@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	ebp
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN11@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 511  : 	Target->Begin								();

	mov	esi, DWORD PTR [edi+1012]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp

; 190  : 	if (!Perform())	

	mov	ecx, esi
	call	?Perform@CRenderTarget@@AAEHXZ		; CRenderTarget::Perform
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	0
	test	eax, eax
	jne	SHORT $LN18@Render

; 191  : 	{
; 192  : 		// Base RT
; 193  : 		RCache.set_RT			(HW.pBaseRT);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	DWORD PTR [eax+12]
	call	DWORD PTR __imp_?set_RT@CBackend@@QAEXPAUIDirect3DSurface9@@I@Z

; 194  : 		RCache.set_ZB			(HW.pBaseZB);

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+16]
	call	DWORD PTR __imp_?set_ZB@CBackend@@QAEXPAUIDirect3DSurface9@@@Z

; 195  : 		curWidth				= Device.dwWidth;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+256]
	mov	DWORD PTR [esi+16], eax

; 196  : 		curHeight				= Device.dwHeight;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+260]

; 197  : 	} else {

	jmp	SHORT $LN19@Render
$LN18@Render:

; 198  : 		// Our 
; 199  : 		RCache.set_RT			(RT->pRT);

	mov	eax, DWORD PTR [esi+24]
	push	DWORD PTR [eax+16]
	call	DWORD PTR __imp_?set_RT@CBackend@@QAEXPAUIDirect3DSurface9@@I@Z

; 200  : 		RCache.set_ZB			(ZB);

	push	DWORD PTR [esi+32]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_ZB@CBackend@@QAEXPAUIDirect3DSurface9@@@Z

; 201  : 		curWidth				= rtWidth;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax

; 202  : 		curHeight				= rtHeight;

	mov	eax, DWORD PTR [esi+12]
$LN19@Render:

; 203  : 	}
; 204  : 	Device.Clear				();

	mov	DWORD PTR [esi+20], eax
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	call	DWORD PTR __imp_?Clear@CRenderDevice@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 512  : 	o.vis_intersect								= FALSE			;

	and	DWORD PTR [edi+628], -2			; fffffffeH

; 513  : 	phase										= PHASE_NORMAL	;
; 514  : 	r_dsgraph_render_hud						();				// hud

	mov	ecx, edi
	mov	DWORD PTR [edi+292], 0
	call	?r_dsgraph_render_hud@R_dsgraph_structure@@QAEXXZ ; R_dsgraph_structure::r_dsgraph_render_hud

; 515  : 	r_dsgraph_render_graph						(0);			// normal level

	push	1
	push	0
	mov	ecx, edi
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph

; 516  : 	if(Details)Details->Render					();				// grass / details

	mov	ebx, DWORD PTR [edi+1004]
	test	ebx, ebx
	je	$LN43@Render
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 273  : 	if (0==dtFS)						return;

	cmp	DWORD PTR [ebx+1088], 0
	je	$LN43@Render

; 274  : 	if (!psDeviceFlags.is(rsDetails))	return;

	mov	eax, DWORD PTR __imp_?psDeviceFlags@@3U?$_flags@I@@A
	test	BYTE PTR [eax], 64			; 00000040H
	je	$LN43@Render
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 176  : 		if (m_frame_calc == Device.dwFrame)

	mov	eax, DWORD PTR [ebx+701276]
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	cmp	eax, DWORD PTR [esi+244]
	je	SHORT $LN51@Render

; 177  : 			return;
; 178  : 
; 179  : 		MT_CALC						(); 

	mov	ecx, ebx
	call	?MT_CALC@CDetailManager@@QAGXXZ		; CDetailManager::MT_CALC
	mov	esi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN51@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 280  : 	Device.Statistic->RenderDUMP_DT_Render.Begin	();

	mov	esi, DWORD PTR [esi+436]
	add	esi, 2328				; 00000918H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN57@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	ebp
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN57@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 282  : 	float factor			= g_pGamePersistent->Environment().wind_strength_factor;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A

; 62   : 	float fi	= 1.f-f;

	movss	xmm2, DWORD PTR __real@3f800000

; 282  : 	float factor			= g_pGamePersistent->Environment().wind_strength_factor;

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+1116]
	movss	xmm3, DWORD PTR [eax+360]

; 62   : 	float fi	= 1.f-f;

	subss	xmm2, xmm3

; 63   : 	amp1		= fi*A.amp1  + f*B.amp1;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ebx+1056]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+1036]
	addss	xmm1, xmm0

; 64   : 	amp2		= fi*A.amp2  + f*B.amp2;

	movaps	xmm0, xmm3
	movss	DWORD PTR [ebx+1076], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+1040]
	mulss	xmm0, DWORD PTR [ebx+1060]
	addss	xmm1, xmm0

; 65   : 	rot1		= fi*A.rot1  + f*B.rot1;

	movaps	xmm0, xmm3
	movss	DWORD PTR [ebx+1080], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+1028]
	mulss	xmm0, DWORD PTR [ebx+1048]
	addss	xmm1, xmm0

; 66   : 	rot2		= fi*A.rot2  + f*B.rot2;

	movaps	xmm0, xmm3
	movss	DWORD PTR [ebx+1068], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebx+1032]
	mulss	xmm0, DWORD PTR [ebx+1052]
	addss	xmm1, xmm0
	movss	DWORD PTR [ebx+1072], xmm1

; 67   : 	speed		= fi*A.speed + f*B.speed;

	mulss	xmm2, DWORD PTR [ebx+1044]
	mulss	xmm3, DWORD PTR [ebx+1064]
	addss	xmm2, xmm3
	movss	DWORD PTR [ebx+1084], xmm2

; 285  : 	RCache.set_CullMode		(CULL_NONE);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [ecx+8916], 1
	je	SHORT $LN68@Render
	mov	DWORD PTR [ecx+8916], 1
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	1
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
$LN68@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 286  : 	RCache.set_xform_world	(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 123  : 	IC bool							UseVS			()		{ return HW.Caps.geometry_major >= 1; }

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 287  : 	if (UseVS())			hw_Render	();

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\detailmanager.h

; 123  : 	IC bool							UseVS			()		{ return HW.Caps.geometry_major >= 1; }

	cmp	WORD PTR [eax+48], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 287  : 	if (UseVS())			hw_Render	();

	jb	SHORT $LN46@Render
	call	?hw_Render@CDetailManager@@QAEXXZ	; CDetailManager::hw_Render
	jmp	SHORT $LN47@Render
$LN46@Render:

; 288  : 	else					soft_Render	();

	call	?soft_Render@CDetailManager@@QAEXXZ	; CDetailManager::soft_Render
$LN47@Render:

; 289  : 	RCache.set_CullMode		(CULL_CCW);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 3
	je	SHORT $LN73@Render
	mov	DWORD PTR [eax+8916], 3
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	3
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
$LN73@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 290  : 	Device.Statistic->RenderDUMP_DT_Render.End	();

	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	cmp	DWORD PTR [eax], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 290  : 	Device.Statistic->RenderDUMP_DT_Render.End	();

	mov	esi, DWORD PTR [ecx+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	je	SHORT $LN75@Render
	lea	ecx, DWORD PTR [esi+2328]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2384], eax
	adc	DWORD PTR [esi+2388], edx
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN75@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager.cpp

; 291  : 	m_frame_rendered		= Device.dwFrame;

	mov	eax, DWORD PTR [ecx+244]
	mov	DWORD PTR [ebx+701280], eax
$LN43@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 517  : 	r_dsgraph_render_lods						(true,false);	// lods - FB

	push	0
	push	1
	mov	ecx, edi
	call	?r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z ; R_dsgraph_structure::r_dsgraph_render_lods

; 518  : 
; 519  : 	g_pGamePersistent->Environment().RenderSky	();				// sky / sun

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1116]
	call	DWORD PTR __imp_?RenderSky@CEnvironment@@QAEXXZ

; 520  : 	g_pGamePersistent->Environment().RenderClouds	();				// clouds

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1116]
	call	DWORD PTR __imp_?RenderClouds@CEnvironment@@QAEXXZ

; 521  : 
; 522  : 	r_pmask										(true,false);	// disable priority "1"
; 523  : 	o.vis_intersect								= TRUE			;

	or	DWORD PTR [edi+628], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	WORD PTR [edi+300], 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 525  : 	L_Dynamic->render							();				// addititional light sources

	mov	esi, DWORD PTR [edi+984]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	BYTE PTR [edi+302], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 524  : 	HOM.Disable									();

	mov	DWORD PTR [edi+744], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+44]
	sub	eax, DWORD PTR [esi+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 294  : 	if (selected_spot.size())		{ 

	test	eax, -4					; fffffffcH
	je	SHORT $LN85@Render

; 295  : 		RImplementation.phase		= CRender::PHASE_SPOT;
; 296  : 		render_spot			();	

	mov	ecx, esi
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+292, 2
	call	?render_spot@CLightR_Manager@@QAEXXZ	; CLightR_Manager::render_spot

; 297  : 		selected_spot.clear	();	

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+44], eax
$LN85@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+32]
	sub	eax, DWORD PTR [esi+28]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 299  : 	if (selected_point.size())		{ 

	test	eax, -4					; fffffffcH
	je	SHORT $LN86@Render

; 300  : 		RImplementation.phase		= CRender::PHASE_POINT;
; 301  : 		render_point		();	

	mov	ecx, esi
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+292, 1
	call	?render_point@CLightR_Manager@@QAEXXZ	; CLightR_Manager::render_point

; 302  : 		selected_point.clear(); 

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+32], eax
$LN86@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 526  : 	if(Wallmarks){

	mov	ecx, DWORD PTR [edi+1000]
	test	ecx, ecx
	je	SHORT $LN3@Render

; 527  : 		g_r										= 0;

	mov	DWORD PTR ?g_r@@3IA, 0			; g_r

; 528  : 		Wallmarks->Render						();				// wallmarks has priority as normal geometry

	call	?Render@CWallmarksEngine@@QAEXXZ	; CWallmarksEngine::Render
$LN3@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	WORD PTR [edi+300], 257			; 00000101H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	cmp	DWORD PTR [edi+736], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 532  : 	phase										= PHASE_NORMAL	;

	mov	DWORD PTR [edi+292], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	setne	al
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	BYTE PTR [edi+302], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 531  : 	o.vis_intersect								= FALSE			;

	and	DWORD PTR [edi+628], -2			; fffffffeH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\HOM.cpp

; 340  : 	bEnabled			= m_pModel?TRUE:FALSE;

	mov	DWORD PTR [edi+744], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 534  : 	if(L_Shadows)L_Shadows->render				();				// ... and shadows

	mov	ecx, DWORD PTR [edi+988]
	test	ecx, ecx
	je	SHORT $LN4@Render
	call	?render@CLightShadows@@QAEXXZ		; CLightShadows::render
$LN4@Render:

; 535  : 	r_dsgraph_render_lods						(false,true);	// lods - FB

	push	1
	push	0
	mov	ecx, edi
	call	?r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z ; R_dsgraph_structure::r_dsgraph_render_lods

; 536  : 	r_dsgraph_render_graph						(1);			// normal level, secondary priority

	push	1
	push	1
	mov	ecx, edi
	call	?r_dsgraph_render_graph@R_dsgraph_structure@@QAEXI_N@Z ; R_dsgraph_structure::r_dsgraph_render_graph

; 537  : 	PortalTraverser.fade_render					();				// faded-portals

	call	?fade_render@CPortalTraverser@@QAEXXZ	; CPortalTraverser::fade_render
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 209  : 	{ if (pool) recurseRL(nodes,CB);  }

	cmp	DWORD PTR [edi+356], 0
	je	SHORT $LN107@Render
	mov	ebx, DWORD PTR [edi+352]

; 83   : 		if (N->right)	recurseRL(N->right,CB);

	mov	eax, DWORD PTR [ebx+88]
	test	eax, eax
	je	SHORT $LN106@Render
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [edi+352]
	call	?recurseRL@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@P6IX0@Z@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::recurseRL
$LN106@Render:

; 84   : 		CB(N);

	mov	ecx, ebx
	call	?sorted_L1@@YIXPAUTNode@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@@Z ; sorted_L1

; 85   : 		if (N->left)	recurseRL(N->left,CB);

	mov	eax, DWORD PTR [ebx+84]
	test	eax, eax
	je	SHORT $LN107@Render
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [edi+352]
	call	?recurseRL@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@P6IX0@Z@Z ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::recurseRL
$LN107@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 539  : 	if(L_Glows)L_Glows->Render					();				// glows

	mov	ebx, DWORD PTR [edi+996]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render.cpp

; 395  : 	mapSorted.clear			();

	mov	DWORD PTR [edi+356], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 539  : 	if(L_Glows)L_Glows->Render					();				// glows

	test	ebx, ebx
	je	$LN167@Render
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ebx+12]
	cmp	eax, DWORD PTR [ebx+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 198  : 	if (Selected.empty())					return		;

	je	$LN167@Render

; 199  : 	RCache.set_xform_world					(Fidentity)	;

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 201  : 	Device.Statistic->RenderDUMP_Glows.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 201  : 	Device.Statistic->RenderDUMP_Glows.Begin	();

	add	esi, 1992				; 000007c8H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN184@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN184@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	ebp
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN184@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	xor	ebp, ebp
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _o_main$1$[esp+56], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 212  : 	Fvector start	= Device.vCameraPosition;

	mov	eax, DWORD PTR [ecx+488]
	mov	DWORD PTR _start$3[esp+56], eax
	mov	eax, DWORD PTR [ecx+492]
	mov	DWORD PTR _start$3[esp+60], eax
	mov	eax, DWORD PTR [ecx+496]
	mov	DWORD PTR _start$3[esp+64], eax

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	cmp	DWORD PTR ?ps_r1_GlowsPerFrame@@3HA, ebp ; ps_r1_GlowsPerFrame
	jle	$LN180@Render
	mov	eax, DWORD PTR [ebx+68]
$LL126@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [ebx+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+16]
	sub	ecx, esi
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	div	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [esi+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 217  : 		if (G.dwFrame=='test')	break;

	cmp	DWORD PTR [esi+72], 1952805748		; 74657374H
	je	$LN185@Render

; 218  : 		G.dwFrame	=	'test';

	mov	DWORD PTR [esi+72], 1952805748		; 74657374H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [esi+16]
	subss	xmm2, DWORD PTR _start$3[esp+56]
	movss	DWORD PTR _dir$2[esp+56], xmm2

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [esi+20]
	subss	xmm3, DWORD PTR _start$3[esp+60]

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+60], xmm3
	movaps	xmm1, xmm3
	movss	xmm4, DWORD PTR [esi+24]
	subss	xmm4, DWORD PTR _start$3[esp+64]
	mulss	xmm1, xmm3

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+64], xmm4

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 221  : 		if (range>EPS_S)	{

	comiss	xmm1, DWORD PTR __real@33d6bf95
	movss	DWORD PTR _range$1[esp+56], xmm1
	jbe	SHORT $LN124@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm0, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR [esi+124]
	push	DWORD PTR _o_main$1$[esp+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	divss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	mov	edi, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	push	eax
	lea	eax, DWORD PTR _dir$2[esp+64]
	push	3
	push	ecx
	fld	DWORD PTR _range$1[esp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm2, xmm0
	mulss	xmm3, xmm0
	mulss	xmm4, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	fstp	DWORD PTR [esp]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+76], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR _start$3[esp+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+80], xmm3
	movss	DWORD PTR _dir$2[esp+84], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	mov	ecx, DWORD PTR [edi]
	push	eax
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	mov	DWORD PTR [esi+120], eax
$LN124@Render:

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	inc	DWORD PTR [ebx+68]
	inc	ebp
	mov	eax, DWORD PTR [ebx+68]
	cmp	ebp, DWORD PTR ?ps_r1_GlowsPerFrame@@3HA ; ps_r1_GlowsPerFrame
	jl	$LL126@Render
$LN185@Render:
	mov	edi, DWORD PTR _this$1$[esp+56]
$LN180@Render:

; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	// 2. Render selected
; 228  : 	render_selected			();

	mov	ecx, ebx
	call	?render_selected@CGlowManager@@QAEXXZ	; CGlowManager::render_selected

; 203  : 	Device.Statistic->RenderDUMP_Glows.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN167@Render
	lea	ecx, DWORD PTR [esi+1992]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2048], eax
	adc	DWORD PTR [esi+2052], edx
$LN167@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 540  : 	g_pGamePersistent->Environment().RenderFlares	();				// lens-flares

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1116]
	call	DWORD PTR __imp_?RenderFlares@CEnvironment@@QAEXXZ

; 541  : 	g_pGamePersistent->Environment().RenderLast	();				// rain/thunder-bolts

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+1116]
	call	DWORD PTR __imp_?RenderLast@CEnvironment@@QAEXXZ

; 542  : 
; 543  : 	// Postprocess, if necessary
; 544  : 	Target->End									();

	mov	ecx, DWORD PTR [edi+1012]
	call	?End@CRenderTarget@@QAEXXZ		; CRenderTarget::End

; 545  : 	if (L_Projector) L_Projector->finalize		();

	mov	ecx, DWORD PTR [edi+992]
	test	ecx, ecx
	je	SHORT $LN6@Render
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h

; 46   : 	void					finalize		()			{ receivers.clear(); taskid.clear();	}

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+36], eax
$LN6@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 548  : 	Device.Statistic->RenderDUMP.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN176@Render
	lea	ecx, DWORD PTR [esi+1512]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+1568], eax
	adc	DWORD PTR [esi+1572], edx
$LN176@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 549  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@CRender@@UAEXXZ ENDP				; CRender::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_pv$ = 8						; size = 4
_w$dead$ = 12						; size = 4
_h$dead$ = 16						; size = 4
_k$dead$ = 20						; size = 4
?ApplyBlur4@CRender@@QAEXPAUTL4uv@FVF@@IIM@Z PROC	; CRender::ApplyBlur4
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	eax, DWORD PTR _pv$[esp-4]
	mov	DWORD PTR [eax], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+4], 1140850688		; 44000000H
	mov	DWORD PTR [eax+8], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 563  : 	pv->p.set(EPS,			float(_h+EPS),	EPS,1.f); pv->color=_c; pv->uv[0].set(p0.x-kw,p1.y-kh);pv->uv[1].set(p0.x+kw,p1.y+kh);pv->uv[2].set(p0.x+kw,p1.y-kh);pv->uv[3].set(p0.x-kw,p1.y+kh);pv++;

	mov	DWORD PTR [eax+16], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+20], -1174405120		; ba000000H
	mov	DWORD PTR [eax+24], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+28], 991952896		; 3b200000H
	mov	DWORD PTR [eax+32], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+36], 991952896		; 3b200000H
	mov	DWORD PTR [eax+40], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+44], -1174405120		; ba000000H
	mov	DWORD PTR [eax+48], 1065373696		; 3f805000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+52], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+56], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+60], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+64], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 564  : 	pv->p.set(EPS,			EPS,			EPS,1.f); pv->color=_c; pv->uv[0].set(p0.x-kw,p0.y-kh);pv->uv[1].set(p0.x+kw,p0.y+kh);pv->uv[2].set(p0.x+kw,p0.y-kh);pv->uv[3].set(p0.x-kw,p0.y+kh);pv++;

	mov	DWORD PTR [eax+68], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+72], -1174405120		; ba000000H
	mov	DWORD PTR [eax+76], -1174405120		; ba000000H
	mov	DWORD PTR [eax+80], 991952896		; 3b200000H
	mov	DWORD PTR [eax+84], 991952896		; 3b200000H
	mov	DWORD PTR [eax+88], 991952896		; 3b200000H
	mov	DWORD PTR [eax+92], -1174405120		; ba000000H
	mov	DWORD PTR [eax+96], -1174405120		; ba000000H
	mov	DWORD PTR [eax+100], 991952896		; 3b200000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+104], 1140850688		; 44000000H
	mov	DWORD PTR [eax+108], 1140850688		; 44000000H
	mov	DWORD PTR [eax+112], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 565  : 	pv->p.set(float(_w+EPS),float(_h+EPS),	EPS,1.f); pv->color=_c; pv->uv[0].set(p1.x-kw,p1.y-kh);pv->uv[1].set(p1.x+kw,p1.y+kh);pv->uv[2].set(p1.x+kw,p1.y-kh);pv->uv[3].set(p1.x-kw,p1.y+kh);pv++;

	mov	DWORD PTR [eax+120], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+124], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+128], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+132], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+136], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+140], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+144], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+148], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+152], 1065373696		; 3f805000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector4.h

; 17   : 	IC	SelfRef 	set(T _x, T _y, T _z, T _w=1)		{ x=_x;		y=_y;		z=_z;		w=_w;		return *this; }

	mov	DWORD PTR [eax+156], 1140850688		; 44000000H
	mov	DWORD PTR [eax+160], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+164], 925353388		; 3727c5acH
	mov	DWORD PTR [eax+168], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 566  : 	pv->p.set(float(_w+EPS),EPS,			EPS,1.f); pv->color=_c; pv->uv[0].set(p1.x-kw,p0.y-kh);pv->uv[1].set(p1.x+kw,p0.y+kh);pv->uv[2].set(p1.x+kw,p0.y-kh);pv->uv[3].set(p1.x-kw,p0.y+kh);pv++;

	mov	DWORD PTR [eax+172], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+176], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+180], -1174405120	; ba000000H
	mov	DWORD PTR [eax+184], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+188], 991952896		; 3b200000H
	mov	DWORD PTR [eax+192], 1065373696		; 3f805000H
	mov	DWORD PTR [eax+196], -1174405120	; ba000000H
	mov	DWORD PTR [eax+200], 1065345024		; 3f7fe000H
	mov	DWORD PTR [eax+204], 991952896		; 3b200000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 567  : }

	ret	16					; 00000010H
?ApplyBlur4@CRender@@QAEXPAUTL4uv@FVF@@IIM@Z ENDP	; CRender::ApplyBlur4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
tv183 = -4						; size = 4
tv181 = -4						; size = 4
__F$ = 8						; size = 4
?Statistics@CRender@@UAEXPAVCGameFont@@@Z PROC		; CRender::Statistics
; _this$ = ecx

; 571  : {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 572  : 	CGameFont&	F	= *_F;
; 573  : 	F.OutNext	(" **** Occ-Q(%03.1f) **** ",100.f*f32(stats.o_culled)/f32(stats.o_queries?stats.o_queries:1));

	mov	edx, 1
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebx+632]
	test	eax, eax
	fild	DWORD PTR [ebx+636]
	cmovne	edx, eax
	mov	eax, DWORD PTR [ebx+636]
	test	eax, eax
	jns	SHORT $LN5@Statistics
	fadd	DWORD PTR __real@4f800000
$LN5@Statistics:
	fmul	DWORD PTR __real@42c80000
	mov	DWORD PTR tv181[esp+16], edx
	fild	DWORD PTR tv181[esp+16]
	test	edx, edx
	jns	SHORT $LN6@Statistics
	fadd	DWORD PTR __real@4f800000
$LN6@Statistics:
	fdivp	ST(1), ST(0)
	sub	esp, 8
	mov	edi, DWORD PTR __F$[esp+20]
	mov	esi, DWORD PTR __imp_?OutNext@CGameFont@@QAAXPBDZZ
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BK@OKMDHAJE@?5?$CK?$CK?$CK?$CK?5Occ?9Q?$CI?$CF03?41f?$CJ?5?$CK?$CK?$CK?$CK?5@
	push	edi
	call	esi

; 574  : 	F.OutNext	(" total  : %2d",	stats.o_queries	);	stats.o_queries = 0;

	push	DWORD PTR [ebx+632]
	push	OFFSET ??_C@_0O@OKFLLHFA@?5total?5?5?3?5?$CF2d@
	push	edi
	call	esi

; 575  : 	F.OutNext	(" culled : %2d",	stats.o_culled	);	stats.o_culled	= 0;

	push	DWORD PTR [ebx+636]
	mov	DWORD PTR [ebx+632], 0
	push	OFFSET ??_C@_0O@CFLPMGDN@?5culled?5?3?5?$CF2d@
	push	edi
	call	esi

; 576  : 	F.OutSkip	();

	fld1
	add	esp, 36					; 00000024H
	mov	ecx, edi
	mov	DWORD PTR [ebx+636], 0
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?OutSkip@CGameFont@@QAEXM@Z
	pop	edi
	pop	esi
	pop	ebx

; 577  : #ifdef DEBUG
; 578  : 	HOM.stats	();
; 579  : #endif
; 580  : }

	pop	ecx
	ret	4
?Statistics@CRender@@UAEXPAVCGameFont@@@Z ENDP		; CRender::Statistics
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
;	COMDAT ?Open@includer@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
_TEXT	SEGMENT
_R$ = -524						; size = 4
_pname$ = -520						; size = 520
_this$ = 8						; size = 4
_IncludeType$ = 12					; size = 4
_pFileName$ = 16					; size = 4
_pParentData$ = 20					; size = 4
_ppData$ = 24						; size = 4
_pBytes$ = 28						; size = 4
?Open@includer@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z PROC ; includer::Open, COMDAT

; 587  : 	{

	sub	esp, 524				; 0000020cH

; 588  : 		string_path				pname;
; 589  : 		strconcat(sizeof(pname), pname, ::Render->getShaderPath(), pFileName);

	mov	eax, DWORD PTR __imp_?Render@@3PAVIRender_interface@@A
	push	esi
	mov	esi, DWORD PTR _pFileName$[esp+524]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+40]
	push	eax
	lea	eax, DWORD PTR _pname$[esp+540]
	push	eax
	push	520					; 00000208H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD1@Z

; 590  : 		IReader* R = FS.r_open("$game_shaders$", pname);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _pname$[esp+548]
	mov	edi, DWORD PTR __imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD0@Z
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0P@IMLOOCAI@$game_shaders$@
	call	edi
	mov	DWORD PTR _R$[esp+532], eax

; 591  : 		if (0 == R) {

	test	eax, eax
	jne	SHORT $LN3@Open

; 592  : 			// possibly in shared directory or somewhere else - open directly
; 593  : 			R = FS.r_open("$game_shaders$", pFileName);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	esi
	push	OFFSET ??_C@_0P@IMLOOCAI@$game_shaders$@
	mov	ecx, DWORD PTR [ecx]
	call	edi
	mov	DWORD PTR _R$[esp+532], eax

; 594  : 			if (0 == R)			return			E_FAIL;

	test	eax, eax
	jne	SHORT $LN3@Open
	pop	edi
	mov	eax, -2147467259			; 80004005H

; 607  : 	}

	pop	esi
	add	esp, 524				; 0000020cH
	ret	24					; 00000018H
$LN3@Open:

; 595  : 		}
; 596  : 
; 597  : 		// duplicate and zero-terminate
; 598  : 		size_t size = R->length();

	mov	edi, DWORD PTR [eax+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 599  : 		u8* data = xr_alloc<u8>(size + 1);

	lea	eax, DWORD PTR [edi+1]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	ecx, DWORD PTR _R$[esp+532]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 599  : 		u8* data = xr_alloc<u8>(size + 1);

	mov	esi, eax

; 600  : 		CopyMemory(data, R->pointer(), size);

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 600  : 		CopyMemory(data, R->pointer(), size);

	push	edx
	push	esi
	call	_memcpy

; 601  : 		data[size] = 0;
; 602  : 		FS.r_close(R);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _R$[esp+544]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+edi], 0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?r_close@CLocatorAPI@@QAEXAAPAVIReader@@@Z

; 603  : 
; 604  : 		*ppData = data;

	mov	eax, DWORD PTR _ppData$[esp+528]
	mov	DWORD PTR [eax], esi

; 605  : 		*pBytes = static_cast<u32>(size);

	mov	eax, DWORD PTR _pBytes$[esp+528]
	mov	DWORD PTR [eax], edi

; 606  : 		return	D3D_OK;

	xor	eax, eax
	pop	edi

; 607  : 	}

	pop	esi
	add	esp, 524				; 0000020cH
	ret	24					; 00000018H
?Open@includer@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z ENDP ; includer::Open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
;	COMDAT ?Close@includer@@UAGJPBX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pData$ = 12						; size = 4
?Close@includer@@UAGJPBX@Z PROC				; includer::Close, COMDAT
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _pData$[esp-4]
	test	eax, eax
	je	SHORT $LN6@Close
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@Close:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 612  : 	}

	xor	eax, eax
	ret	8
?Close@includer@@UAGJPBX@Z ENDP				; includer::Close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
__disasm$1 = -532					; size = 4
_data$2 = -532						; size = 4
_data$3 = -532						; size = 4
_W$4 = -528						; size = 4
_pTarget$1$ = -524					; size = 4
_dname$5 = -520						; size = 520
_buffer_size$dead$ = 8					; size = 4
_file_name$ = 12					; size = 4
_result$ = 16						; size = 4
_disasm$ = 20						; size = 1
?create_shader@@YAJQBDPBKI0AAPAX_N@Z PROC		; create_shader
; _pTarget$ = ecx
; _buffer$ = edx

; 628  : {

	sub	esp, 532				; 00000214H

; 629  : 	HRESULT		_result = E_FAIL;
; 630  : 	if (pTarget[0] == 'p')

	mov	eax, DWORD PTR _result$[esp+528]
	cmp	BYTE PTR [ecx], 112			; 00000070H
	push	ebx
	push	ebp
	mov	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	ebp, DWORD PTR _file_name$[esp+536]
	push	esi
	push	edi
	mov	DWORD PTR _pTarget$1$[esp+548], ecx
	mov	esi, edx
	mov	ecx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [ebx+12]
	push	eax
	push	esi
	push	ecx
	mov	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@create_sha

; 631  : 	{
; 632  : 		SPS* sps_result = (SPS*)result;
; 633  : 		_result = HW.pDevice->CreatePixelShader(buffer, &sps_result->ps);

	call	DWORD PTR [edx+424]
	mov	edi, eax

; 634  : 		if (!SUCCEEDED(_result)) {

	test	edi, edi
	jns	SHORT $LN4@create_sha

; 635  : 			Log("! PS: ", file_name);

	push	ebp
	push	OFFSET ??_C@_06FBCGDMPM@?$CB?5PS?3?5@
$LN14@create_sha:

; 690  : }

	call	DWORD PTR __imp_?Log@@YAXPBD0@Z
	push	edi
	push	OFFSET ??_C@_0CB@LMOENIDG@?$CB?5CreatePixelShader?5hr?5?$DN?$DN?50x?$CF08@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 16					; 00000010H
	mov	eax, -2147467259			; 80004005H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 532				; 00000214H
	ret	0
$LN4@create_sha:

; 636  : 			Msg("! CreatePixelShader hr == 0x%08x", _result);
; 637  : 			return E_FAIL;
; 638  : 		}
; 639  : 
; 640  : 		LPCVOID data = NULL;
; 641  : 		_result = D3DXFindShaderComment(buffer, MAKEFOURCC('C', 'T', 'A', 'B'), &data, NULL);

	push	0
	lea	eax, DWORD PTR _data$3[esp+552]
	mov	DWORD PTR _data$3[esp+552], 0
	push	eax
	push	1111577667				; 42415443H
	push	esi
	call	DWORD PTR __imp__D3DXFindShaderComment@16
	mov	edi, eax

; 642  : 		if (SUCCEEDED(_result) && data)

	test	edi, edi
	js	SHORT $LN5@create_sha
	mov	eax, DWORD PTR _data$3[esp+548]
	test	eax, eax
	je	SHORT $LN5@create_sha

; 643  : 		{
; 644  : 			LPD3DXSHADER_CONSTANTTABLE	pConstants = LPD3DXSHADER_CONSTANTTABLE(data);
; 645  : 			sps_result->constants.parse(pConstants, 0x1);

	push	1
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	DWORD PTR __imp_?parse@R_constant_table@@QAEHPAXG@Z

; 646  : 	}

	jmp	SHORT $LN9@create_sha
$LN5@create_sha:

; 647  : 		else
; 648  : 		{
; 649  : 			Log("! PS: ", file_name);

	push	ebp
	push	OFFSET ??_C@_06FBCGDMPM@?$CB?5PS?3?5@

; 650  : 			Msg("! D3DXFindShaderComment hr == 0x%08x", _result);
; 651  : 		}
; 652  : }

	jmp	SHORT $LN13@create_sha
$LN2@create_sha:

; 653  : 	else
; 654  : 	{
; 655  : 		SVS* svs_result = (SVS*)result;
; 656  : 		_result = HW.pDevice->CreateVertexShader(buffer, &svs_result->vs);

	call	DWORD PTR [edx+364]
	mov	edi, eax

; 657  : 		if (!SUCCEEDED(_result)) {

	test	edi, edi
	jns	SHORT $LN7@create_sha

; 658  : 			Log("! VS: ", file_name);

	push	ebp
	push	OFFSET ??_C@_06NOGGMJFM@?$CB?5VS?3?5@

; 659  : 			Msg("! CreatePixelShader hr == 0x%08x", _result);
; 660  : 			return		E_FAIL;

	jmp	SHORT $LN14@create_sha
$LN7@create_sha:

; 661  : 		}
; 662  : 
; 663  : 		LPCVOID			data = NULL;
; 664  : 		_result = D3DXFindShaderComment(buffer, MAKEFOURCC('C', 'T', 'A', 'B'), &data, NULL);

	push	0
	lea	eax, DWORD PTR _data$2[esp+552]
	mov	DWORD PTR _data$2[esp+552], 0
	push	eax
	push	1111577667				; 42415443H
	push	esi
	call	DWORD PTR __imp__D3DXFindShaderComment@16
	mov	edi, eax

; 665  : 		if (SUCCEEDED(_result) && data)

	test	edi, edi
	js	SHORT $LN8@create_sha
	mov	eax, DWORD PTR _data$2[esp+548]
	test	eax, eax
	je	SHORT $LN8@create_sha

; 666  : 		{
; 667  : 			LPD3DXSHADER_CONSTANTTABLE	pConstants = LPD3DXSHADER_CONSTANTTABLE(data);
; 668  : 			svs_result->constants.parse(pConstants, 0x2);

	push	2
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	DWORD PTR __imp_?parse@R_constant_table@@QAEHPAXG@Z

; 669  : 		}

	jmp	SHORT $LN9@create_sha
$LN8@create_sha:

; 670  : 		else
; 671  : 		{
; 672  : 			Log("! VS: ", file_name);

	push	ebp
	push	OFFSET ??_C@_06NOGGMJFM@?$CB?5VS?3?5@
$LN13@create_sha:

; 673  : 			Msg("! D3DXFindShaderComment hr == 0x%08x", _result);
; 674  : 		}
; 675  : 	}
; 676  : 
; 677  : 	if (disasm)

	call	DWORD PTR __imp_?Log@@YAXPBD0@Z
	push	edi
	push	OFFSET ??_C@_0CF@PIPNAOIB@?$CB?5D3DXFindShaderComment?5hr?5?$DN?$DN?50@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 16					; 00000010H
$LN9@create_sha:
	cmp	BYTE PTR _disasm$[esp+544], 0
	je	$LN11@create_sha

; 678  : 	{
; 679  : 		ID3DXBuffer* _disasm = 0;
; 680  : 		D3DXDisassembleShader(LPDWORD(buffer), FALSE, 0, &_disasm);

	lea	eax, DWORD PTR __disasm$1[esp+548]
	mov	DWORD PTR __disasm$1[esp+548], 0
	push	eax
	push	0
	push	0
	push	esi
	call	DWORD PTR __imp__D3DXDisassembleShader@16

; 681  : 		string_path	dname;
; 682  : 		strconcat(sizeof(dname), dname, "disasm\\", file_name, ('v' == pTarget[0]) ? ".vs" : ".ps");

	mov	ecx, DWORD PTR _pTarget$1$[esp+548]
	mov	edx, OFFSET ??_C@_03MOLFLKIL@?4ps@
	mov	eax, OFFSET ??_C@_03MKDIMGDJ@?4vs@
	cmp	BYTE PTR [ecx], 118			; 00000076H
	cmovne	eax, edx
	push	eax
	push	ebp
	push	OFFSET ??_C@_07NGDNODCK@disasm?2@
	lea	eax, DWORD PTR _dname$5[esp+560]
	push	eax
	push	520					; 00000208H
	call	DWORD PTR __imp_?strconcat@@YAPADHPADPBD11@Z

; 683  : 		IWriter* W = FS.w_open("$app_data_root$", dname);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _dname$5[esp+568]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	OFFSET ??_C@_0BA@BDJNLMJI@$app_data_root$@
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
	mov	DWORD PTR _W$4[esp+548], eax

; 684  : 		W->w(_disasm->GetBufferPointer(), _disasm->GetBufferSize());

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR __disasm$1[esp+548]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR __disasm$1[esp+552]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _W$4[esp+552]
	push	eax
	call	DWORD PTR [esi+12]

; 685  : 		FS.w_close(W);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _W$4[esp+548]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z

; 686  : 		_RELEASE(_disasm);

	mov	ecx, DWORD PTR __disasm$1[esp+548]
	test	ecx, ecx
	je	SHORT $LN11@create_sha
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN11@create_sha:

; 687  : 	}
; 688  : 
; 689  : 	return _result;

	mov	eax, edi
	pop	edi

; 690  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 532				; 00000214H
	ret	0
?create_shader@@YAJQBDPBKI0AAPAX_N@Z ENDP		; create_shader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\LocatorAPI.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_crc$1$ = -3424						; size = 4
_pShaderBuf$1 = -3424					; size = 4
__result$1$ = -3420					; size = 4
_file$2 = -3420						; size = 4
_pErrorBuf$3 = -3416					; size = 4
_processor$4 = -3416					; size = 4
tv703 = -3412						; size = 4
_processor$5 = -3412					; size = 4
_extension$ = -3408					; size = 3
_this$1$ = -3404					; size = 4
_pConstants$6 = -3400					; size = 4
_Includer$7 = -3396					; size = 4
$T8 = -3392						; size = 24
_sh_name$ = -3368					; size = 260
_file$9 = -3104						; size = 520
_temp_file_name$ = -3104				; size = 520
_file_name$ = -2584					; size = 520
_folder$ = -2064					; size = 520
_defines$ = -1544					; size = 1024
_folder_name$ = -520					; size = 520
_name$ = 8						; size = 4
_pSrcData$ = 12						; size = 4
_SrcDataLen$ = 16					; size = 4
_pFunctionName$ = 20					; size = 4
_pTarget$ = 24						; size = 4
_Flags$ = 28						; size = 4
_result$ = 32						; size = 4
?shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z PROC	; CRender::shader_compile
; _this$ = ecx

; 700  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 3428				; 00000d64H
	push	ebx
	push	esi
	push	edi

; 701  : 	D3DXMACRO defines[128]{};

	push	1024					; 00000400H
	lea	eax, DWORD PTR _defines$[esp+3444]
	mov	ebx, ecx
	push	0
	push	eax
	mov	DWORD PTR _this$1$[esp+3452], ebx
	call	_memset
	add	esp, 12					; 0000000cH

; 702  : 	int def_it = 0;
; 703  : 
; 704  : 	char sh_name[MAX_PATH] = "";

	lea	eax, DWORD PTR _sh_name$[esp+3441]
	push	259					; 00000103H
	push	0
	push	eax
	call	_memset

; 705  : 	size_t len = 0;
; 706  : 
; 707  : 	// options
; 708  : 	if (o.forceskinw) {

	mov	eax, DWORD PTR [ebx+628]
	add	esp, 12					; 0000000cH
	shr	eax, 3
	mov	ecx, eax
	and	ecx, 1
	je	SHORT $LN8@shader_com

; 709  : 		defines[def_it].Name = "SKIN_COLOR";

	mov	DWORD PTR _defines$[esp+3440], OFFSET ??_C@_0L@PJCDFAEI@SKIN_COLOR@

; 710  : 		defines[def_it].Definition = "1";

	mov	DWORD PTR _defines$[esp+3444], OFFSET ??_C@_01HIHLOKLC@1@
$LN8@shader_com:

; 711  : 		def_it++;
; 712  : 	}
; 713  : 	sh_name[len] = '0' + char(o.forceskinw); ++len;
; 714  : 
; 715  : 	if (m_skinning < 0) {

	mov	edx, DWORD PTR [ebx+4]
	and	al, 1
	add	al, 48					; 00000030H
	mov	BYTE PTR _sh_name$[esp+3440], al
	test	edx, edx
	jns	SHORT $LN9@shader_com

; 716  : 		defines[def_it].Name = "SKIN_NONE";

	mov	DWORD PTR _defines$[esp+ecx*8+3440], OFFSET ??_C@_09BOBBOPBB@SKIN_NONE@

; 717  : 		defines[def_it].Definition = "1";
; 718  : 		def_it++;
; 719  : 		sh_name[len] = '1'; ++len;

	mov	WORD PTR _sh_name$[esp+3441], 12337	; 00003031H
	mov	BYTE PTR _sh_name$[esp+3443], 48	; 00000030H

; 720  : 	}

	jmp	$LN129@shader_com
$LN9@shader_com:

; 721  : 	else
; 722  : 	{
; 723  : 		sh_name[len] = '0'; ++len;
; 724  : 	}
; 725  : 
; 726  : 	if (0 == m_skinning) {

	mov	BYTE PTR _sh_name$[esp+3441], 48	; 00000030H
	test	edx, edx
	jne	SHORT $LN130@shader_com

; 727  : 		defines[def_it].Name = "SKIN_0";

	mov	DWORD PTR _defines$[esp+ecx*8+3440], OFFSET ??_C@_06IDLPGDEM@SKIN_0@

; 728  : 		defines[def_it].Definition = "1";

	mov	DWORD PTR _defines$[esp+ecx*8+3444], OFFSET ??_C@_01HIHLOKLC@1@

; 729  : 		def_it++;

	inc	ecx
	test	edx, edx
	sete	al
	add	al, 48					; 00000030H
	cmp	edx, 1
	mov	BYTE PTR _sh_name$[esp+3442], al
	sete	al
	add	al, 48					; 00000030H
	mov	BYTE PTR _sh_name$[esp+3443], al
	jmp	SHORT $LN13@shader_com
$LN130@shader_com:

; 730  : 	}
; 731  : 	sh_name[len] = '0' + char(0 == m_skinning); ++len;

	sete	al
	add	al, 48					; 00000030H
	mov	BYTE PTR _sh_name$[esp+3442], al

; 732  : 
; 733  : 	if (1 == m_skinning) {

	cmp	edx, 1
	jne	SHORT $LN12@shader_com

; 734  : 		defines[def_it].Name = "SKIN_1";

	mov	DWORD PTR _defines$[esp+ecx*8+3440], OFFSET ??_C@_06JKKEFCAN@SKIN_1@

; 735  : 		defines[def_it].Definition = "1";

	mov	DWORD PTR _defines$[esp+ecx*8+3444], OFFSET ??_C@_01HIHLOKLC@1@

; 736  : 		def_it++;

	inc	ecx
	cmp	edx, edx
	sete	al
	add	al, 48					; 00000030H
	mov	BYTE PTR _sh_name$[esp+3443], al
	jmp	SHORT $LN13@shader_com
$LN12@shader_com:

; 737  : 	}
; 738  : 	sh_name[len] = '0' + char(1 == m_skinning); ++len;

	sete	al
	add	al, 48					; 00000030H
	mov	BYTE PTR _sh_name$[esp+3443], al

; 739  : 
; 740  : 	if (2 == m_skinning) {

	cmp	edx, 2
	jne	SHORT $LN131@shader_com

; 741  : 		defines[def_it].Name = "SKIN_2";

	mov	DWORD PTR _defines$[esp+ecx*8+3440], OFFSET ??_C@_06LBIJABMO@SKIN_2@
$LN129@shader_com:

; 742  : 		defines[def_it].Definition = "1";
; 743  : 		def_it++;
; 744  : 	}
; 745  : 	sh_name[len] = '0' + char(2 == m_skinning); ++len;

	mov	DWORD PTR _defines$[esp+ecx*8+3444], OFFSET ??_C@_01HIHLOKLC@1@
	inc	ecx
$LN13@shader_com:
	cmp	edx, 2
$LN131@shader_com:

; 746  : 
; 747  : 	// finish
; 748  : 	defines[def_it].Name = 0;
; 749  : 	defines[def_it].Definition = 0;
; 750  : 	def_it++;
; 751  : 	R_ASSERT(def_it < 128);
; 752  : 
; 753  : 	HRESULT		_result = E_FAIL;
; 754  : 
; 755  : 	string_path	folder_name, folder;
; 756  : 	strcpy(folder, "objects\\r1\\");
; 757  : 	strcat(folder, name);

	mov	ebx, DWORD PTR _name$[ebp]
	sete	al
	add	al, 48					; 00000030H
	mov	DWORD PTR _defines$[esp+ecx*8+3440], 0
	mov	BYTE PTR _sh_name$[esp+3444], al
	mov	edx, ebx
	mov	eax, DWORD PTR ??_C@_0M@MCOCEOGP@objects?2r1?2@
	mov	esi, edx
	mov	DWORD PTR _folder$[esp+3440], eax
	mov	eax, DWORD PTR ??_C@_0M@MCOCEOGP@objects?2r1?2@+4
	mov	DWORD PTR _folder$[esp+3444], eax
	mov	eax, DWORD PTR ??_C@_0M@MCOCEOGP@objects?2r1?2@+8
	mov	DWORD PTR _defines$[esp+ecx*8+3444], 0
	mov	DWORD PTR __result$1$[esp+3440], -2147467259 ; 80004005H
	mov	DWORD PTR _folder$[esp+3448], eax
$LL110@shader_com:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL110@shader_com
	lea	edi, DWORD PTR _folder$[esp+3440]
	sub	edx, esi
	dec	edi
$LL111@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL111@shader_com
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 758  : 	strcat(folder, ".");

	lea	edi, DWORD PTR _folder$[esp+3440]
	dec	edi
$LL112@shader_com:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL112@shader_com
	mov	ax, WORD PTR ??_C@_01LFCBOECM@?4@
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 327  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

	push	2
	push	DWORD PTR _pTarget$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 758  : 	strcat(folder, ".");

	mov	WORD PTR [edi], ax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 327  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

	lea	eax, DWORD PTR _extension$[esp+3448]
	push	3
	push	eax
	call	DWORD PTR __imp__strncpy_s
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 762  : 	strcat(folder, extension);

	lea	edx, DWORD PTR _extension$[esp+3456]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h

; 327  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

	add	esp, 16					; 00000010H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 762  : 	strcat(folder, extension);

	mov	esi, edx
$LL113@shader_com:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL113@shader_com
	lea	edi, DWORD PTR _folder$[esp+3440]
	sub	edx, esi
	dec	edi
$LL114@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL114@shader_com
	mov	ecx, edx

; 763  : 
; 764  : 	FS.update_path(folder_name, "$game_shaders$", folder);

	lea	eax, DWORD PTR _folder$[esp+3440]
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	eax
	push	OFFSET ??_C@_0P@IMLOOCAI@$game_shaders$@
	lea	eax, DWORD PTR _folder_name$[esp+3448]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?update_path@CLocatorAPI@@QAEPBDAAY0CAI@DPBD1@Z

; 765  : 	strcat(folder_name, "\\");

	lea	edi, DWORD PTR _folder_name$[esp+3440]
	dec	edi
$LL115@shader_com:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL115@shader_com
	mov	ax, WORD PTR ??_C@_01KICIPPFI@?2@
	mov	WORD PTR [edi], ax

; 766  : 
; 767  : 	m_file_set.clear();

	mov	edi, DWORD PTR _this$1$[esp+3440]
	add	edi, 1104				; 00000450H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	mov	ecx, edi
	mov	esi, DWORD PTR [edi]
	push	DWORD PTR [esi+4]
	push	edi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 768  : 	FS.file_list(m_file_set, folder_name, FS_ListFiles | FS_RootOnly, "*");

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _folder_name$[esp+3440]
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	push	9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1344 :         _Head->_Parent  = _Head;

	mov	DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

	mov	DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

	mov	DWORD PTR [esi+8], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 768  : 	FS.file_list(m_file_set, folder_name, FS_ListFiles | FS_RootOnly, "*");

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1347 :         _Scary->_Mysize = 0;

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 768  : 	FS.file_list(m_file_set, folder_name, FS_ListFiles | FS_RootOnly, "*");

	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR __imp_?file_list@CLocatorAPI@@QAEHAAV?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@PBDI1@Z

; 769  : 
; 770  : 	string_path temp_file_name, file_name;
; 771  : 	if (!match_shader_id(name, sh_name, m_file_set, temp_file_name)) {

	lea	eax, DWORD PTR _temp_file_name$[esp+3440]
	mov	ecx, ebx
	push	eax
	push	edi
	lea	edx, DWORD PTR _sh_name$[esp+3448]
	call	?match_shader_id@@YA_NQBD0ABV?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@AAY0CAI@D@Z ; match_shader_id
	add	esp, 8
	test	al, al
	jne	$LN15@shader_com

; 772  : 		string_path file;
; 773  : 		strcpy(file, "shaders_cache\\r1\\");

	mov	eax, DWORD PTR ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@

; 774  : 		strcat(file, name);

	mov	esi, ebx
	mov	DWORD PTR _file$9[esp+3440], eax
	mov	eax, DWORD PTR ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@+4
	mov	DWORD PTR _file$9[esp+3444], eax
	mov	eax, DWORD PTR ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@+8
	mov	DWORD PTR _file$9[esp+3448], eax
	mov	eax, DWORD PTR ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@+12
	mov	DWORD PTR _file$9[esp+3452], eax
	mov	ax, WORD PTR ??_C@_0BC@NLGOMJHG@shaders_cache?2r1?2@+16
	mov	WORD PTR _file$9[esp+3456], ax
	npad	5
$LL116@shader_com:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL116@shader_com
	lea	edi, DWORD PTR _file$9[esp+3440]
	sub	ebx, esi
	dec	edi
$LL117@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL117@shader_com
	mov	ecx, ebx
	shr	ecx, 2
	rep movsd
	mov	ecx, ebx
	and	ecx, 3
	rep movsb

; 775  : 		strcat(file, ".");

	lea	edi, DWORD PTR _file$9[esp+3440]
	dec	edi
	npad	1
$LL118@shader_com:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL118@shader_com
	mov	ax, WORD PTR ??_C@_01LFCBOECM@?4@

; 776  : 		strcat(file, extension);

	lea	edx, DWORD PTR _extension$[esp+3440]
	mov	WORD PTR [edi], ax
	mov	esi, edx
	npad	7
$LL119@shader_com:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL119@shader_com
	lea	edi, DWORD PTR _file$9[esp+3440]
	sub	edx, esi
	dec	edi
$LL120@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL120@shader_com
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 777  : 		strcat(file, "\\");

	lea	edi, DWORD PTR _file$9[esp+3440]
	dec	edi
	npad	1
$LL121@shader_com:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL121@shader_com
	mov	ax, WORD PTR ??_C@_01KICIPPFI@?2@

; 778  : 		strcat(file, sh_name);

	lea	edx, DWORD PTR _sh_name$[esp+3440]
	mov	WORD PTR [edi], ax
	mov	esi, edx
	npad	7
$LL122@shader_com:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL122@shader_com
	lea	edi, DWORD PTR _file$9[esp+3440]
	sub	edx, esi
	dec	edi
$LL123@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL123@shader_com
	mov	ecx, edx

; 779  : 		FS.update_path(file_name, "$app_data_root$", file);

	lea	eax, DWORD PTR _file$9[esp+3440]
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	push	eax
	push	OFFSET ??_C@_0BA@BDJNLMJI@$app_data_root$@
	lea	eax, DWORD PTR _file_name$[esp+3448]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR __imp_?update_path@CLocatorAPI@@QAEPBDAAY0CAI@DPBD1@Z

; 780  : 	}

	jmp	SHORT $LN16@shader_com
$LN15@shader_com:

; 781  : 	else {
; 782  : 		strcpy(file_name, folder_name);

	xor	ecx, ecx
	npad	2
$LL28@shader_com:
	mov	al, BYTE PTR _folder_name$[esp+ecx+3440]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR _file_name$[esp+ecx+3439], al
	test	al, al
	jne	SHORT $LL28@shader_com

; 783  : 		strcat(file_name, temp_file_name);

	lea	edx, DWORD PTR _temp_file_name$[esp+3440]
	mov	esi, edx
	npad	2
$LL124@shader_com:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL124@shader_com
	lea	edi, DWORD PTR _file_name$[esp+3440]
	sub	edx, esi
	dec	edi
$LL125@shader_com:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL125@shader_com
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
$LN16@shader_com:

; 784  : 	}
; 785  : 
; 786  : 	if (FS.exist(file_name))

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _file_name$[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?exist@CLocatorAPI@@QAEPBUfile@1@PBD@Z
	test	eax, eax
	je	$LN109@shader_com

; 787  : 	{
; 788  : 		IReader* file = FS.r_open(file_name);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _file_name$[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?r_open@CLocatorAPI@@QAEPAVIReader@@PBD@Z
	mov	ebx, eax

; 789  : 		if (file->length() > 4)

	cmp	DWORD PTR [ebx+12], 4
	jle	$LN19@shader_com

; 790  : 		{
; 791  : 			u32 crc = 0;
; 792  : 			crc = file->r_u32();

	mov	ecx, ebx
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 793  : 
; 794  : 			boost::crc_32_type		processor;

	push	ecx
	lea	ecx, DWORD PTR _processor$4[esp+3444]
	mov	DWORD PTR _crc$1$[esp+3444], eax
	call	??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::crc_optimal<32,79764919,4294967295,4294967295,1,1>
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	edi, DWORD PTR [ebx+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	edx, ecx
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	eax, DWORD PTR _processor$4[esp+3440]
	sub	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 795  : 			processor.process_block(file->pointer(), ((char*)file->pointer()) + file->elapsed());

	add	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\FS.h

; 264  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	DWORD PTR tv703[esp+3440], edx
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	esi, edx
	cmp	esi, edi
	jae	SHORT $LN43@shader_com
	npad	6
$LL44@shader_com:

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	movzx	edx, BYTE PTR [esi]

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	inc	esi

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	movzx	ecx, al
	xor	edx, ecx

; 542  :             { return rem >> CHAR_BIT; }

	shr	eax, 8

; 922  :         rem_ ^= crc_table_type::table_[ byte_index ];

	xor	eax, DWORD PTR ?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA[edx*4]
	cmp	esi, edi
	jb	SHORT $LL44@shader_com

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	edx, DWORD PTR tv703[esp+3440]
$LN43@shader_com:

; 951  :     return ( reflect_out_type::reflect(rem_) ^ get_final_xor_value() )

	not	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 798  : 			if (real_crc == crc) {

	cmp	eax, DWORD PTR _crc$1$[esp+3440]
	jne	SHORT $LN19@shader_com

; 799  : 				_result = create_shader(pTarget, (DWORD*)file->pointer(), static_cast<u32>(file->elapsed()), file_name, result, o.disasm);

	mov	eax, DWORD PTR _this$1$[esp+3440]
	mov	eax, DWORD PTR [eax+628]
	shr	eax, 2
	and	al, 1
	movzx	eax, al
	push	eax
	push	DWORD PTR _result$[ebp]
	lea	eax, DWORD PTR _file_name$[esp+3448]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?create_shader@@YAJQBDPBKI0AAPAX_N@Z	; create_shader
	add	esp, 16					; 00000010H
	mov	DWORD PTR __result$1$[esp+3440], eax
$LN19@shader_com:

; 800  : 			}
; 801  : 		}
; 802  : 		file->close();

	mov	ecx, ebx
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 803  : 	}
; 804  : 
; 805  : 	if (FAILED(_result))

	mov	edi, DWORD PTR __result$1$[esp+3440]
	test	edi, edi
	jns	$LN26@shader_com
$LN109@shader_com:

; 806  : 	{
; 807  : 		includer Includer;
; 808  : 		LPD3DXBUFFER pShaderBuf = NULL;
; 809  : 		LPD3DXBUFFER pErrorBuf = NULL;
; 810  : 		LPD3DXCONSTANTTABLE pConstants = NULL;
; 811  : 		LPD3DXINCLUDE pInclude = (LPD3DXINCLUDE)&Includer;
; 812  : 
; 813  : 		_result = D3DXCompileShader((LPCSTR)pSrcData, SrcDataLen, defines, pInclude, pFunctionName, pTarget, Flags | D3DXSHADER_USE_LEGACY_D3DX9_31_DLL, &pShaderBuf, &pErrorBuf, &pConstants);

	mov	ebx, DWORD PTR _pTarget$[ebp]
	lea	eax, DWORD PTR _pConstants$6[esp+3440]
	push	eax
	lea	eax, DWORD PTR _pErrorBuf$3[esp+3444]
	mov	DWORD PTR _Includer$7[esp+3444], OFFSET ??_7includer@@6B@
	push	eax
	lea	eax, DWORD PTR _pShaderBuf$1[esp+3448]
	mov	DWORD PTR _pShaderBuf$1[esp+3448], 0
	push	eax
	mov	eax, DWORD PTR _Flags$[ebp]
	or	eax, 65536				; 00010000H
	mov	DWORD PTR _pErrorBuf$3[esp+3452], 0
	push	eax
	push	ebx
	push	DWORD PTR _pFunctionName$[ebp]
	lea	eax, DWORD PTR _Includer$7[esp+3464]
	mov	DWORD PTR _pConstants$6[esp+3464], 0
	push	eax
	lea	eax, DWORD PTR _defines$[esp+3468]
	push	eax
	push	DWORD PTR _SrcDataLen$[ebp]
	push	DWORD PTR _pSrcData$[ebp]
	call	DWORD PTR __imp__D3DXCompileShader@40
	mov	DWORD PTR __result$1$[esp+3440], eax

; 814  : 		if (SUCCEEDED(_result)) {

	test	eax, eax
	js	$LN21@shader_com

; 815  : 			IWriter* file = FS.w_open(file_name);

	mov	eax, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\LocatorAPI.h

; 122  : 	IC IWriter*					w_open			(LPCSTR N){return w_open(0,N);}

	lea	ecx, DWORD PTR _file_name$[esp+3440]
	push	ecx
	push	0
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?w_open@CLocatorAPI@@QAEPAVIWriter@@PBD0@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 817  : 			boost::crc_32_type processor;

	push	ecx
	lea	ecx, DWORD PTR _processor$5[esp+3444]
	mov	DWORD PTR _file$2[esp+3444], eax
	call	??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::crc_optimal<32,79764919,4294967295,4294967295,1,1>

; 818  : 			processor.process_block(pShaderBuf->GetBufferPointer(), ((char*)pShaderBuf->GetBufferPointer()) + pShaderBuf->GetBufferSize());

	mov	eax, DWORD PTR _pShaderBuf$1[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _pShaderBuf$1[esp+3440]
	mov	edi, eax
	push	ecx
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _pShaderBuf$1[esp+3440]
	add	edi, eax
	push	ecx
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+12]
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	ecx, DWORD PTR _processor$5[esp+3440]
	cmp	eax, edi
	jae	SHORT $LN62@shader_com
$LL63@shader_com:

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	movzx	esi, BYTE PTR [eax]

; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	inc	eax

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	movzx	edx, cl
	xor	esi, edx

; 542  :             { return rem >> CHAR_BIT; }

	shr	ecx, 8

; 922  :         rem_ ^= crc_table_type::table_[ byte_index ];

	xor	ecx, DWORD PTR ?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA[esi*4]
	cmp	eax, edi
	jb	SHORT $LL63@shader_com
$LN62@shader_com:

; 951  :     return ( reflect_out_type::reflect(rem_) ^ get_final_xor_value() )

	not	ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 821  : 			file->w_u32(crc);

	push	ecx
	mov	ecx, DWORD PTR _file$2[esp+3444]
	call	DWORD PTR __imp_?w_u32@IWriter@@QAEXI@Z

; 822  : 			file->w(pShaderBuf->GetBufferPointer(), (u32)pShaderBuf->GetBufferSize());

	mov	eax, DWORD PTR _file$2[esp+3440]
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _pShaderBuf$1[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	eax
	mov	eax, DWORD PTR _pShaderBuf$1[esp+3444]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _file$2[esp+3444]
	push	eax
	call	DWORD PTR [esi+12]

; 823  : 			FS.w_close(file);

	mov	ecx, DWORD PTR __imp_?xr_FS@@3PAVCLocatorAPI@@A
	lea	eax, DWORD PTR _file$2[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?w_close@CLocatorAPI@@QAEXAAPAVIWriter@@@Z

; 824  : 
; 825  : 			_result = create_shader(pTarget, (DWORD*)pShaderBuf->GetBufferPointer(), pShaderBuf->GetBufferSize(), file_name, result, o.disasm);

	mov	eax, DWORD PTR _pShaderBuf$1[esp+3440]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _this$1$[esp+3440]
	mov	eax, DWORD PTR [ecx+628]
	shr	eax, 2
	and	al, 1
	movzx	eax, al
	push	eax
	push	DWORD PTR _result$[ebp]
	lea	eax, DWORD PTR _file_name$[esp+3448]
	push	eax
	mov	eax, DWORD PTR _pShaderBuf$1[esp+3452]
	push	ecx
	push	eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+12]
	mov	edx, eax
	mov	ecx, ebx
	call	?create_shader@@YAJQBDPBKI0AAPAX_N@Z	; create_shader
	add	esp, 16					; 00000010H
	mov	edi, eax

; 826  : 
; 827  : 			if (pErrorBuf)

	cmp	DWORD PTR _pErrorBuf$3[esp+3440], 0
	je	$LN26@shader_com

; 828  : 			{
; 829  : 				Log("! ", file_name);

	mov	esi, DWORD PTR __imp_?Log@@YAXPBD0@Z
	lea	eax, DWORD PTR _file_name$[esp+3440]
	push	eax
	push	OFFSET ??_C@_02KMLFCOJI@?$CB?5@
	call	esi

; 830  : 				Log("! Warning: ", (LPCSTR)pErrorBuf->GetBufferPointer());

	mov	eax, DWORD PTR _pErrorBuf$3[esp+3448]
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+12]
	push	eax
	push	OFFSET ??_C@_0M@LHHOJELD@?$CB?5Warning?3?5@
	call	esi

; 841  : 		}
; 842  : 	}
; 843  : 
; 844  : 	return _result;

	add	esp, 8
	mov	eax, edi

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN21@shader_com:

; 831  : 			}
; 832  : 		}
; 833  : 		else
; 834  : 		{
; 835  : 			Log("! ", file_name);

	mov	esi, DWORD PTR __imp_?Log@@YAXPBD0@Z
	lea	eax, DWORD PTR _file_name$[esp+3440]
	push	eax
	push	OFFSET ??_C@_02KMLFCOJI@?$CB?5@
	call	esi
	add	esp, 8

; 836  : 			R_ASSERT2(SUCCEEDED(_result), make_string("! Can't compile shader: %s, %s", file_name, (LPCSTR)pErrorBuf->GetBufferPointer()));

	cmp	BYTE PTR ?ignore_always@?DC@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA, 0
	jne	$LN5@shader_com
	mov	eax, DWORD PTR _pErrorBuf$3[esp+3440]
	push	OFFSET ?ignore_always@?DC@??shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z@4_NA
	push	OFFSET ??_C@_0BI@NLEBJGLM@CRender?3?3shader_compile@
	push	836					; 00000344H
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	eax
	call	DWORD PTR [ecx+12]
	push	eax
	lea	eax, DWORD PTR _file_name$[esp+3460]
	push	eax
	lea	eax, DWORD PTR $T8[esp+3464]
	push	OFFSET ??_C@_0BP@OMCFLODH@?$CB?5Can?8t?5compile?5shader?3?5?$CFs?0?5?$CFs@
	push	eax
	call	?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; make_string
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0BD@DCAGGEAG@SUCCEEDED?$CI_result?$CJ@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H0AA_N@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T8[esp+3460]
	cmp	edx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN5@shader_com
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T8[esp+3440]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN92@shader_com

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN92@shader_com
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN92@shader_com:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN5@shader_com:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 837  : 			if (pErrorBuf)

	mov	ecx, DWORD PTR _pErrorBuf$3[esp+3440]
	test	ecx, ecx
	je	SHORT $LN25@shader_com

; 838  : 				Log("! Error: ", (LPCSTR)pErrorBuf->GetBufferPointer());

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+12]
	push	eax
	push	OFFSET ??_C@_09EFHBAOK@?$CB?5Error?3?5@
	call	esi
	mov	edi, DWORD PTR __result$1$[esp+3448]

; 841  : 		}
; 842  : 	}
; 843  : 
; 844  : 	return _result;

	add	esp, 8
	mov	eax, edi

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN25@shader_com:

; 839  : 			else
; 840  : 				Msg("Can't compile shader hr=0x%08x", _result);

	mov	edi, DWORD PTR __result$1$[esp+3440]
	push	edi
	push	OFFSET ??_C@_0BP@CEIAODPN@Can?8t?5compile?5shader?5hr?$DN0x?$CF08x@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ

; 841  : 		}
; 842  : 	}
; 843  : 
; 844  : 	return _result;

	add	esp, 8
$LN26@shader_com:
	mov	eax, edi

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN128@shader_com:
?shader_compile@CRender@@UAEJPBDPBKI00KAAPAX@Z ENDP	; CRender::shader_compile
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0includer@@QAE@XZ
_TEXT	SEGMENT
??0includer@@QAE@XZ PROC				; includer::includer, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7includer@@6B@
	mov	eax, ecx
	ret	0
??0includer@@QAE@XZ ENDP				; includer::includer
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ID3DXInclude@@QAE@XZ
_TEXT	SEGMENT
??0ID3DXInclude@@QAE@XZ PROC				; ID3DXInclude::ID3DXInclude, COMDAT
; _this$ = ecx
	mov	eax, ecx
	ret	0
??0ID3DXInclude@@QAE@XZ ENDP				; ID3DXInclude::ID3DXInclude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 24
_mask$ = 8						; size = 4
_mask_length$ = 12					; size = 4
?match_shader@@YA_NQBD00I@Z PROC			; match_shader
; _debug_shader_id$ = ecx
; _full_shader_id$ = edx

; 848  : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	esi, edx
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 174  : {	return (u32)strlen(S);			}

	mov	edi, esi
	lea	edx, DWORD PTR [edi+1]
	npad	3
$LL47@match_shad:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL47@match_shad
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 850  : 	R_ASSERT2(

	mov	ebx, DWORD PTR _mask$[esp+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 174  : {	return (u32)strlen(S);			}

	sub	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 850  : 	R_ASSERT2(

	cmp	BYTE PTR ?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA, al
	jne	SHORT $LN2@match_shad
	cmp	edi, DWORD PTR _mask_length$[esp+40]
	je	SHORT $LN2@match_shad
	push	OFFSET ?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA
	push	OFFSET ??_C@_0N@GPBBBEHJ@match_shader@
	push	858					; 0000035aH
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	esi
	push	ebx
	push	ecx
	lea	eax, DWORD PTR $T1[esp+72]
	push	OFFSET ??_C@_0CE@HAHBDCPG@bad?5cache?5for?5shader?5?$CFs?0?5?$FL?$CFs?$FN?0?5@
	push	eax
	call	?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; make_string
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CF@MFPDANGH@full_shader_id_length?5?$DN?$DN?5mask_l@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H0AA_N@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+64]
	cmp	edx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN2@match_shad
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+44]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN35@match_shad

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN35@match_shad
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN35@match_shad:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@match_shad:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 860  : 	char const* const e = full_shader_id + full_shader_id_length;

	lea	ecx, DWORD PTR [edi+esi]

; 861  : 	char const* j = mask;
; 862  : 	for (; i != e; ++i, ++j) {

	cmp	esi, ecx
	je	SHORT $LN46@match_shad

; 851  : 		full_shader_id_length == mask_length,
; 852  : 		make_string(
; 853  : 			"bad cache for shader %s, [%s], [%s]",
; 854  : 			debug_shader_id,
; 855  : 			mask,
; 856  : 			full_shader_id
; 857  : 		)
; 858  : 	);
; 859  : 	char const* i = full_shader_id;

	sub	ebx, esi
$LL7@match_shad:

; 863  : 		if (*i == *j)

	mov	al, BYTE PTR [ebx+esi]
	cmp	BYTE PTR [esi], al
	je	SHORT $LN5@match_shad

; 864  : 			continue;
; 865  : 
; 866  : 		if (*j == '_')

	cmp	al, 95					; 0000005fH
	jne	SHORT $LN10@match_shad
$LN5@match_shad:

; 861  : 	char const* j = mask;
; 862  : 	for (; i != e; ++i, ++j) {

	inc	esi
	cmp	esi, ecx
	jne	SHORT $LL7@match_shad
$LN46@match_shad:

; 867  : 			continue;
; 868  : 
; 869  : 		return false;
; 870  : 	}
; 871  : 
; 872  : 	return true;

	mov	al, 1

; 873  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN10@match_shad:
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN48@match_shad:
?match_shader@@YA_NQBD00I@Z ENDP			; match_shader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp
_TEXT	SEGMENT
_full_shader_id$1$ = -36				; size = 4
_debug_shader_id$1$ = -32				; size = 4
$T1 = -28						; size = 24
_file_set$ = 8						; size = 4
_result$ = 12						; size = 4
?match_shader_id@@YA_NQBD0ABV?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@AAY0CAI@D@Z PROC ; match_shader_id
; _debug_shader_id$ = ecx
; _full_shader_id$ = edx

; 876  : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1140 :         return const_iterator(_Scary->_Myhead->_Left, _Scary);

	mov	edi, DWORD PTR _file_set$[esp+48]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 876  : {

	mov	DWORD PTR _full_shader_id$1$[esp+52], edx
	mov	DWORD PTR _debug_shader_id$1$[esp+52], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1140 :         return const_iterator(_Scary->_Myhead->_Left, _Scary);

	mov	edi, DWORD PTR [edi]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	esi, DWORD PTR [edi]

; 233  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 895  : 	for (; i != e; ++i) {

	je	$LN3@match_shad
	npad	1
$LL26@match_shad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+56], 16			; 00000010H

; 3888 :         return _Mypair._Myval2._Myptr();

	lea	ebp, DWORD PTR [esi+36]

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN122@match_shad

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	ebp, DWORD PTR [ebp]
$LN122@match_shad:
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 174  : {	return (u32)strlen(S);			}

	mov	ebx, edx
	lea	ecx, DWORD PTR [ebx+1]
$LL125@match_shad:
	mov	al, BYTE PTR [ebx]
	inc	ebx
	test	al, al
	jne	SHORT $LL125@match_shad
	sub	ebx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 850  : 	R_ASSERT2(

	cmp	BYTE PTR ?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA, al
	jne	SHORT $LN48@match_shad
	cmp	ebx, DWORD PTR [esi+52]
	je	SHORT $LN48@match_shad
	push	OFFSET ?ignore_always@?3??match_shader@@YA_NQBD00I@Z@4_NA
	push	OFFSET ??_C@_0N@GPBBBEHJ@match_shader@
	push	858					; 0000035aH
	push	OFFSET ??_C@_0EC@GAKMNDAB@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	edx
	push	ebp
	push	DWORD PTR _debug_shader_id$1$[esp+76]
	lea	eax, DWORD PTR $T1[esp+80]
	push	OFFSET ??_C@_0CE@HAHBDCPG@bad?5cache?5for?5shader?5?$CFs?0?5?$FL?$CFs?$FN?0?5@
	push	eax
	call	?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; make_string
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CF@MFPDANGH@full_shader_id_length?5?$DN?$DN?5mask_l@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0H0AA_N@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+72]
	cmp	edx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN48@match_shad
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+52]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN81@match_shad

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN78@match_shad
$LN81@match_shad:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN48@match_shad:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 859  : 	char const* i = full_shader_id;

	mov	ecx, DWORD PTR _full_shader_id$1$[esp+52]
	mov	eax, ecx

; 860  : 	char const* const e = full_shader_id + full_shader_id_length;

	lea	edx, DWORD PTR [ebx+ecx]

; 861  : 	char const* j = mask;
; 862  : 	for (; i != e; ++i, ++j) {

	cmp	ecx, edx
	je	SHORT $LN102@match_shad

; 859  : 	char const* i = full_shader_id;

	sub	ebp, ecx
	npad	6
$LL53@match_shad:

; 863  : 		if (*i == *j)

	mov	cl, BYTE PTR [eax+ebp]
	cmp	BYTE PTR [eax], cl
	je	SHORT $LN51@match_shad

; 864  : 			continue;
; 865  : 
; 866  : 		if (*j == '_')

	cmp	cl, 95					; 0000005fH
	jne	SHORT $LN56@match_shad
$LN51@match_shad:

; 861  : 	char const* j = mask;
; 862  : 	for (; i != e; ++i, ++j) {

	inc	eax
	cmp	eax, edx
	jne	SHORT $LL53@match_shad
$LN102@match_shad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3888 :         return _Mypair._Myval2._Myptr();

	add	esi, 36					; 00000024H

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN93@match_shad

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

	mov	esi, DWORD PTR [esi]
$LN93@match_shad:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 897  : 			strcpy(result, (*i).name.c_str());

	mov	ecx, DWORD PTR _result$[esp+48]
	sub	ecx, esi
$LL7@match_shad:
	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	test	al, al
	jne	SHORT $LL7@match_shad

; 898  : 			return				true;

	mov	al, 1

; 904  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN56@match_shad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN25@match_shad

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN24@match_shad
	npad	5
$LL23@match_shad:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN24@match_shad

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL23@match_shad
$LN24@match_shad:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	esi, eax

; 58   :         } else {

	jmp	SHORT $LN106@match_shad
$LN25@match_shad:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	esi, eax

; 451  :         while (!_Pnode->_Left->_Isnil) {

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN106@match_shad
	npad	2
$LL29@match_shad:
	mov	eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

	mov	esi, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL29@match_shad
$LN106@match_shad:

; 233  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 895  : 	for (; i != e; ++i) {

	je	SHORT $LN3@match_shad
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edx, DWORD PTR _full_shader_id$1$[esp+52]
	jmp	$LL26@match_shad
$LN78@match_shad:

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN3@match_shad:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.cpp

; 904  : }

	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN130@match_shad:
?match_shader_id@@YA_NQBD0ABV?$xr_set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@@AAY0CAI@D@Z ENDP ; match_shader_id
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator!=, COMDAT
; _this$ = ecx

; 238  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 239  :     }

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator++, COMDAT
; _this$ = ecx

; 193  :     _Tree_const_iterator& operator++() noexcept {

	push	esi
	mov	esi, ecx
	push	edi

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+8]
	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN6@operator

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN21@operator
$LL4@operator:
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN21@operator

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	DWORD PTR [esi], eax
	mov	edx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@operator
$LN21@operator:

; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;

	mov	DWORD PTR [esi], eax

; 201  :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
$LN6@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN11@operator
	npad	7
$LL10@operator:
	mov	eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

	mov	edi, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL10@operator
$LN11@operator:

; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;

	mov	DWORD PTR [esi], edi

; 201  :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBEABUFS_File@@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBEABUFS_File@@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator*, COMDAT
; _this$ = ecx

; 180  : #if _ITERATOR_DEBUG_LEVEL == 2
; 181  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 182  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 183  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 184  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 185  : 
; 186  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 187  :     }

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBEABUFS_File@@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??1?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@XZ
_TEXT	SEGMENT
??1?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@XZ PROC ; resptr_core<IRender_Glow,resptrcode_glow>::~resptr_core<IRender_Glow,resptrcode_glow>, COMDAT
; _this$ = ecx

; 64   : 						~resptr_core	()												{	_dec();						}

	jmp	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
??1?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@XZ ENDP ; resptr_core<IRender_Glow,resptrcode_glow>::~resptr_core<IRender_Glow,resptrcode_glow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@PAVIRender_Glow@@_N@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_add_ref$dead$ = 12					; size = 1
??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@PAVIRender_Glow@@_N@Z PROC ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>, COMDAT
; _this$ = ecx

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@resptr_cor
	inc	DWORD PTR [eax+4]
$LN7@resptr_cor:

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, ecx
	ret	8
??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@PAVIRender_Glow@@_N@Z ENDP ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?begin@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEPAU_D3DVERTEXELEMENT9@@XZ
_TEXT	SEGMENT
?begin@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEPAU_D3DVERTEXELEMENT9@@XZ PROC ; svector<_D3DVERTEXELEMENT9,65>::begin, COMDAT
; _this$ = ecx

; 26   : 	IC iterator	begin()						{ return array;							}

	mov	eax, ecx
	ret	0
?begin@?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAEPAU_D3DVERTEXELEMENT9@@XZ ENDP ; svector<_D3DVERTEXELEMENT9,65>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEAAPAUIDirect3DIndexBuffer9@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEAAPAUIDirect3DIndexBuffer9@@I@Z PROC ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAEAAPAUIDirect3DIndexBuffer9@@I@Z ENDP ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ PROC ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@@QAE@XZ ENDP ; xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::xr_vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::~vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEAAPAUIDirect3DVertexBuffer9@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEAAPAUIDirect3DVertexBuffer9@@I@Z PROC ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAEAAPAUIDirect3DVertexBuffer9@@I@Z ENDP ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ PROC ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@@QAE@XZ ENDP ; xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::xr_vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::~vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z PROC ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Pos$[esp-4], 524
	add	eax, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ENDP ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ PROC ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@@QAE@XZ ENDP ; xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::xr_vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::~vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z PROC ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ENDP ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::xr_vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::~vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEAAUFSlideWindowItem@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEAAUFSlideWindowItem@@I@Z PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAEAAUFSlideWindowItem@@I@Z ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ PROC ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@@QAE@XZ ENDP ; xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::xr_vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~vector<FSlideWindowItem,xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::~vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ PROC ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >::xr_vector<IRender_Portal *,xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::~vector<IRender_Portal *,xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::~vector<IRender_Portal *,xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@2@XZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Remove@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?Remove@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@@Z PROC ; CRegistrator<pureFrame>::Remove, COMDAT
; _this$ = ecx

; 62   : 	{

	push	esi
	mov	esi, ecx
	push	edi

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	sub	edx, eax
	sar	edx, 2
	imul	ecx, edx, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	test	ecx, ecx
	je	SHORT $LN3@Remove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	ebx
	mov	ebx, DWORD PTR _obj$[esp+8]
	xor	edx, edx
$LL4@Remove:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 64   : 			if (R[i].Object == obj) R[i].Prio = REG_PRIORITY_INVALID;

	cmp	DWORD PTR [edx+eax], ebx
	lea	ecx, DWORD PTR [edx+eax]
	jne	SHORT $LN2@Remove
	mov	DWORD PTR [ecx+4], -1
	mov	eax, DWORD PTR [esi]
$LN2@Remove:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	inc	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	add	edx, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 2
	imul	ecx, ecx, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 63   : 		for (u32 i = 0; i < R.size(); i++) {

	cmp	edi, ecx
	jb	SHORT $LL4@Remove
	pop	ebx
$LN3@Remove:

; 65   : 		}
; 66   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN6@Remove
	or	eax, 2
	pop	edi
	mov	DWORD PTR [esi+12], eax

; 68   : 	};

	pop	esi
	ret	4
$LN6@Remove:

; 67   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ ; CRegistrator<pureFrame>::Resort
	pop	edi

; 68   : 	};

	pop	esi
	ret	4
?Remove@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@@Z ENDP ; CRegistrator<pureFrame>::Remove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Add@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@HI@Z
_TEXT	SEGMENT
_I$ = -12						; size = 12
_obj$ = 8						; size = 4
_priority$dead$ = 12					; size = 4
_flags$dead$ = 16					; size = 4
?Add@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@HI@Z PROC ; CRegistrator<pureFrame>::Add, COMDAT
; _this$ = ecx

; 46   : 	{

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 47   : #ifdef DEBUG
; 48   : 		VERIFY(priority != REG_PRIORITY_INVALID);
; 49   : 		VERIFY(obj);
; 50   : 		for (u32 i = 0; i < R.size(); i++) VERIFY(!((R[i].Prio != REG_PRIORITY_INVALID) && (R[i].Object == (void*)obj)));
; 51   : #endif
; 52   : 		_REG_INFO			I;
; 53   : 		I.Object = obj;
; 54   : 		I.Prio = priority;

	mov	DWORD PTR _I$[esp+20], 1164413355	; 456789abH
	mov	ecx, DWORD PTR _obj$[esp+12]
	mov	DWORD PTR _I$[esp+16], ecx

; 55   : 		I.Flags = flags;

	mov	DWORD PTR _I$[esp+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN8@Add
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 1164413355		; 456789abH
	mov	DWORD PTR [eax+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 12			; 0000000cH

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN7@Add
$LN8@Add:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _I$[esp+16]
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
$LN7@Add:
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 58   : 		if (in_process)		changed = true;

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN2@Add
	or	eax, 2
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 60   : 	};

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN2@Add:

; 59   : 		else Resort();

	mov	ecx, esi
	call	?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ ; CRegistrator<pureFrame>::Resort
	pop	esi

; 60   : 	};

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?Add@?$CRegistrator@VpureFrame@@@@QAEXPAVpureFrame@@HI@Z ENDP ; CRegistrator<pureFrame>::Add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
;	COMDAT ?xform@?$_box3@M@@QAEAAV1@ABU?$_matrix@M@@@Z
_TEXT	SEGMENT
tv711 = -44						; size = 4
tv732 = -40						; size = 4
_vz$1 = -36						; size = 12
_vy$2 = -24						; size = 12
_vx$3 = -12						; size = 12
tv712 = 8						; size = 4
_m$ = 8							; size = 4
?xform@?$_box3@M@@QAEAAV1@ABU?$_matrix@M@@@Z PROC	; _box3<float>::xform, COMDAT
; _this$ = ecx

; 86   :     {

	sub	esp, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mov	eax, DWORD PTR _m$[esp+40]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR [ecx+12]
	movss	xmm3, DWORD PTR [ecx+8]
	subss	xmm5, xmm4

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+16]
	movaps	xmm0, xmm2
	movss	xmm7, DWORD PTR [ecx+20]
	subss	xmm7, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm0, xmm5
	movaps	xmm6, xmm5
	mulss	xmm5, DWORD PTR [eax+8]
	mulss	xmm6, DWORD PTR [eax+4]
	movss	DWORD PTR _vx$3[esp+52], xmm5
	movss	xmm5, DWORD PTR [ecx+16]
	subss	xmm5, DWORD PTR [ecx+4]
	movss	DWORD PTR _vx$3[esp+44], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$3[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR tv712[esp+40], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vx$3[esp+48], xmm6
	movss	DWORD PTR tv732[esp+44], xmm1
	movss	DWORD PTR _vy$2[esp+44], xmm1
	movaps	xmm1, xmm5
	mulss	xmm5, DWORD PTR [eax+24]
	mulss	xmm1, DWORD PTR [eax+20]
	movss	DWORD PTR _vy$2[esp+52], xmm5
	movss	xmm5, DWORD PTR [eax+32]
	mulss	xmm5, xmm7
	movss	DWORD PTR _vy$2[esp+48], xmm1
	movss	DWORD PTR _vz$1[esp+44], xmm5
	movaps	xmm5, xmm7
	mulss	xmm7, DWORD PTR [eax+40]
	mulss	xmm5, DWORD PTR [eax+36]
	movss	DWORD PTR _vz$1[esp+52], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm7, DWORD PTR [ecx+4]
	mulss	xmm7, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _vz$1[esp+48], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm7, xmm2
	addss	xmm7, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	DWORD PTR [ecx], xmm7
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [eax+4]
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [eax+20]
	addss	xmm2, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm2, xmm0
	movss	DWORD PTR [ecx+4], xmm2

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	mulss	xmm1, DWORD PTR [eax+24]
	mulss	xmm4, DWORD PTR [eax+8]
	mulss	xmm3, DWORD PTR [eax+40]
	addss	xmm1, xmm4
	addss	xmm3, DWORD PTR [eax+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+12], xmm7
	movss	DWORD PTR [ecx+16], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm1, xmm3
	movss	DWORD PTR [ecx+8], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+20], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 74   : 		if(negative(vx.x))	min.x += vx.x; else max.x += vx.x;

	je	SHORT $LN10@xform
	movss	xmm0, DWORD PTR tv712[esp+40]
	addss	xmm0, xmm7
	movss	DWORD PTR [ecx], xmm0
	jmp	SHORT $LN11@xform
$LN10@xform:
	addss	xmm7, DWORD PTR tv712[esp+40]
	movss	DWORD PTR [ecx+12], xmm7
$LN11@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$3[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 75   : 		if(negative(vx.y))	min.y += vx.y; else max.y += vx.y;

	addss	xmm6, xmm2
	je	SHORT $LN12@xform
	movss	DWORD PTR [ecx+4], xmm6
	jmp	SHORT $LN13@xform
$LN12@xform:
	movss	DWORD PTR [ecx+16], xmm6
	movaps	xmm6, xmm2
$LN13@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vx$3[esp+52], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 76   : 		if(negative(vx.z))	min.z += vx.z; else max.z += vx.z;

	movss	xmm5, DWORD PTR _vx$3[esp+52]
	addss	xmm5, xmm1
	je	SHORT $LN14@xform
	movss	DWORD PTR [ecx+8], xmm5
	jmp	SHORT $LN15@xform
$LN14@xform:
	movss	DWORD PTR [ecx+20], xmm5
	movaps	xmm5, xmm1
$LN15@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$2[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 77   : 		if(negative(vy.x))	min.x += vy.x; else max.x += vy.x;

	je	SHORT $LN16@xform
	movss	xmm0, DWORD PTR tv732[esp+44]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	jmp	SHORT $LN17@xform
$LN16@xform:
	addss	xmm7, DWORD PTR tv732[esp+44]
	movss	DWORD PTR [ecx+12], xmm7
$LN17@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$2[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 78   : 		if(negative(vy.y))	min.y += vy.y; else max.y += vy.y;

	je	SHORT $LN18@xform
	addss	xmm6, DWORD PTR _vy$2[esp+48]
	movss	DWORD PTR [ecx+4], xmm6
	jmp	SHORT $LN19@xform
$LN18@xform:
	movss	xmm0, DWORD PTR _vy$2[esp+48]
	addss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx+16], xmm0
$LN19@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vy$2[esp+52], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 79   : 		if(negative(vy.z))	min.z += vy.z; else max.z += vy.z;

	je	SHORT $LN20@xform
	addss	xmm5, DWORD PTR _vy$2[esp+52]
	movss	DWORD PTR [ecx+8], xmm5
	jmp	SHORT $LN21@xform
$LN20@xform:
	movss	xmm0, DWORD PTR _vy$2[esp+52]
	addss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [ecx+20], xmm0
$LN21@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$1[esp+44], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 80   : 		if(negative(vz.x))	min.x += vz.x; else max.x += vz.x;

	je	SHORT $LN22@xform
	movss	xmm0, DWORD PTR _vz$1[esp+44]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	jmp	SHORT $LN23@xform
$LN22@xform:
	addss	xmm7, DWORD PTR _vz$1[esp+44]
	movss	DWORD PTR [ecx+12], xmm7
$LN23@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$1[esp+48], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 81   : 		if(negative(vz.y))	min.y += vz.y; else max.y += vz.y;

	je	SHORT $LN24@xform
	addss	xmm6, DWORD PTR _vz$1[esp+48]
	movss	DWORD PTR [ecx+4], xmm6
	jmp	SHORT $LN25@xform
$LN24@xform:
	movss	xmm0, DWORD PTR _vz$1[esp+48]
	addss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx+16], xmm0
$LN25@xform:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 25   : 	IC BOOL negative(const float &f)	{ return (*((unsigned*)(&f))&fdSGN);	}

	test	DWORD PTR _vz$1[esp+52], -2147483648	; 80000000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	mov	eax, ecx
	je	SHORT $LN26@xform
	addss	xmm5, DWORD PTR _vz$1[esp+52]
	movss	DWORD PTR [ecx+8], xmm5

; 87   : 		Self b;
; 88   :         b.set(*this);
; 89   :         return xform(b,m);
; 90   :     }

	add	esp, 44					; 0000002cH
	ret	4
$LN26@xform:

; 82   : 		if(negative(vz.z))	min.z += vz.z; else max.z += vz.z;

	movss	xmm0, DWORD PTR _vz$1[esp+52]
	addss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [ecx+20], xmm0

; 87   : 		Self b;
; 88   :         b.set(*this);
; 89   :         return xform(b,m);
; 90   :     }

	add	esp, 44					; 0000002cH
	ret	4
?xform@?$_box3@M@@QAEAAV1@ABU?$_matrix@M@@@Z ENDP	; _box3<float>::xform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set
;	COMDAT ??0?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ PROC ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::set<FS_File,std::less<FS_File>,xalloc<FS_File> >, COMDAT
; _this$ = ecx

; 82   :     set() : _Mybase(key_compare()) {}

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\set

; 82   :     set() : _Mybase(key_compare()) {}

	mov	eax, esi
	pop	esi
	ret	0
??0?$set@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@@std@@QAE@XZ ENDP ; std::set<FS_File,std::less<FS_File>,xalloc<FS_File> >::set<FS_File,std::less<FS_File>,xalloc<FS_File> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::clear, COMDAT
; _this$ = ecx

; 1339 :     void clear() noexcept {

	push	esi
	push	edi
	mov	edi, ecx

; 1340 :         const auto _Scary = _Get_scary();
; 1341 :         _Scary->_Orphan_ptr(nullptr);
; 1342 :         auto _Head = _Scary->_Myhead;

	mov	esi, DWORD PTR [edi]

; 1343 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

	push	DWORD PTR [esi+4]
	push	edi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >

; 1344 :         _Head->_Parent  = _Head;

	mov	DWORD PTR [esi+4], esi

; 1345 :         _Head->_Left    = _Head;

	mov	DWORD PTR [esi], esi

; 1346 :         _Head->_Right   = _Head;

	mov	DWORD PTR [esi+8], esi

; 1347 :         _Scary->_Mysize = 0;

	mov	DWORD PTR [edi+4], 0
	pop	edi
	pop	esi

; 1348 :     }

	ret	0
?clear@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::end, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1149 :         const auto _Scary = _Get_scary();
; 1150 :         return const_iterator(_Scary->_Myhead, _Scary);
; 1151 :     }

	ret	4
?end@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::begin, COMDAT
; _this$ = ecx

; 1139 :         const auto _Scary = _Get_scary();
; 1140 :         return const_iterator(_Scary->_Myhead->_Left, _Scary);

	mov	eax, DWORD PTR [ecx]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1141 :     }

	ret	4
?begin@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::~_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >, COMDAT
; _this$ = ecx

; 1084 :     ~_Tree() noexcept {

	push	esi
	mov	esi, ecx

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	esi
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN12@Tree
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN12@Tree:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 1091 :     }

	ret	0
??1?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::~_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEAAUFSlideWindowItem@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEAAUFSlideWindowItem@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEAAUFSlideWindowItem@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	edx, DWORD PTR __Off$[esp-4], 524
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEAAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DVertexBuffer9@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DVertexBuffer9@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DVertexBuffer9@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DIndexBuffer9@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DIndexBuffer9@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEAAPAUIDirect3DIndexBuffer9@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator==, COMDAT
; _this$ = ecx

; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 234  :     }

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 50   :     _Tree_unchecked_const_iterator& operator++() noexcept {

	push	esi
	mov	esi, ecx
	push	edi

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+8]
	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN4@operator

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
$LL2@operator:
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN19@operator

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	DWORD PTR [esi], eax
	mov	edx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN19@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	DWORD PTR [esi], eax

; 63   :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
$LN4@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN9@operator
	npad	7
$LL8@operator:
	mov	eax, DWORD PTR [ecx]

; 452  :             _Pnode = _Pnode->_Left;

	mov	edi, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL8@operator
$LN9@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	DWORD PTR [esi], edi

; 63   :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@UFS_File@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<FS_File> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXXZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXXZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@2@XZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@2@XZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@QAE@XZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXXZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXXZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@2@XZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@2@XZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@QAE@XZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXXZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXXZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@2@XZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@2@XZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@QAE@XZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXXZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXXZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@2@XZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@2@XZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXXZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXXZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@2@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@QAE@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXXZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXXZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::vector<IRender_Portal *,xalloc<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::vector<IRender_Portal *,xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h
;	COMDAT ?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ
_TEXT	SEGMENT
?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ PROC	; CRegistrator<pureFrame>::Resort, COMDAT
; _this$ = ecx

; 83   : 	{

	push	esi

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	push	DWORD PTR __imp_?_REG_Compare@@YAHPBX0@Z
	mov	esi, ecx
	push	12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	push	eax
	push	edx
	call	DWORD PTR __imp__qsort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 84   : 		qsort(&*R.begin(), R.size(), sizeof(_REG_INFO), _REG_Compare);

	add	esp, 16					; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	ecx, eax
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	je	SHORT $LN50@Resort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	push	edi
	mov	edi, eax
$LL2@Resort:

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, edi
	sub	ecx, edx
	sar	ecx, 2
	imul	ecx, ecx, -1431655765

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	lea	ecx, DWORD PTR [ecx+ecx*2]
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	cmp	DWORD PTR [edx+ecx*4-8], -1
	jne	SHORT $LN51@Resort
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	lea	eax, DWORD PTR [edi-12]

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, eax

; 1390 :         --_Mylast;

	mov	DWORD PTR [esi+4], eax

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edi, eax
	sub	ecx, edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 85   : 		while ((R.size()) && (R[R.size() - 1].Prio == REG_PRIORITY_INVALID)) R.pop_back();

	jne	SHORT $LL2@Resort
$LN51@Resort:
	pop	edi
$LN50@Resort:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	cmp	edx, eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\pure.h

; 86   : 		if (R.empty())		R.clear();

	jne	SHORT $LN49@Resort
	mov	DWORD PTR [esi+4], edx
$LN49@Resort:

; 87   : 		changed = false;
; 88   : 	};

	and	DWORD PTR [esi+12], -3			; fffffffdH
	pop	esi
	ret	0
?Resort@?$CRegistrator@VpureFrame@@@@QAEXXZ ENDP	; CRegistrator<pureFrame>::Resort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEAAU_REG_INFO@@I@Z ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QBEIXZ ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXABU_REG_INFO@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXABU_REG_INFO@@@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXABU_REG_INFO@@@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?A_TABU_REG_INFO@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?A_TABU_REG_INFO@@@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::emplace_back<_REG_INFO const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?A_TABU_REG_INFO@@@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::emplace_back<_REG_INFO const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAE?A_TABU_REG_INFO@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAE?A_TABU_REG_INFO@@@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_back_with_unused_capacity<_REG_INFO const &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAE?A_TABU_REG_INFO@@@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_back_with_unused_capacity<_REG_INFO const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXQAU?$_Tree_node@UFS_File@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXQAU?$_Tree_node@UFS_File@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Orphan_ptr, COMDAT
; _this$dead$ = ecx

; 714  : #if _ITERATOR_DEBUG_LEVEL == 2
; 715  :         _Lockit _Lock(_LOCK_DEBUG);
; 716  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 717  :         while (*_Pnext) {
; 718  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 719  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 720  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 721  :             } else { // orphan the iterator
; 722  :                 (*_Pnext)->_Myproxy = nullptr;
; 723  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 724  :             }
; 725  :         }
; 726  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 727  :         (void) _Ptr;
; 728  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 729  :     }

	ret	4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXQAU?$_Tree_node@UFS_File@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1947 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	eax, ecx

; 1948 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1943 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	eax, ecx

; 1944 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Getal, COMDAT
; _this$ = ecx

; 1935 :         return _Mypair._Myval2._Get_first();

	mov	eax, ecx

; 1936 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@ABU?$less@UFS_File@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@ABU?$less@UFS_File@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >, COMDAT
; _this$ = ecx

; 883  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	64					; 00000040H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax

; 884  :         _Alloc_sentinel_and_proxy();
; 885  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@QAE@ABU?$less@UFS_File@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEAAU_REG_INFO@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEAAU_REG_INFO@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEAAU_REG_INFO@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEABUFSlideWindowItem@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEABUFSlideWindowItem@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEABUFSlideWindowItem@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAE@PAUFSlideWindowItem@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEABV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEABV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEABV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 524
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEABV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEABV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEABV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAE@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DVertexBuffer9@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DVertexBuffer9@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DVertexBuffer9@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DVertexBuffer9@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DIndexBuffer9@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DIndexBuffer9@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEABQAUIDirect3DIndexBuffer9@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAE@PAPAUIDirect3DIndexBuffer9@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@0@Z PROC ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUIDirect3DIndexBuffer9@@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@AAEXPAPAUIDirect3DIndexBuffer9@@0@Z ENDP ; std::vector<IDirect3DIndexBuffer9 *,xalloc<IDirect3DIndexBuffer9 *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEXPAPAUIDirect3DIndexBuffer9@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEXPAPAUIDirect3DIndexBuffer9@@I@Z PROC ; xalloc<IDirect3DIndexBuffer9 *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QBEXPAPAUIDirect3DIndexBuffer9@@I@Z ENDP ; xalloc<IDirect3DIndexBuffer9 *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@0@Z PROC ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUIDirect3DVertexBuffer9@@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@AAEXPAPAUIDirect3DVertexBuffer9@@0@Z ENDP ; std::vector<IDirect3DVertexBuffer9 *,xalloc<IDirect3DVertexBuffer9 *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEXPAPAUIDirect3DVertexBuffer9@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEXPAPAUIDirect3DVertexBuffer9@@I@Z PROC ; xalloc<IDirect3DVertexBuffer9 *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QBEXPAPAUIDirect3DVertexBuffer9@@I@Z ENDP ; xalloc<IDirect3DVertexBuffer9 *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z PROC ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@AAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@0@Z ENDP ; std::vector<svector<_D3DVERTEXELEMENT9,65>,xalloc<svector<_D3DVERTEXELEMENT9,65> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QBEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@I@Z ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z PROC ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$resptr_core@UShader@@Uresptrcode_shader@@@@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@AAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ENDP ; std::vector<resptr_core<Shader,resptrcode_shader>,xalloc<resptr_core<Shader,resptrcode_shader> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QBEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEAAV?$xalloc@UFSlideWindowItem@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEAAV?$xalloc@UFSlideWindowItem@@@@XZ PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEAAV?$xalloc@UFSlideWindowItem@@@@XZ ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@0@Z PROC ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@UFSlideWindowItem@@V?$xalloc@UFSlideWindowItem@@@@@std@@AAEXPAUFSlideWindowItem@@0@Z ENDP ; std::vector<FSlideWindowItem,xalloc<FSlideWindowItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@UFSlideWindowItem@@@@QBEXPAUFSlideWindowItem@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@UFSlideWindowItem@@@@QBEXPAUFSlideWindowItem@@I@Z PROC ; xalloc<FSlideWindowItem>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@UFSlideWindowItem@@@@QBEXPAUFSlideWindowItem@@I@Z ENDP ; xalloc<FSlideWindowItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEAAV?$xalloc@PAVIRender_Portal@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEAAV?$xalloc@PAVIRender_Portal@@@@XZ PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEAAV?$xalloc@PAVIRender_Portal@@@@XZ ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@0@Z PROC ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVIRender_Portal@@V?$xalloc@PAVIRender_Portal@@@@@std@@AAEXPAPAVIRender_Portal@@0@Z ENDP ; std::vector<IRender_Portal *,xalloc<IRender_Portal *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVIRender_Portal@@@@QBEXPAPAVIRender_Portal@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVIRender_Portal@@@@QBEXPAPAVIRender_Portal@@I@Z PROC ; xalloc<IRender_Portal *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVIRender_Portal@@@@QBEXPAPAVIRender_Portal@@I@Z ENDP ; xalloc<IRender_Portal *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEXPAU_REG_INFO@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEXPAU_REG_INFO@@0@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEXPAU_REG_INFO@@0@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBE_NXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBE_NXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@2@XZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@2@XZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::pop_back, COMDAT
; _this$ = ecx

; 1381 :         auto& _My_data   = _Mypair._Myval2;
; 1382 :         pointer& _Mylast = _My_data._Mylast;
; 1383 : 
; 1384 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 
; 1388 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1389 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1390 :         --_Mylast;

	add	DWORD PTR [ecx+4], -12			; fffffff4H

; 1391 :     }

	ret	0
?pop_back@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ PROC ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@XZ ENDP ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@SAPAU?$_Tree_node@UFS_File@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@SAPAU?$_Tree_node@UFS_File@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Min, COMDAT
; __Pnode$ = ecx

; 451  :         while (!_Pnode->_Left->_Isnil) {

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN9@Min
$LL2@Min:
	mov	ecx, DWORD PTR [edx]

; 452  :             _Pnode = _Pnode->_Left;

	mov	eax, edx
	mov	edx, ecx
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@Min

; 456  :     }

	ret	0
$LN9@Min:

; 453  :         }
; 454  : 
; 455  :         return _Pnode;

	mov	eax, ecx

; 456  :     }

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@SAPAU?$_Tree_node@UFS_File@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1913 :     void _Alloc_sentinel_and_proxy() {

	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1914 :         const auto _Scary = _Get_scary();
; 1915 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1916 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
	pop	esi

; 1918 :         _Proxy._Release();
; 1919 :     }

	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@UFS_File@@U?$less@UFS_File@@@std@@V?$xalloc@UFS_File@@@@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FS_File,std::less<FS_File>,xalloc<FS_File>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEABU_REG_INFO@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEABU_REG_INFO@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEABU_REG_INFO@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAE@PAU_REG_INFO@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	imul	eax, DWORD PTR __Off$[esp-4], 524
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ PROC ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ PROC ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ PROC ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UFSlideWindowItem@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UFSlideWindowItem@@@@XZ PROC ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAEAAV?$xalloc@UFSlideWindowItem@@@@XZ ENDP ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Portal@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Portal@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRender_Portal@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ PROC ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@@QAEXXZ ENDP ; xr_vector<_REG_INFO,xalloc<_REG_INFO> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEXXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_REG_INFO> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ PROC	; xr_new<CRenderTarget>, COMDAT

; 67   : {

	push	ecx

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	push	108					; 0000006cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+12], 0

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+24], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+24]

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+40], 0
	mov	DWORD PTR [edi+44], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp

; 10   : {

	mov	DWORD PTR [edi], OFFSET ??_7CRenderTarget@@6B@

; 11   : 	bAvailable			= FALSE;

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+12]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+24], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VCRT@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender_RenderTarget.cpp

; 32   : 	bAvailable			= Create	();

	mov	ecx, edi
	mov	DWORD PTR [edi+104], 0
	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+60], 0
	mov	DWORD PTR [edi+64], 0
	mov	DWORD PTR [edi+76], 0
	mov	DWORD PTR [edi+68], 0
	mov	DWORD PTR [edi+72], 0
	mov	DWORD PTR [edi+84], 1103626240		; 41c80000H
	mov	DWORD PTR [edi+80], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+52], 0
	mov	DWORD PTR [edi+56], 0
	mov	DWORD PTR [edi+88], 8355711		; 007f7f7fH
	mov	DWORD PTR [edi+92], 5592405		; 00555555H
	mov	DWORD PTR [edi+96], 0
	call	?Create@CRenderTarget@@AAEHXZ		; CRenderTarget::Create

; 33   : 	Msg					("* SSample: %s",bAvailable?"enabled":"disabled");

	test	eax, eax
	mov	DWORD PTR [edi+4], eax
	mov	edx, OFFSET ??_C@_08BEHKFNNO@disabled@
	mov	ecx, OFFSET ??_C@_07MHHIKOPA@enabled@
	cmove	ecx, edx
	push	ecx
	push	OFFSET ??_C@_0O@HCJBNNCF@?$CK?5SSample?3?5?$CFs@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, edi
	pop	edi
	pop	esi

; 70   : }

	pop	ecx
	ret	0
??$xr_new@VCRenderTarget@@@@YAPAVCRenderTarget@@XZ ENDP	; xr_new<CRenderTarget>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCModelPool@@@@YAPAVCModelPool@@XZ
_TEXT	SEGMENT
??$xr_new@VCModelPool@@@@YAPAVCModelPool@@XZ PROC	; xr_new<CModelPool>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	mov	esi, DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	push	edi
	push	56					; 00000038H
	call	esi

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 192  : {

	mov	DWORD PTR [edi], OFFSET ??_7CModelPool@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+32], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
	push	24					; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [edi+28], eax

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+40], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1917 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [edi+36], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 193  : 	bLogging				= TRUE;

	mov	DWORD PTR [edi+44], 1

; 194  :     bForceDiscard 			= FALSE;

	mov	DWORD PTR [edi+48], 0

; 195  :     bAllowChildrenDuplicate	= TRUE; 

	mov	DWORD PTR [edi+52], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi

; 69   : 	return new (ptr) T();

	mov	ecx, eax
	call	DWORD PTR __imp_??0motions_container@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\ModelPool.cpp

; 196  : 	g_pMotionsContainer		= xr_new<motions_container>();

	mov	ecx, DWORD PTR __imp_?g_pMotionsContainer@@3PAVmotions_container@@A
	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, edi
	pop	edi
	pop	esi

; 70   : }

	ret	0
??$xr_new@VCModelPool@@@@YAPAVCModelPool@@XZ ENDP	; xr_new<CModelPool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCLightR_Manager@@@@YAPAVCLightR_Manager@@XZ
_TEXT	SEGMENT
??$xr_new@VCLightR_Manager@@@@YAPAVCLightR_Manager@@XZ PROC ; xr_new<CLightR_Manager>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	52					; 00000034H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 322  : {

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7CLightR_Manager@@6B@
	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+28], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	esi

; 70   : }

	ret	0
??$xr_new@VCLightR_Manager@@@@YAPAVCLightR_Manager@@XZ ENDP ; xr_new<CLightR_Manager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCLightR_Manager@@@@YAXAAPAVCLightR_Manager@@@Z
_TEXT	SEGMENT
??$xr_delete@VCLightR_Manager@@@@YAXAAPAVCLightR_Manager@@@Z PROC ; xr_delete<CLightR_Manager>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VCLightR_Manager@@@@YAXAAPAVCLightR_Manager@@@Z ENDP ; xr_delete<CLightR_Manager>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCModelPool@@@@YAXAAPAVCModelPool@@@Z
_TEXT	SEGMENT
??$xr_delete@VCModelPool@@@@YAXAAPAVCModelPool@@@Z PROC	; xr_delete<CModelPool>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VCModelPool@@@@YAXAAPAVCModelPool@@@Z ENDP	; xr_delete<CModelPool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCRenderTarget@@@@YAXAAPAVCRenderTarget@@@Z
_TEXT	SEGMENT
??$xr_delete@VCRenderTarget@@@@YAXAAPAVCRenderTarget@@@Z PROC ; xr_delete<CRenderTarget>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+48]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VCRenderTarget@@@@YAXAAPAVCRenderTarget@@@Z ENDP ; xr_delete<CRenderTarget>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCROS_impl@@@@YAPAVCROS_impl@@XZ
_TEXT	SEGMENT
??$xr_new@VCROS_impl@@@@YAPAVCROS_impl@@XZ PROC		; xr_new<CROS_impl>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	1960					; 000007a8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	esi, eax
	mov	edx, 26					; 0000001aH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [esi], OFFSET ??_7CROS_impl@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+16], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	eax, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	npad	1
$LL24@xr_new:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax-16], 0
	lea	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [eax-80], 0
	mov	DWORD PTR [eax-76], 0
	mov	DWORD PTR [eax-72], 0
	mov	DWORD PTR [eax-68], 0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_collide_defs.h

; 34   : 			range = 0;

	mov	DWORD PTR [eax-64], 0

; 35   : 			result = FALSE;

	mov	DWORD PTR [eax-60], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-24], 0
	sub	edx, 1
	jne	$LL24@xr_new
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 21   : {

	lea	ecx, DWORD PTR [esi+1836]
	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1948], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [esi+1952], 0
	mov	DWORD PTR [esi+1956], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\LightTrack.cpp

; 23   : 	dwFrame				= u32(-1);

	mov	DWORD PTR [esi+8], -1

; 24   : 	shadow_recv_frame	= u32(-1);

	mov	DWORD PTR [esi+1924], -1

; 25   : 	shadow_recv_slot	= -1;

	mov	DWORD PTR [esi+1928], -1

; 26   : 
; 27   : 	result_count		= 0;

	mov	DWORD PTR [esi+1904], 0

; 28   : 	result_iterator		= 0;

	mov	DWORD PTR [esi+1908], 0

; 29   : 	result_frame		= u32(-1);

	mov	DWORD PTR [esi+1912], -1

; 30   : 	result_sun			= 0;

	mov	DWORD PTR [esi+1916], 0

; 31   : 	hemi_value			= 0.5f;

	mov	DWORD PTR [esi+1932], 1056964608	; 3f000000H

; 32   : 	hemi_smooth			= 0.5f;

	mov	DWORD PTR [esi+1936], 1056964608	; 3f000000H

; 33   : 	sun_value			= 0.2f;

	mov	DWORD PTR [esi+1940], 1045220557	; 3e4ccccdH

; 34   : 	sun_smooth			= 0.2f;

	mov	DWORD PTR [esi+1944], 1045220557	; 3e4ccccdH

; 35   : 
; 36   : #if RENDER==R_R1
; 37   : 	MODE				= IRender_ObjectSpecific::TRACE_ALL											;

	mov	DWORD PTR [esi+4], 7
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	esi

; 70   : }

	ret	0
??$xr_new@VCROS_impl@@@@YAPAVCROS_impl@@XZ ENDP		; xr_new<CROS_impl>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VIRender_ObjectSpecific@@@@YAXAAPAVIRender_ObjectSpecific@@@Z
_TEXT	SEGMENT
??$xr_delete@VIRender_ObjectSpecific@@@@YAXAAPAVIRender_ObjectSpecific@@@Z PROC ; xr_delete<IRender_ObjectSpecific>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+12]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VIRender_ObjectSpecific@@@@YAXAAPAVIRender_ObjectSpecific@@@Z ENDP ; xr_delete<IRender_ObjectSpecific>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@VCGlow@@@@YAPAVCGlow@@XZ
_TEXT	SEGMENT
??$xr_new@VCGlow@@@@YAPAVCGlow@@XZ PROC			; xr_new<CGlow>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	push	200					; 000000c8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 11   : 	xr_resource()			: dwReference(0)				{ }

	mov	DWORD PTR [edi+4], 0
	mov	ecx, DWORD PTR __imp_??_7IRender_Glow@@6B@
	mov	DWORD PTR [edi], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 20   : CGlow::CGlow		()		: ISpatial(g_SpatialSpace)

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edi+8]
	call	DWORD PTR __imp_??0ISpatial@@QAE@PAVISpatial_DB@@@Z

; 21   : {

	mov	DWORD PTR [edi], OFFSET ??_7CGlow@@6BIRender_Glow@@@
	lea	ecx, DWORD PTR [edi+124]
	mov	DWORD PTR [edi+8], OFFSET ??_7CGlow@@6BISpatial@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+68], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 21   : {

	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache

; 22   : 	flags.bActive	= false;

	and	DWORD PTR [edi+60], -2			; fffffffeH
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+76], 0
	mov	DWORD PTR [edi+80], 0
	mov	DWORD PTR [edi+84], 0
	mov	DWORD PTR [edi+88], 0
	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 25   : 	radius			= 0.1f;

	mov	DWORD PTR [edi+100], 1036831949		; 3dcccccdH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	mov	DWORD PTR [edi+104], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+108], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+112], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 27   : 	bTestResult		= FALSE;

	mov	DWORD PTR [edi+120], 0

; 28   : 	fade			= 1.f;

	mov	DWORD PTR [edi+64], 1065353216		; 3f800000H

; 29   : 	dwFrame			= 0;

	mov	DWORD PTR [edi+72], 0

; 30   : 	spatial.type	= STYPE_RENDERABLE;

	mov	DWORD PTR [edi+12], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	edi
	pop	esi

; 70   : }

	ret	0
??$xr_new@VCGlow@@@@YAPAVCGlow@@XZ ENDP			; xr_new<CGlow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@P6A_NPAVISpatial@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0P6A_NPAVISpatial@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@P6A_NPAVISpatial@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0P6A_NPAVISpatial@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __Pred$dead$ = ecx

; 7076 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	push	ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?pred_sp_sort@@YA_NPAVISpatial@@0@Z ; pred_sp_sort
	push	eax
	call	??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
	add	esp, 8

; 7081 : }

	pop	ecx
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@P6A_NPAVISpatial@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0P6A_NPAVISpatial@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@E@@YAPAEI@Z
_TEXT	SEGMENT
??$xr_alloc@E@@YAPAEI@Z PROC				; xr_alloc<unsigned char>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@E@@YAPAEI@Z ENDP				; xr_alloc<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@$$CBX@@YAXAAPBX@Z
_TEXT	SEGMENT
??$xr_free@$$CBX@@YAXAAPBX@Z PROC			; xr_free<void const >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@$$CBX@@YAXAAPBX@Z ENDP			; xr_free<void const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z
_TEXT	SEGMENT
_init_rem$dead$ = 8					; size = 4
??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z PROC ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::crc_optimal<32,79764919,4294967295,4294967295,1,1>, COMDAT
; _this$ = ecx

; 799  : {

	push	esi
	push	edi

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	or	edx, -1

; 310  :         value_type        reflection = 0;

	xor	esi, esi

; 799  : {

	mov	edi, ecx

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	xor	eax, eax
	npad	5
$LL8@crc_optima:

; 315  :             if ( x & one )

	test	dl, 1
	je	SHORT $LN6@crc_optima

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	bts	esi, ecx
$LN6@crc_optima:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	inc	eax
	shr	edx, 1
	cmp	eax, 32					; 00000020H
	jb	SHORT $LL8@crc_optima

; 800  :     crc_table_type::init_table();

	mov	DWORD PTR [edi], esi
	call	?init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ ; boost::detail::crc_table_t<32,79764919,1>::init_table

; 801  : }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAE@I@Z ENDP ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::crc_optimal<32,79764919,4294967295,4294967295,1,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?process_block@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAEXPBX0@Z
_TEXT	SEGMENT
_bytes_begin$ = 8					; size = 4
_bytes_end$ = 12					; size = 4
?process_block@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAEXPBX0@Z PROC ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::process_block, COMDAT
; _this$ = ecx

; 912  :     // Recompute the CRC for each byte passed
; 913  :     for ( unsigned char const * p
; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	mov	edx, DWORD PTR _bytes_begin$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _bytes_end$[esp+4]
	mov	esi, ecx
	cmp	edx, edi
	jae	SHORT $LN3@process_bl
	mov	eax, DWORD PTR [esi]
$LL4@process_bl:

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	mov	cl, BYTE PTR [edx]

; 912  :     // Recompute the CRC for each byte passed
; 913  :     for ( unsigned char const * p
; 914  :      = static_cast<unsigned char const *>(bytes_begin) ; p < bytes_end ; ++p )

	inc	edx

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	xor	cl, BYTE PTR [esi]

; 915  :     {
; 916  :         // Compare the new byte with the remainder's higher bits to
; 917  :         // get the new bits, shift out the remainder's current higher
; 918  :         // bits, and update the remainder with the polynominal division
; 919  :         // of the new bits.
; 920  :         unsigned char const  byte_index = helper_type::index( rem_, *p );
; 921  :         rem_ = helper_type::shift( rem_ );
; 922  :         rem_ ^= crc_table_type::table_[ byte_index ];

	movzx	ecx, cl

; 542  :             { return rem >> CHAR_BIT; }

	shr	eax, 8

; 915  :     {
; 916  :         // Compare the new byte with the remainder's higher bits to
; 917  :         // get the new bits, shift out the remainder's current higher
; 918  :         // bits, and update the remainder with the polynominal division
; 919  :         // of the new bits.
; 920  :         unsigned char const  byte_index = helper_type::index( rem_, *p );
; 921  :         rem_ = helper_type::shift( rem_ );
; 922  :         rem_ ^= crc_table_type::table_[ byte_index ];

	xor	eax, DWORD PTR ?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA[ecx*4]
	mov	DWORD PTR [esi], eax
	cmp	edx, edi
	jb	SHORT $LL4@process_bl
$LN3@process_bl:
	pop	edi

; 923  :     }
; 924  : }

	pop	esi
	ret	8
?process_block@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QAEXPBX0@Z ENDP ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::process_block
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?checksum@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ
_TEXT	SEGMENT
?checksum@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ PROC ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::checksum, COMDAT
; _this$ = ecx

; 951  :     return ( reflect_out_type::reflect(rem_) ^ get_final_xor_value() )

	mov	eax, DWORD PTR [ecx]
	not	eax

; 952  :      & masking_type::sig_bits_fast;
; 953  : }

	ret	0
?checksum@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ ENDP ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::checksum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\string.h
;	COMDAT ??$strncpy_s@$02@@YAHAAY02DPBDI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
??$strncpy_s@$02@@YAHAAY02DPBDI@Z PROC			; strncpy_s<3>, COMDAT
; __Destination$ = ecx
; __Source$ = edx

; 327  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(

	push	2
	push	edx
	push	3
	push	ecx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
	ret	0
??$strncpy_s@$02@@YAHAAY02DPBDI@Z ENDP			; strncpy_s<3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

	push	ebp
	push	esi

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	mov	esi, DWORD PTR __Rootnode$[esp+4]
	mov	ebp, ecx
	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN3@Erase_tree
	push	ebx
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	edi
$LL2@Erase_tree:

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, ebp
	push	DWORD PTR __Al$[esp+16]
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	edi, esi

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 380  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	ecx, DWORD PTR [edi+16]
	call	DWORD PTR __imp_??1FS_File@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edi, edi
	je	SHORT $LN367@Erase_tree
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	ebx
$LN367@Erase_tree:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL2@Erase_tree
	pop	edi
	pop	ebx
$LN3@Erase_tree:
	pop	esi

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 746  :         }
; 747  :     }

	pop	ebp
	ret	8
??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Erase_head@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_head<xalloc<std::_Tree_node<FS_File,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

	push	esi
	mov	esi, ecx

; 751  :         this->_Orphan_all();
; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	push	DWORD PTR __Al$[esp+4]
	call	??$_Erase_tree@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_tree<xalloc<std::_Tree_node<FS_File,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 560  :         _Al.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	eax, eax
	je	SHORT $LN10@Erase_head
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	DWORD PTR __Al$[esp-4], eax
	jmp	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN10@Erase_head:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 754  :     }

	ret	4
??$_Erase_head@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAEXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Erase_head<xalloc<std::_Tree_node<FS_File,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DIndexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@V?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1>::_Compressed_pair<xalloc<IDirect3DVertexBuffer9 *>,std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@V?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1>::_Compressed_pair<xalloc<svector<_D3DVERTEXELEMENT9,65> >,std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1>::_Compressed_pair<xalloc<resptr_core<Shader,resptrcode_shader> >,std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<FSlideWindowItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@UFSlideWindowItem@@@@V?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1>::_Compressed_pair<xalloc<FSlideWindowItem>,std::_Vector_val<std::_Simple_types<FSlideWindowItem> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVIRender_Portal@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1>::_Compressed_pair<xalloc<IRender_Portal *>,std::_Vector_val<std::_Simple_types<IRender_Portal *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU_REG_INFO@@@std@@YAABU_REG_INFO@@ABU1@@Z
_TEXT	SEGMENT
??$forward@ABU_REG_INFO@@@std@@YAABU_REG_INFO@@ABU1@@Z PROC ; std::forward<_REG_INFO const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU_REG_INFO@@@std@@YAABU_REG_INFO@@ABU1@@Z ENDP ; std::forward<_REG_INFO const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_REG_INFO@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@ABU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_REG_INFO@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@ABU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_REG_INFO@@ABU1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@ABU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Backout$2 = -44					; size = 12
__Newvec$ = -32						; size = 4
__Oldsize$1$ = -28					; size = 4
__UFirst$3 = -24					; size = 4
tv441 = -20						; size = 4
__Whereoff$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$1$[ebp], eax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx
	sar	eax, 2
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 357913941				; 15555555H
	je	$LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 2
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 357913941				; 15555555H
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 357913941				; 15555555H
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR tv441[ebp], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	edx
	push	ecx
	call	?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv441[ebp]
	lea	eax, DWORD PTR [ecx+12]
	push	eax
	push	DWORD PTR [edi+4]
	push	DWORD PTR __Whereptr$[ebp]
	call	?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	inc	eax
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv441[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z ; xalloc<_REG_INFO>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@CAXXZ ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_REG_INFO@@@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@QAU2@ABU2@@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Emplace_reallocate<_REG_INFO const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > const >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<FS_File> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABU?$less@UFS_File@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@UFS_File@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@UFS_File@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@UFS_File@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@UFS_File@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@UFS_File@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1>::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1><std::less<FS_File> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	12					; 0000000cH
??$?0ABU?$less@UFS_File@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@UFS_File@@@std@@V?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@UFS_File@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1>::_Compressed_pair<std::less<FS_File>,std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>,1><std::less<FS_File> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAXPAPAUIDirect3DIndexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAXPAPAUIDirect3DIndexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z PROC ; std::_Destroy_range<xalloc<IDirect3DIndexBuffer9 *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@YAXPAPAUIDirect3DIndexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@@Z ENDP ; std::_Destroy_range<xalloc<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUIDirect3DIndexBuffer9@@@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$xr_free@PAUIDirect3DIndexBuffer9@@@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z PROC ; xr_free<IDirect3DIndexBuffer9 *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUIDirect3DIndexBuffer9@@@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z ENDP ; xr_free<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAXPAPAUIDirect3DVertexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAXPAPAUIDirect3DVertexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z PROC ; std::_Destroy_range<xalloc<IDirect3DVertexBuffer9 *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@YAXPAPAUIDirect3DVertexBuffer9@@QAPAU1@AAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@@Z ENDP ; std::_Destroy_range<xalloc<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUIDirect3DVertexBuffer9@@@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$xr_free@PAUIDirect3DVertexBuffer9@@@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z PROC ; xr_free<IDirect3DVertexBuffer9 *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUIDirect3DVertexBuffer9@@@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z ENDP ; xr_free<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z PROC ; std::_Destroy_range<xalloc<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@YAXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@QAV1@AAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@Z ENDP ; std::_Destroy_range<xalloc<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; xr_free<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; xr_free<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z PROC ; std::_Destroy_range<xalloc<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@YAXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@QAV1@AAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@Z ENDP ; std::_Destroy_range<xalloc<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; xr_free<resptr_core<Shader,resptrcode_shader> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; xr_free<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@UFSlideWindowItem@@@@@std@@YAXPAUFSlideWindowItem@@QAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@UFSlideWindowItem@@@@@std@@YAXPAUFSlideWindowItem@@QAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z PROC ; std::_Destroy_range<xalloc<FSlideWindowItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@UFSlideWindowItem@@@@@std@@YAXPAUFSlideWindowItem@@QAU1@AAV?$xalloc@UFSlideWindowItem@@@@@Z ENDP ; std::_Destroy_range<xalloc<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$xr_free@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z PROC ; xr_free<FSlideWindowItem>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z ENDP ; xr_free<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVIRender_Portal@@@@@std@@YAXPAPAVIRender_Portal@@QAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVIRender_Portal@@@@@std@@YAXPAPAVIRender_Portal@@QAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z PROC ; std::_Destroy_range<xalloc<IRender_Portal *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVIRender_Portal@@@@@std@@YAXPAPAVIRender_Portal@@QAPAV1@AAV?$xalloc@PAVIRender_Portal@@@@@Z ENDP ; std::_Destroy_range<xalloc<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVIRender_Portal@@@@YAXAAPAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$xr_free@PAVIRender_Portal@@@@YAXAAPAPAVIRender_Portal@@@Z PROC ; xr_free<IRender_Portal *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVIRender_Portal@@@@YAXAAPAPAVIRender_Portal@@@Z ENDP ; xr_free<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<_REG_INFO> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<_REG_INFO> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Buyheadnode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z PROC ; std::_Tree_node<FS_File,void *>::_Buyheadnode<xalloc<std::_Tree_node<FS_File,void *> > >, COMDAT
; __Al$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 345  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	DWORD PTR [eax], eax

; 346  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	DWORD PTR [eax+4], eax

; 347  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	DWORD PTR [eax+8], eax

; 348  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 349  :         _Pnode->_Isnil = true;
; 350  :         return _Pnode;
; 351  :     }

	ret	0
??$_Buyheadnode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAPAU01@AAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@Z ENDP ; std::_Tree_node<FS_File,void *>::_Buyheadnode<xalloc<std::_Tree_node<FS_File,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?reflect@?$crc_helper@$0CA@$0A@@detail@boost@@SAII@Z
_TEXT	SEGMENT
?reflect@?$crc_helper@$0CA@$0A@@detail@boost@@SAII@Z PROC ; boost::detail::crc_helper<32,0>::reflect, COMDAT
; _x$ = ecx

; 569  :             { return x; }

	mov	eax, ecx
	ret	0
?reflect@?$crc_helper@$0CA@$0A@@detail@boost@@SAII@Z ENDP ; boost::detail::crc_helper<32,0>::reflect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?shift@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z
_TEXT	SEGMENT
?shift@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z PROC	; boost::detail::crc_helper<32,1>::shift, COMDAT
; _rem$ = ecx

; 542  :             { return rem >> CHAR_BIT; }

	shr	ecx, 8
	mov	eax, ecx
	ret	0
?shift@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z ENDP	; boost::detail::crc_helper<32,1>::shift
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?index@?$crc_helper@$0CA@$00@detail@boost@@SAEIE@Z
_TEXT	SEGMENT
?index@?$crc_helper@$0CA@$00@detail@boost@@SAEIE@Z PROC	; boost::detail::crc_helper<32,1>::index, COMDAT
; _rem$ = ecx
; _x$ = dl

; 538  :             { return (unsigned char)(x ^ (rem & 0xff)); }

	xor	cl, dl
	mov	al, cl
	ret	0
?index@?$crc_helper@$0CA@$00@detail@boost@@SAEIE@Z ENDP	; boost::detail::crc_helper<32,1>::index
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?reflect@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z
_TEXT	SEGMENT
?reflect@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z PROC ; boost::detail::crc_helper<32,1>::reflect, COMDAT
; _x$ = ecx

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	push	esi

; 310  :         value_type        reflection = 0;

	xor	esi, esi

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	xor	edx, edx
$LL6@reflect:

; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN4@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	mov	eax, 31					; 0000001fH
	sub	eax, edx
	bts	esi, eax
$LN4@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	inc	edx
	shr	ecx, 1
	cmp	edx, 32					; 00000020H
	jb	SHORT $LL6@reflect

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	mov	eax, esi
	pop	esi
	ret	0
?reflect@?$crc_helper@$0CA@$00@detail@boost@@SAII@Z ENDP ; boost::detail::crc_helper<32,1>::reflect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VIRender_ObjectSpecific@@@@QAEXAAPAVIRender_ObjectSpecific@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VIRender_ObjectSpecific@@@@QAEXAAPAVIRender_ObjectSpecific@@@Z PROC ; xr_special_free<1,IRender_ObjectSpecific>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+12]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VIRender_ObjectSpecific@@@@QAEXAAPAVIRender_ObjectSpecific@@@Z ENDP ; xr_special_free<1,IRender_ObjectSpecific>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCRenderTarget@@@@QAEXAAPAVCRenderTarget@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VCRenderTarget@@@@QAEXAAPAVCRenderTarget@@@Z PROC ; xr_special_free<1,CRenderTarget>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx+48]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VCRenderTarget@@@@QAEXAAPAVCRenderTarget@@@Z ENDP ; xr_special_free<1,CRenderTarget>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCModelPool@@@@QAEXAAPAVCModelPool@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VCModelPool@@@@QAEXAAPAVCModelPool@@@Z PROC ; xr_special_free<1,CModelPool>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VCModelPool@@@@QAEXAAPAVCModelPool@@@Z ENDP ; xr_special_free<1,CModelPool>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCLightR_Manager@@@@QAEXAAPAVCLightR_Manager@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VCLightR_Manager@@@@QAEXAAPAVCLightR_Manager@@@Z PROC ; xr_special_free<1,CLightR_Manager>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VCLightR_Manager@@@@QAEXAAPAVCLightR_Manager@@@Z ENDP ; xr_special_free<1,CLightR_Manager>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEPAPAVISpatial@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEPAPAVISpatial@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@QBEPAPAVISpatial@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DIndexBuffer9@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DIndexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAE@XZ PROC	; xalloc<IDirect3DIndexBuffer9 *>::xalloc<IDirect3DIndexBuffer9 *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAE@XZ ENDP	; xalloc<IDirect3DIndexBuffer9 *>::xalloc<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUIDirect3DVertexBuffer9@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >::_Vector_val<std::_Simple_types<IDirect3DVertexBuffer9 *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAE@XZ PROC	; xalloc<IDirect3DVertexBuffer9 *>::xalloc<IDirect3DVertexBuffer9 *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAE@XZ ENDP	; xalloc<IDirect3DVertexBuffer9 *>::xalloc<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >::_Vector_val<std::_Simple_types<svector<_D3DVERTEXELEMENT9,65> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAE@XZ PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::xalloc<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAE@XZ ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::xalloc<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >::_Vector_val<std::_Simple_types<resptr_core<Shader,resptrcode_shader> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAE@XZ PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::xalloc<resptr_core<Shader,resptrcode_shader> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAE@XZ ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::xalloc<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FSlideWindowItem> >::_Vector_val<std::_Simple_types<FSlideWindowItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UFSlideWindowItem@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FSlideWindowItem> >::_Vector_val<std::_Simple_types<FSlideWindowItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@UFSlideWindowItem@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UFSlideWindowItem@@@@QAE@XZ PROC		; xalloc<FSlideWindowItem>::xalloc<FSlideWindowItem>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@UFSlideWindowItem@@@@QAE@XZ ENDP		; xalloc<FSlideWindowItem>::xalloc<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IRender_Portal *> >::_Vector_val<std::_Simple_types<IRender_Portal *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVIRender_Portal@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IRender_Portal *> >::_Vector_val<std::_Simple_types<IRender_Portal *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVIRender_Portal@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVIRender_Portal@@@@QAE@XZ PROC		; xalloc<IRender_Portal *>::xalloc<IRender_Portal *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVIRender_Portal@@@@QAE@XZ ENDP		; xalloc<IRender_Portal *>::xalloc<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@CAXXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@CAXXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXQAU_REG_INFO@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXQAU_REG_INFO@@II@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXQAU_REG_INFO@@II@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEII@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 357913941				; 15555555H

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 357913941				; 15555555H
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEII@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	ecx, edi
	je	SHORT $LN22@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 12					; 0000000cH

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
$LN22@Umove:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
?_Umove@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEPAU_REG_INFO@@PAU3@00@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 357913941				; 15555555H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@ABU2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@ABU2@@Z PROC ; xalloc<_REG_INFO>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	ret	8
?construct@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@ABU2@@Z ENDP ; xalloc<_REG_INFO>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z PROC ; xalloc<_REG_INFO>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U_REG_INFO@@@@QBEPAU_REG_INFO@@IPBX@Z ENDP ; xalloc<_REG_INFO>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEPAU?$_Tree_node@UFS_File@@PAX@std@@IPBX@Z
_TEXT	SEGMENT
_n$dead$ = 8						; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEPAU?$_Tree_node@UFS_File@@PAX@std@@IPBX@Z PROC ; xalloc<std::_Tree_node<FS_File,void *> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEPAU?$_Tree_node@UFS_File@@PAX@std@@IPBX@Z ENDP ; xalloc<std::_Tree_node<FS_File,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEABV?$xalloc@U_REG_INFO@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEABV?$xalloc@U_REG_INFO@@@@XZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@ABEABV?$xalloc@U_REG_INFO@@@@XZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@QBEIXZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAIABV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAIABV?$xalloc@U_REG_INFO@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 357913941				; 15555555H

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAIABV?$xalloc@U_REG_INFO@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_REG_INFO@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_REG_INFO@@@@XZ PROC ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QBEABV?$xalloc@U_REG_INFO@@@@XZ ENDP ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U_REG_INFO@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@U_REG_INFO@@@@QBEIXZ PROC		; xalloc<_REG_INFO>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 357913941				; 15555555H
	ret	0
?max_size@?$xalloc@U_REG_INFO@@@@QBEIXZ ENDP		; xalloc<_REG_INFO>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?get_final_xor_value@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ
_TEXT	SEGMENT
?get_final_xor_value@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ PROC ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::get_final_xor_value, COMDAT
; _this$dead$ = ecx

; 836  :     return FinalXor;

	or	eax, -1

; 837  : }

	ret	0
?get_final_xor_value@?$crc_optimal@$0CA@$0EMBBNLH@$0PPPPPPPP@$0PPPPPPPP@$00$00@boost@@QBEIXZ ENDP ; boost::crc_optimal<32,79764919,4294967295,4294967295,1,1>::get_final_xor_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ
_TEXT	SEGMENT
?init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ PROC ; boost::detail::crc_table_t<32,79764919,1>::init_table, COMDAT

; 479  :         // compute table only on the first run
; 480  :         static  bool  did_init = false;
; 481  :         if ( did_init )  return;

	cmp	BYTE PTR ?did_init@?1??init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ@4_NA, 0 ; `boost::detail::crc_table_t<32,79764919,1>::init_table'::`2'::did_init
	jne	$LN1@init_table

; 482  : 
; 483  :         // factor-out constants to avoid recalculation
; 484  :         value_type const     fast_hi_bit = masking_type::high_bit_fast;
; 485  :         unsigned char const  byte_hi_bit = 1u << (CHAR_BIT - 1u);
; 486  : 
; 487  :         // loop over every possible dividend value
; 488  :         unsigned char  dividend = 0;

	push	ebx
	push	esi
	xor	bh, bh
$LL4@init_table:

; 489  :         do
; 490  :         {
; 491  :             value_type  remainder = 0;

	xor	eax, eax

; 492  : 
; 493  :             // go through all the dividend's bits
; 494  :             for ( unsigned char mask = byte_hi_bit ; mask ; mask >>= 1 )

	mov	bl, 128					; 00000080H
$LL7@init_table:

; 495  :             {
; 496  :                 // check if divisor fits
; 497  :                 if ( dividend & mask )
; 498  :                 {
; 499  :                     remainder ^= fast_hi_bit;
; 500  :                 }
; 501  : 
; 502  :                 // do polynominal division
; 503  :                 if ( remainder & fast_hi_bit )

	mov	edx, eax
	mov	cl, bl
	xor	edx, -2147483648			; 80000000H
	and	cl, bh
	cmove	edx, eax
	lea	ecx, DWORD PTR [edx+edx]
	mov	eax, ecx
	xor	eax, 79764919				; 04c11db7H
	test	edx, edx
	cmovns	eax, ecx
	shr	bl, 1
	jne	SHORT $LL7@init_table

; 310  :         value_type        reflection = 0;

	xor	esi, esi

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	xor	edx, edx
	npad	5
$LL18@init_table:

; 315  :             if ( x & one )

	test	al, 1
	je	SHORT $LN16@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	mov	ecx, 31					; 0000001fH
	sub	ecx, edx
	bts	esi, ecx
$LN16@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	inc	edx
	shr	eax, 1
	cmp	edx, 32					; 00000020H
	jb	SHORT $LL18@init_table

; 310  :         value_type        reflection = 0;

	xor	al, al

; 314  :         {
; 315  :             if ( x & one )

	test	bh, 1
	je	SHORT $LN24@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	xor	eax, eax
	bts	eax, 7
$LN24@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	mov	cl, bh
	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN44@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 6
$LN44@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN46@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 5
$LN46@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN48@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 4
$LN48@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN50@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 3
$LN50@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN52@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 2
$LN52@init_table:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN54@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 1
$LN54@init_table:

; 314  :         {
; 315  :             if ( x & one )

	cmp	cl, 2
	jb	SHORT $LN56@init_table

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 0
$LN56@init_table:

; 504  :                 {
; 505  :                     remainder <<= 1;
; 506  :                     remainder ^= TruncPoly;
; 507  :                 }
; 508  :                 else
; 509  :                 {
; 510  :                     remainder <<= 1;
; 511  :                 }
; 512  :             }
; 513  : 
; 514  :             table_[ crc_helper<CHAR_BIT, Reflect>::reflect(dividend) ]

	movzx	eax, al
	mov	DWORD PTR ?table_@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@2PAIA[eax*4], esi

; 515  :              = crc_helper<Bits, Reflect>::reflect( remainder );
; 516  :         }
; 517  :         while ( ++dividend );

	add	bh, 1
	jne	$LL4@init_table

; 518  : 
; 519  :         did_init = true;

	pop	esi
	mov	BYTE PTR ?did_init@?1??init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ@4_NA, 1 ; `boost::detail::crc_table_t<32,79764919,1>::init_table'::`2'::did_init
	pop	ebx
$LN1@init_table:

; 520  :     }

	ret	0
?init_table@?$crc_table_t@$0CA@$0EMBBNLH@$00@detail@boost@@SAXXZ ENDP ; boost::detail::crc_table_t<32,79764919,1>::init_table
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@V?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1>::_Compressed_pair<xalloc<std::_Tree_node<FS_File,void *> >,std::_Tree_val<std::_Tree_simple_types<FS_File> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<ISpatial *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NPAVISpatial@@0@Z$0A@@std@@YAP6A_NPAVISpatial@@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NPAVISpatial@@0@Z$0A@@std@@YAP6A_NPAVISpatial@@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(ISpatial *,ISpatial *),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?pred_sp_sort@@YA_NPAVISpatial@@0@Z ; pred_sp_sort

; 254  : }

	ret	0
??$_Pass_fn@P6A_NPAVISpatial@@0@Z$0A@@std@@YAP6A_NPAVISpatial@@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(ISpatial *,ISpatial *),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__Last$1$ = -32						; size = 4
__Hole$1$ = -28						; size = 4
__Hole$1$ = -28						; size = 4
__Val$1$ = -24						; size = 4
__Val$1$ = -24						; size = 4
__Mid$1$ = -20						; size = 4
__Max_sequence_non_leaf$1$ = -20			; size = 4
__First$1$ = -16					; size = 4
__Bottom$1$ = -16					; size = 4
tv742 = -12						; size = 4
__Val$1 = -12						; size = 4
__Mid$2 = -12						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z PROC ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ebp, DWORD PTR __Pred$[esp+40]
	mov	ebx, edx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+48], ebx
	mov	eax, ebx
	mov	DWORD PTR __First$1$[esp+48], esi
	sub	eax, esi
	and	eax, -4					; fffffffcH
	push	edi
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN165@Sort_unche
	mov	edi, DWORD PTR __Ideal$[esp+48]
	npad	7
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	edi, edi
	jle	$LN166@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebp
	push	ebx
	mov	edx, esi
	lea	ecx, DWORD PTR __Mid$2[esp+60]
	call	??$_Partition_by_median_guess_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YA?AU?$pair@PAPAVISpatial@@PAPAV1@@0@PAPAVISpatial@@0P6A_NPAV2@1@Z@Z ; std::_Partition_by_median_guess_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$2[esp+60]
	mov	eax, edi
	sar	eax, 2
	add	esp, 8
	sar	edi, 1
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Mid$2[esp+56]
	add	edi, eax
	mov	eax, edx
	and	ecx, -4					; fffffffcH
	sub	eax, esi
	and	eax, -4					; fffffffcH
	push	ebp
	push	edi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, esi
	call	??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>

; 7067 :             _First = _Mid.second;

	mov	esi, DWORD PTR __Mid$2[esp+64]
	mov	DWORD PTR __First$1$[esp+60], esi

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN190@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Mid$2[esp+64]
	mov	edx, ebx
	call	??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$2[esp+60]
	mov	DWORD PTR __Last$1$[esp+60], ebx
$LN190@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebx
	add	esp, 8
	sub	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 128				; 00000080H
	jg	SHORT $LL2@Sort_unche
$LN165@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	esi, ebx
	je	$LN45@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Mid$1$[esp+52], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+52]
	je	$LN45@Sort_unche
	npad	7
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	edi, DWORD PTR [ebx]
	push	edi
	mov	DWORD PTR __Hole$1$[esp+60], ebx
	mov	DWORD PTR __Val$1$[esp+60], edi
	call	ebp
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, ebx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, ebx
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], edi

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN166@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	sub	ebx, esi
	mov	eax, ebx
	mov	DWORD PTR __Last$1$[esp+52], ebx
	sar	eax, 2

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, eax
	mov	DWORD PTR __Bottom$1$[esp+52], eax
	sar	ecx, 1
	test	ecx, ecx
	jle	$LN29@Sort_unche
	dec	eax
	mov	DWORD PTR tv742[esp+52], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+52], eax
	npad	3
$LL28@Sort_unche:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	edx, DWORD PTR [esi+ecx*4-4]
	dec	ecx
	mov	DWORD PTR __Hole$1$[esp+52], ecx

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, ecx
	mov	DWORD PTR __Val$1$[esp+52], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	edi, ecx

; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ecx, eax
	jge	SHORT $LN34@Sort_unche
	npad	11
$LL33@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [esi+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [esi+edi*4]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN35@Sort_unche

; 5389 :             --_Idx;

	dec	edi
$LN35@Sort_unche:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	DWORD PTR [esi+ebx*4], eax

; 5392 :         _Hole             = _Idx;

	mov	ebx, edi
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+52]
	cmp	edi, eax
	jl	SHORT $LL33@Sort_unche
	mov	ecx, DWORD PTR __Hole$1$[esp+52]
	mov	edx, DWORD PTR __Val$1$[esp+52]
$LN34@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, eax
	jne	SHORT $LN36@Sort_unche
	mov	eax, DWORD PTR __Bottom$1$[esp+52]
	test	al, 1
	jne	SHORT $LN36@Sort_unche

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR [esi+ebx*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv742[esp+52]
$LN36@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ecx, ebx
	jge	SHORT $LN40@Sort_unche
	npad	5
$LL41@Sort_unche:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	edi, DWORD PTR [ebx-1]
	sar	edi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	edx
	push	DWORD PTR [esi+edi*4]
	call	ebp
	mov	ecx, DWORD PTR __Hole$1$[esp+60]
	add	esp, 8
	test	al, al
	je	SHORT $LN40@Sort_unche

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [esi+edi*4]
	mov	edx, DWORD PTR __Val$1$[esp+52]
	mov	DWORD PTR [esi+ebx*4], eax

; 5272 :         _Hole             = _Idx;

	mov	ebx, edi
	cmp	ecx, edi
	jl	SHORT $LL41@Sort_unche
$LN40@Sort_unche:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+52]
	mov	DWORD PTR [esi+ebx*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+52]
	test	ecx, ecx
	jg	$LL28@Sort_unche
	mov	ebx, DWORD PTR __Last$1$[esp+52]
	mov	eax, DWORD PTR __Bottom$1$[esp+52]
$LN29@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	eax, 2
	jl	$LN45@Sort_unche
	npad	6
$LL46@Sort_unche:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ebx+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+52], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx+esi-4], eax
	lea	eax, DWORD PTR __Val$1[esp+52]
	push	ebp
	push	eax
	lea	eax, DWORD PTR [ebx-4]
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	ebx, 4

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, ebx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL46@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [ebx-4]
	lea	edi, DWORD PTR [ebx-4]
	push	DWORD PTR __Val$1$[esp+56]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
	mov	esi, DWORD PTR __Val$1$[esp+52]
	mov	ebx, DWORD PTR __Hole$1$[esp+52]
$LL16@Sort_unche:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	ebx, edi
	push	DWORD PTR [edi-4]
	sub	edi, 4
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
	mov	esi, DWORD PTR __First$1$[esp+52]
	mov	DWORD PTR __Hole$1$[esp+52], ebx
	mov	ebx, DWORD PTR __Mid$1$[esp+52]
$LN15@Sort_unche:

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	ecx, DWORD PTR __Hole$1$[esp+52]
	mov	eax, DWORD PTR __Val$1$[esp+52]
	mov	DWORD PTR [ecx], eax
$LN19@Sort_unche:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	ebx, 4
	mov	DWORD PTR __Mid$1$[esp+52], ebx
	cmp	ebx, DWORD PTR __Last$1$[esp+52]
	jne	$LL11@Sort_unche
$LN45@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
??$_Sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0HP6A_NPAV1@1@Z@Z ENDP ; std::_Sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@UFS_File@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@UFS_File@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 604  :     return _Old_val;
; 605  : }

	ret	0
??$exchange@PAU?$_Tree_node@UFS_File@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Freenode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z PROC ; std::_Tree_node<FS_File,void *>::_Freenode<xalloc<std::_Tree_node<FS_File,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 378  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	push	esi
	mov	esi, edx

; 379  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 380  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??1FS_File@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	esi, esi
	je	SHORT $LN15@Freenode
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN15@Freenode:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 382  :     }

	ret	0
??$_Freenode@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z ENDP ; std::_Tree_node<FS_File,void *>::_Freenode<xalloc<std::_Tree_node<FS_File,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??$_Freenode0@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z PROC ; std::_Tree_node<FS_File,void *>::_Freenode0<xalloc<std::_Tree_node<FS_File,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN8@Freenode0
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN8@Freenode0:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree

; 375  :     }

	ret	0
??$_Freenode0@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@?$_Tree_node@UFS_File@@PAX@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU01@@Z ENDP ; std::_Tree_node<FS_File,void *>::_Freenode0<xalloc<std::_Tree_node<FS_File,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU?$less@UFS_File@@@std@@@std@@YAABU?$less@UFS_File@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@UFS_File@@@std@@@std@@YAABU?$less@UFS_File@@@0@ABU10@@Z PROC ; std::forward<std::less<FS_File> const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU?$less@UFS_File@@@std@@@std@@YAABU?$less@UFS_File@@@0@ABU10@@Z ENDP ; std::forward<std::less<FS_File> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@@Z PROC ; std::_Unfancy<IDirect3DIndexBuffer9 *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUIDirect3DIndexBuffer9@@@std@@YAPAPAUIDirect3DIndexBuffer9@@PAPAU1@@Z ENDP ; std::_Unfancy<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUIDirect3DIndexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$destroy@PAUIDirect3DIndexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::destroy<IDirect3DIndexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUIDirect3DIndexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DIndexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DIndexBuffer9@@@@PAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DIndexBuffer9 *> >::destroy<IDirect3DIndexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@@Z PROC ; std::_Unfancy<IDirect3DVertexBuffer9 *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUIDirect3DVertexBuffer9@@@std@@YAPAPAUIDirect3DVertexBuffer9@@PAPAU1@@Z ENDP ; std::_Unfancy<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUIDirect3DVertexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$destroy@PAUIDirect3DVertexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::destroy<IDirect3DVertexBuffer9 *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUIDirect3DVertexBuffer9@@@?$_Normal_allocator_traits@V?$xalloc@PAUIDirect3DVertexBuffer9@@@@@std@@SAXAAV?$xalloc@PAUIDirect3DVertexBuffer9@@@@PAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IDirect3DVertexBuffer9 *> >::destroy<IDirect3DVertexBuffer9 *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@@Z PROC ; std::_Unfancy<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@PAV1@@Z ENDP ; std::_Unfancy<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
??$destroy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::destroy<svector<_D3DVERTEXELEMENT9,65> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@?$_Normal_allocator_traits@V?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@@std@@SAXAAV?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<svector<_D3DVERTEXELEMENT9,65> > >::destroy<svector<_D3DVERTEXELEMENT9,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@@Z PROC ; std::_Unfancy<resptr_core<Shader,resptrcode_shader> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@PAV1@@Z ENDP ; std::_Unfancy<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??$destroy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::destroy<resptr_core<Shader,resptrcode_shader> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<Shader,resptrcode_shader> > >::destroy<resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@UFSlideWindowItem@@@std@@YAPAUFSlideWindowItem@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@UFSlideWindowItem@@@std@@YAPAUFSlideWindowItem@@PAU1@@Z PROC ; std::_Unfancy<FSlideWindowItem>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@UFSlideWindowItem@@@std@@YAPAUFSlideWindowItem@@PAU1@@Z ENDP ; std::_Unfancy<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UFSlideWindowItem@@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$destroy@UFSlideWindowItem@@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z PROC ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::destroy<FSlideWindowItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@UFSlideWindowItem@@@?$_Normal_allocator_traits@V?$xalloc@UFSlideWindowItem@@@@@std@@SAXAAV?$xalloc@UFSlideWindowItem@@@@PAUFSlideWindowItem@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FSlideWindowItem> >::destroy<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@PAPAV1@@Z PROC ; std::_Unfancy<IRender_Portal *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVIRender_Portal@@@std@@YAPAPAVIRender_Portal@@PAPAV1@@Z ENDP ; std::_Unfancy<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVIRender_Portal@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$destroy@PAVIRender_Portal@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::destroy<IRender_Portal *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVIRender_Portal@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRender_Portal@@@@@std@@SAXAAV?$xalloc@PAVIRender_Portal@@@@PAPAVIRender_Portal@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRender_Portal *> >::destroy<IRender_Portal *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<FS_File,void *> *,std::_Tree_node<FS_File,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?reflect@?$reflector@$0CA@@detail@boost@@SAII@Z
_TEXT	SEGMENT
?reflect@?$reflector@$0CA@@detail@boost@@SAII@Z PROC	; boost::detail::reflector<32>::reflect, COMDAT
; _x$ = ecx

; 309  :     {

	push	esi

; 310  :         value_type        reflection = 0;

	xor	esi, esi
	xor	edx, edx
$LL4@reflect:

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN2@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	mov	eax, 31					; 0000001fH
	sub	eax, edx
	bts	esi, eax
$LN2@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	inc	edx
	shr	ecx, 1
	cmp	edx, 32					; 00000020H
	jb	SHORT $LL4@reflect

; 318  :             }
; 319  :         }
; 320  : 
; 321  :         return reflection;

	mov	eax, esi
	pop	esi

; 322  :     }

	ret	0
?reflect@?$reflector@$0CA@@detail@boost@@SAII@Z ENDP	; boost::detail::reflector<32>::reflect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@YAPAU_REG_INFO@@QAU1@0PAU1@AAV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@YAPAU_REG_INFO@@QAU1@0PAU1@AAV?$xalloc@U_REG_INFO@@@@@Z PROC ; std::_Uninitialized_move<_REG_INFO *,xalloc<_REG_INFO> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+8], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 12					; 0000000cH

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAU_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@YAPAU_REG_INFO@@QAU1@0PAU1@AAV?$xalloc@U_REG_INFO@@@@@Z ENDP ; std::_Uninitialized_move<_REG_INFO *,xalloc<_REG_INFO> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU_REG_INFO@@@std@@YA?A_TABQAU_REG_INFO@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU_REG_INFO@@@std@@YA?A_TABQAU_REG_INFO@@@Z PROC ; std::_Get_unwrapped<_REG_INFO * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU_REG_INFO@@@std@@YA?A_TABQAU_REG_INFO@@@Z ENDP ; std::_Get_unwrapped<_REG_INFO * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z PROC	; xr_alloc<_REG_INFO>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U_REG_INFO@@@@YAPAU_REG_INFO@@I@Z ENDP	; xr_alloc<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@U?$_Tree_node@UFS_File@@PAX@std@@@@YAPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z
_TEXT	SEGMENT
??$xr_alloc@U?$_Tree_node@UFS_File@@PAX@std@@@@YAPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z PROC ; xr_alloc<std::_Tree_node<FS_File,void *> >, COMDAT
; _count$dead$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	64					; 00000040H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@U?$_Tree_node@UFS_File@@PAX@std@@@@YAPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z ENDP ; xr_alloc<std::_Tree_node<FS_File,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEPAU_REG_INFO@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::~_Uninitialized_backout_al<xalloc<_REG_INFO> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::~_Uninitialized_backout_al<xalloc<_REG_INFO> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@PAU_REG_INFO@@AAV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@PAU_REG_INFO@@AAV?$xalloc@U_REG_INFO@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Uninitialized_backout_al<xalloc<_REG_INFO> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAE@PAU_REG_INFO@@AAV?$xalloc@U_REG_INFO@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Uninitialized_backout_al<xalloc<_REG_INFO> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?reflect@?$crc_helper@$07$00@detail@boost@@SAEE@Z
_TEXT	SEGMENT
?reflect@?$crc_helper@$07$00@detail@boost@@SAEE@Z PROC	; boost::detail::crc_helper<8,1>::reflect, COMDAT
; _x$ = cl

; 310  :         value_type        reflection = 0;

	xor	al, al

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN4@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	xor	eax, eax
	bts	eax, 7
$LN4@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN16@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 6
$LN16@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN18@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 5
$LN18@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN20@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 4
$LN20@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN22@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 3
$LN22@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN24@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 2
$LN24@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )

	shr	cl, 1

; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN26@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 1
$LN26@reflect:

; 314  :         {
; 315  :             if ( x & one )

	cmp	cl, 2
	jb	SHORT $LN28@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 0
$LN28@reflect:

; 534  :             { return detail::reflector<Bits>::reflect( x ); }

	ret	0
?reflect@?$crc_helper@$07$00@detail@boost@@SAEE@Z ENDP	; boost::detail::crc_helper<8,1>::reflect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@@Z PROC ; xalloc<IDirect3DIndexBuffer9 *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUIDirect3DIndexBuffer9@@@@QAEXPAPAUIDirect3DIndexBuffer9@@@Z ENDP ; xalloc<IDirect3DIndexBuffer9 *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@@Z PROC ; xalloc<IDirect3DVertexBuffer9 *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUIDirect3DVertexBuffer9@@@@QAEXPAPAUIDirect3DVertexBuffer9@@@Z ENDP ; xalloc<IDirect3DVertexBuffer9 *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@@QAEXPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; xalloc<svector<_D3DVERTEXELEMENT9,65> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; xalloc<resptr_core<Shader,resptrcode_shader> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@QAEXPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; xalloc<resptr_core<Shader,resptrcode_shader> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@@Z PROC ; xalloc<FSlideWindowItem>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@UFSlideWindowItem@@@@QAEXPAUFSlideWindowItem@@@Z ENDP ; xalloc<FSlideWindowItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@@Z PROC ; xalloc<IRender_Portal *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVIRender_Portal@@@@QAEXPAPAVIRender_Portal@@@Z ENDP ; xalloc<IRender_Portal *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Tree_val<std::_Tree_simple_types<FS_File> >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@UFS_File@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<FS_File> >::_Tree_val<std::_Tree_simple_types<FS_File> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@2@I@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::deallocate, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	edx, edx
	je	SHORT $LN6@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edx
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN6@deallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 561  :     }

	ret	0
?deallocate@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAU?$_Tree_node@UFS_File@@PAX@2@I@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QAE@XZ PROC ; xalloc<std::_Tree_node<FS_File,void *> >::xalloc<std::_Tree_node<FS_File,void *> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QAE@XZ ENDP ; xalloc<std::_Tree_node<FS_File,void *> >::xalloc<std::_Tree_node<FS_File,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEXPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEXPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z PROC ; xalloc<std::_Tree_node<FS_File,void *> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@QBEXPAU?$_Tree_node@UFS_File@@PAX@std@@I@Z ENDP ; xalloc<std::_Tree_node<FS_File,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAPAPAVISpatial@@QAPAV1@0P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAPAPAVISpatial@@QAPAV1@0P6A_NPAV1@1@Z@Z PROC ; std::_Insertion_sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	esi
	mov	eax, edx
	mov	esi, ecx
	mov	DWORD PTR __Last$1$[esp+12], eax
	mov	DWORD PTR __First$1$[esp+12], esi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	esi, eax
	je	SHORT $LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	push	edi
	lea	edi, DWORD PTR [esi+4]
	cmp	edi, eax
	je	SHORT $LN27@Insertion_
	push	ebx
	push	ebp
	npad	2
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);
; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	DWORD PTR [esi]
	mov	ebx, DWORD PTR [edi]
	mov	ebp, edi
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, edi

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, edi
	sub	ecx, esi
	push	ecx
	sub	eax, ecx
	add	eax, 4
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6928 :                 *_First = _STD move(_Val);

	mov	DWORD PTR [esi], ebx

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR [edi-4]
	lea	esi, DWORD PTR [edi-4]
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	2
$LL7@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax
	mov	ebp, esi
	push	DWORD PTR [esi-4]
	sub	esi, 4
	push	ebx
	call	DWORD PTR __Pred$[esp+28]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:
	mov	esi, DWORD PTR __First$1$[esp+24]

; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole

	mov	DWORD PTR [ebp], ebx
$LN10@Insertion_:

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+24]
	add	edi, 4
	cmp	edi, eax
	jne	SHORT $LL2@Insertion_

; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;

	pop	ebp
	pop	ebx
$LN27@Insertion_:
	pop	edi
$LN3@Insertion_:
	pop	esi

; 6940 : }

	add	esp, 8
	ret	0
??$_Insertion_sort_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAPAPAVISpatial@@QAPAV1@0P6A_NPAV1@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__Val$1$ = -20						; size = 4
__Max_sequence_non_leaf$1$ = -16			; size = 4
__Hole$1$ = -12						; size = 4
__Bottom$1$ = -8					; size = 4
tv268 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z PROC ; std::_Make_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	mov	eax, edx
	mov	ebx, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	eax, ebx
	sar	eax, 2
	push	ebp

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ebp, eax
	mov	DWORD PTR __Bottom$1$[esp+28], eax
	sar	ebp, 1
	test	ebp, ebp
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+24]
	dec	eax
	mov	DWORD PTR tv268[esp+28], eax
	sar	eax, 1
	push	esi
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+32], eax
	push	edi
	npad	1
$LL2@Make_heap_:

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;
; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	edx, DWORD PTR [ebx+ebp*4-4]
	dec	ebp
	mov	DWORD PTR __Hole$1$[esp+36], ebp

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	edi, ebp
	mov	DWORD PTR __Val$1$[esp+36], edx

; 5381 :     _Diff _Idx       = _Hole;

	mov	esi, ebp

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	ebp, eax
	jge	SHORT $LN8@Make_heap_
	mov	ebp, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	npad	7
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+esi*8+4]
	lea	esi, DWORD PTR [esi*2+2]
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	DWORD PTR [ebx+edi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	esi, ebp
	jl	SHORT $LL7@Make_heap_
	mov	ebp, DWORD PTR __Hole$1$[esp+36]
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	mov	edx, DWORD PTR __Val$1$[esp+36]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN10@Make_heap_
	mov	eax, DWORD PTR __Bottom$1$[esp+36]
	test	al, 1
	jne	SHORT $LN10@Make_heap_

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	edi, DWORD PTR tv268[esp+36]
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ebp, edi
	jge	SHORT $LN29@Make_heap_
	npad	1
$LL15@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	edx
	push	DWORD PTR [ebx+esi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN29@Make_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Val$1$[esp+36]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	ebp, esi
	jl	SHORT $LL15@Make_heap_
$LN29@Make_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$1$[esp+36]

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	ecx, DWORD PTR __Pred$[esp+32]

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	DWORD PTR [ebx+edi*4], eax

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	test	ebp, ebp
	jg	$LL2@Make_heap_
	pop	edi
	pop	esi
$LN3@Make_heap_:
	pop	ebp

; 5553 :     }
; 5554 : }

	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Make_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ENDP ; std::_Make_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z PROC ; std::_Sort_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, edi
	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN3@Sort_heap_
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+12]
	npad	8
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi+esi-4]

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+16], eax

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, edi
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+esi-4], eax
	lea	eax, DWORD PTR __Val$1[esp+16]
	push	ebx
	push	eax
	lea	eax, DWORD PTR [esi-4]
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	esi, 4

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL4@Sort_heap_
	pop	ebx
$LN3@Sort_heap_:
	pop	edi

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	esi
	pop	ecx
	ret	0
??$_Sort_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ENDP ; std::_Sort_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YA?AU?$pair@PAPAVISpatial@@PAPAV1@@0@PAPAVISpatial@@0P6A_NPAV2@1@Z@Z
_TEXT	SEGMENT
__Plast$1$ = -20					; size = 4
__Glast$1$ = -16					; size = 4
__First$1$ = -12					; size = 4
__Gfirst$1$ = -8					; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YA?AU?$pair@PAPAVISpatial@@PAPAV1@@0@PAPAVISpatial@@0P6A_NPAV2@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen
; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+24]
	mov	ebx, edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+32]
	mov	eax, edi
	sub	eax, ebx
	mov	DWORD PTR ___$ReturnUdt$1$[esp+36], ecx
	sar	eax, 3
	mov	ecx, ebx
	push	ebp
	mov	DWORD PTR __First$1$[esp+40], ebx
	lea	esi, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [edi-4]
	mov	edx, esi
	push	eax
	call	??$_Guess_median_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z ; std::_Guess_median_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
	add	esp, 8

; 6980 :     _RanIt _Pfirst = _Mid;
; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Plast$1$[esp+36], ebx

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+36], esi
	jae	SHORT $LN66@Partition_
	mov	ebx, DWORD PTR __First$1$[esp+36]
$LL2@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_
	push	DWORD PTR [esi-4]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN91@Partition_

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	cmp	ebx, esi
	jb	SHORT $LL2@Partition_
$LN91@Partition_:
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
$LN66@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	ebx, edi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_
	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN92@Partition_

; 6989 :         ++_Plast;

	add	ebx, 4
	cmp	ebx, edi
	jb	SHORT $LL4@Partition_
$LN92@Partition_:
	mov	DWORD PTR __Plast$1$[esp+36], ebx
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	edi, ebx

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebp, esi
$LN97@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Glast$1$[esp+36], ebp
$LN96@Partition_:
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LL6@Partition_:
	cmp	edi, DWORD PTR __Last$[esp+32]
	jae	SHORT $LN70@Partition_
	mov	ebp, DWORD PTR __Last$[esp+32]
	npad	5
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN93@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	ebx, 4
$LN9@Partition_:
	add	edi, 4
	cmp	edi, ebp
	jb	SHORT $LL11@Partition_
$LN93@Partition_:
	mov	ebp, DWORD PTR __Glast$1$[esp+36]
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	mov	DWORD PTR __Gfirst$1$[esp+36], edi
$LN70@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+36]
	cmp	ebp, eax
	jbe	SHORT $LN95@Partition_
	mov	edi, DWORD PTR __Glast$1$[esp+36]
	mov	ebx, eax
	lea	ebp, DWORD PTR [edi-4]
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	DWORD PTR [esi]
	push	DWORD PTR [ebp]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	DWORD PTR [ebp]
	push	DWORD PTR [esi]
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN94@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, ebp
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	edi, 4
	sub	ebp, 4
	cmp	ebx, edi
	jb	SHORT $LL14@Partition_
$LN94@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+36]
	mov	ebx, DWORD PTR __Plast$1$[esp+36]
	mov	DWORD PTR __Glast$1$[esp+36], edi
	mov	ebp, DWORD PTR __Glast$1$[esp+36]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebp, eax
	mov	edi, DWORD PTR __Gfirst$1$[esp+36]
$LN95@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	edi, DWORD PTR __Last$[esp+32]
	je	SHORT $LN72@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN29@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN29@Partition_:

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	add	edi, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
	jmp	$LN96@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	ebp, -4					; fffffffcH
	mov	DWORD PTR __Glast$1$[esp+36], ebp
	cmp	edi, DWORD PTR __Last$[esp+32]
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	ebp, esi
	je	SHORT $LN82@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebp], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN82@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
	mov	DWORD PTR __Plast$1$[esp+36], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	edi, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	jmp	$LN97@Partition_
$LN72@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	add	esp, 20					; 00000014H
	ret	0
??$_Partition_by_median_guess_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YA?AU?$pair@PAPAVISpatial@@PAPAV1@@0@PAPAVISpatial@@0P6A_NPAV2@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@UFS_File@@@std@@YAPAUFS_File@@AAU1@@Z
_TEXT	SEGMENT
??$addressof@UFS_File@@@std@@YAPAUFS_File@@AAU1@@Z PROC	; std::addressof<FS_File>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@UFS_File@@@std@@YAPAUFS_File@@AAU1@@Z ENDP	; std::addressof<FS_File>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@UFS_File@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAUFS_File@@@Z
_TEXT	SEGMENT
??$destroy@UFS_File@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAUFS_File@@@Z PROC ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::destroy<FS_File>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 578  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc& _Al, _Ty* _Ptr) {

	mov	ecx, edx
	jmp	DWORD PTR __imp_??1FS_File@@QAE@XZ
??$destroy@UFS_File@@@?$_Normal_allocator_traits@V?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@@std@@SAXAAV?$xalloc@U?$_Tree_node@UFS_File@@PAX@std@@@@PAUFS_File@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<std::_Tree_node<FS_File,void *> > >::destroy<FS_File>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<FS_File,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<FS_File,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<FS_File,void *> *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAPAU?$_Tree_node@UFS_File@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<FS_File,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@UFS_File@@PAX@0@@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@UFS_File@@PAX@0@@Z PROC ; std::_Voidify_iter<std::_Tree_node<FS_File,void *> * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@UFS_File@@PAX@0@@Z ENDP ; std::_Voidify_iter<std::_Tree_node<FS_File,void *> * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAABQAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAABQAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<FS_File,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAU?$_Tree_node@UFS_File@@PAX@std@@@std@@YAABQAU?$_Tree_node@UFS_File@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<FS_File,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAU_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z PROC ; std::move<_REG_INFO &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z ENDP ; std::move<_REG_INFO &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_REG_INFO@@@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEX$$QAU_REG_INFO@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_REG_INFO@@@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEX$$QAU_REG_INFO@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Emplace_back<_REG_INFO>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_REG_INFO@@@?$_Uninitialized_backout_al@V?$xalloc@U_REG_INFO@@@@@std@@QAEX$$QAU_REG_INFO@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<_REG_INFO> >::_Emplace_back<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\third-party\include\boost\crc.hpp
;	COMDAT ?reflect@?$reflector@$07@detail@boost@@SAEE@Z
_TEXT	SEGMENT
?reflect@?$reflector@$07@detail@boost@@SAEE@Z PROC	; boost::detail::reflector<8>::reflect, COMDAT
; _x$ = cl

; 310  :         value_type        reflection = 0;

	xor	al, al

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	test	cl, 1
	je	SHORT $LN2@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	xor	eax, eax
	bts	eax, 7
$LN2@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN14@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 6
$LN14@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN16@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 5
$LN16@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN18@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 4
$LN18@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN20@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 3
$LN20@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN22@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 2
$LN22@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	shr	cl, 1
	test	cl, 1
	je	SHORT $LN24@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 1
$LN24@reflect:

; 311  :         value_type const  one = 1;
; 312  : 
; 313  :         for ( std::size_t i = 0 ; i < Bits ; ++i, x >>= 1 )
; 314  :         {
; 315  :             if ( x & one )

	cmp	cl, 2
	jb	SHORT $LN26@reflect

; 316  :             {
; 317  :                 reflection |= ( one << (Bits - 1u - i) );

	movzx	eax, al
	bts	eax, 0
$LN26@reflect:

; 318  :             }
; 319  :         }
; 320  : 
; 321  :         return reflection;
; 322  :     }

	ret	0
?reflect@?$reflector@$07@detail@boost@@SAEE@Z ENDP	; boost::detail::reflector<8>::reflect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUIDirect3DIndexBuffer9@@@std@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUIDirect3DIndexBuffer9@@@std@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z PROC ; std::_Destroy_in_place<IDirect3DIndexBuffer9 * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUIDirect3DIndexBuffer9@@@std@@YAXAAPAPAUIDirect3DIndexBuffer9@@@Z ENDP ; std::_Destroy_in_place<IDirect3DIndexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUIDirect3DVertexBuffer9@@@std@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUIDirect3DVertexBuffer9@@@std@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z PROC ; std::_Destroy_in_place<IDirect3DVertexBuffer9 * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUIDirect3DVertexBuffer9@@@std@@YAXAAPAPAUIDirect3DVertexBuffer9@@@Z ENDP ; std::_Destroy_in_place<IDirect3DVertexBuffer9 * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z PROC ; std::_Destroy_in_place<svector<_D3DVERTEXELEMENT9,65> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@std@@YAXAAPAV?$svector@U_D3DVERTEXELEMENT9@@$0EB@@@@Z ENDP ; std::_Destroy_in_place<svector<_D3DVERTEXELEMENT9,65> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Destroy_in_place<resptr_core<Shader,resptrcode_shader> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAXAAPAV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Destroy_in_place<resptr_core<Shader,resptrcode_shader> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAUFSlideWindowItem@@@std@@YAXAAPAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAUFSlideWindowItem@@@std@@YAXAAPAUFSlideWindowItem@@@Z PROC ; std::_Destroy_in_place<FSlideWindowItem *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAUFSlideWindowItem@@@std@@YAXAAPAUFSlideWindowItem@@@Z ENDP ; std::_Destroy_in_place<FSlideWindowItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVIRender_Portal@@@std@@YAXAAPAPAVIRender_Portal@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVIRender_Portal@@@std@@YAXAAPAPAVIRender_Portal@@@Z PROC ; std::_Destroy_in_place<IRender_Portal * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVIRender_Portal@@@std@@YAXAAPAPAVIRender_Portal@@@Z ENDP ; std::_Destroy_in_place<IRender_Portal * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U?$_Tree_node@UFS_File@@PAX@std@@@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@std@@@Z
_TEXT	SEGMENT
??$xr_free@U?$_Tree_node@UFS_File@@PAX@std@@@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@std@@@Z PROC ; xr_free<std::_Tree_node<FS_File,void *> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U?$_Tree_node@UFS_File@@PAX@std@@@@YAXAAPAU?$_Tree_node@UFS_File@@PAX@std@@@Z ENDP ; xr_free<std::_Tree_node<FS_File,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GFS_File@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GFS_File@@QAEPAXI@Z PROC				; FS_File::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1FS_File@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	4
??_GFS_File@@QAEPAXI@Z ENDP				; FS_File::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z
_TEXT	SEGMENT
??$move@AAPAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z PROC ; std::move<ISpatial * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z ENDP ; std::move<ISpatial * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z PROC ; std::_Move_backward_unchecked<ISpatial * *,ISpatial * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4351 :     // move [_First, _Last) backwards to [..., _Dest)
; 4352 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4353 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4354 : #ifdef __cpp_lib_is_constant_evaluated
; 4355 :         if (!_STD is_constant_evaluated())
; 4356 : #endif // __cpp_lib_is_constant_evaluated
; 4357 :         {
; 4358 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4359 :         }
; 4360 :     }
; 4361 : 
; 4362 :     while (_First != _Last) {
; 4363 :         *--_Dest = _STD move(*--_Last);
; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z ENDP ; std::_Move_backward_unchecked<ISpatial * *,ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
tv234 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 8

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+4]
	push	ebx
	push	ebp
	mov	ebx, ecx
	mov	DWORD PTR __Top$1$[esp+16], edx
	lea	ecx, DWORD PTR [eax-1]
	mov	ebp, ecx
	mov	DWORD PTR tv234[esp+16], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ecx, DWORD PTR __Pred$[esp+12]
	push	esi
	mov	esi, edx
	sar	ebp, 1
	push	edi
	mov	edi, esi
	cmp	esi, ebp
	jge	SHORT $LN3@Pop_heap_h
	npad	8
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;
; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	DWORD PTR [ebx+edi*8+4]
	lea	edi, DWORD PTR [edi*2+2]
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	edi
$LN4@Pop_heap_h:

; 5390 :         }
; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5392 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	edi, ebp
	jl	SHORT $LL2@Pop_heap_h
	mov	edx, DWORD PTR __Top$1$[esp+24]
	mov	eax, DWORD PTR __Bottom$[esp+20]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	edi, ebp
	jne	SHORT $LN5@Pop_heap_h
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	mov	eax, DWORD PTR [ebx+eax*4-4]
	mov	DWORD PTR [ebx+esi*4], eax

; 5397 :         _Hole             = _Bottom - 1;

	mov	esi, DWORD PTR tv234[esp+24]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, esi
	jge	SHORT $LN20@Pop_heap_h
	mov	ebp, DWORD PTR __Val$[esp+20]
	npad	5
$LL10@Pop_heap_h:
	push	DWORD PTR [ebp]
	lea	edi, DWORD PTR [esi-1]
	sar	edi, 1
	push	DWORD PTR [ebx+edi*4]
	call	ecx
	add	esp, 8
	test	al, al
	je	SHORT $LN21@Pop_heap_h

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR __Pred$[esp+20]
	mov	DWORD PTR [ebx+esi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	DWORD PTR __Top$1$[esp+24], edi
	jl	SHORT $LL10@Pop_heap_h
$LN21@Pop_heap_h:

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	eax, DWORD PTR [ebp]
	pop	edi
	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN20@Pop_heap_h:

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+20]
	pop	edi
	mov	eax, DWORD PTR [eax]

; 5398 :     }
; 5399 : 
; 5400 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 5401 : }

	mov	DWORD PTR [ebx+esi*4], eax
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z PROC ; std::_Pop_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	sub	eax, ecx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-4]
	sub	edx, 4

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp]

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+8], eax

; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	sub	edx, ecx
	lea	eax, DWORD PTR __Val$1[esp+8]
	sar	edx, 2
	push	eax
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	ecx
	ret	0
??$_Pop_heap_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@0P6A_NPAV1@1@Z@Z ENDP ; std::_Pop_heap_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z PROC ; std::_Prev_iter<ISpatial * *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-4]

; 1555 : }

	ret	0
??$_Prev_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ENDP ; std::_Prev_iter<ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
tv426 = -8						; size = 4
tv422 = -4						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z PROC ; std::_Guess_median_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+8]
	mov	eax, ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+12]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	sub	eax, edi
	sar	eax, 2
	mov	ecx, DWORD PTR [edi]
	push	ecx
	cmp	eax, 40					; 00000028H
	jle	$LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	edx, DWORD PTR [eax*8]
	shl	eax, 2

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax+edi]

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	lea	ebx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv422[esp+32], edx
	mov	DWORD PTR tv426[esp+32], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN95@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN95@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv422[esp+24]
	push	DWORD PTR [ebx]
	push	DWORD PTR [eax+edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv422[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edx+edi]
	mov	DWORD PTR [edx+edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN8@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	edi, esi
	sub	edi, DWORD PTR tv426[esp+24]

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN96@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN96@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR tv426[esp+24]
	push	DWORD PTR [esi]
	push	DWORD PTR [eax+esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR tv426[esp+24]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR [edx+esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN25@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN25@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$[esp+20]
	mov	edi, eax
	sub	eax, DWORD PTR tv422[esp+24]
	sub	edi, DWORD PTR tv426[esp+24]
	mov	DWORD PTR __First$1$[esp+24], eax

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN97@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN97@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, DWORD PTR __Last$[esp+20]
	push	DWORD PTR [edi]
	push	DWORD PTR [eax]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	edx, DWORD PTR __Last$[esp+20]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	eax, DWORD PTR __First$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [eax]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN42@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	mov	edx, DWORD PTR __First$1$[esp+24]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], ecx
$LN42@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN98@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
$LN98@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [edi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [ebx]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [ebx]
	pop	edi
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	ebx
	add	esp, 8
	ret	0
$LN2@Guess_medi:

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN99@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN99@Guess_medi:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN76@Guess_medi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN76@Guess_medi:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6973 : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Guess_median_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z ENDP ; std::_Guess_median_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Next_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z PROC ; std::_Next_iter<ISpatial * *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+4]

; 1542 : }

	ret	0
??$_Next_iter@PAPAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ENDP ; std::_Next_iter<ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAPAVISpatial@@PAPAV1@@std@@YAXPAPAVISpatial@@0@Z
_TEXT	SEGMENT
??$iter_swap@PAPAVISpatial@@PAPAV1@@std@@YAXPAPAVISpatial@@0@Z PROC ; std::iter_swap<ISpatial * *,ISpatial * *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAPAVISpatial@@PAPAV1@@std@@YAXPAPAVISpatial@@0@Z ENDP ; std::iter_swap<ISpatial * *,ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAPAVISpatial@@AAPAPAV0@$0A@@?$pair@PAPAVISpatial@@PAPAV1@@std@@QAE@AAPAPAVISpatial@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAVISpatial@@AAPAPAV0@$0A@@?$pair@PAPAVISpatial@@PAPAV1@@std@@QAE@AAPAPAVISpatial@@0@Z PROC ; std::pair<ISpatial * *,ISpatial * *>::pair<ISpatial * *,ISpatial * *><ISpatial * * &,ISpatial * * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAPAVISpatial@@AAPAPAV0@$0A@@?$pair@PAPAVISpatial@@PAPAV1@@std@@QAE@AAPAPAVISpatial@@0@Z ENDP ; std::pair<ISpatial * *,ISpatial * *>::pair<ISpatial * *,ISpatial * *><ISpatial * * &,ISpatial * * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z
_TEXT	SEGMENT
??$forward@U_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z PROC ; std::forward<_REG_INFO>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U_REG_INFO@@@std@@YA$$QAU_REG_INFO@@AAU1@@Z ENDP ; std::forward<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_REG_INFO@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_REG_INFO@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@$$QAU3@@Z PROC ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@U_REG_INFO@@U1@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@$$QAU3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::construct<_REG_INFO,_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z PROC ; std::_Copy_backward_memmove<ISpatial * *,ISpatial * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4247 :     // implement copy_backward-like function as memmove
; 4248 :     auto _FirstPtr              = _To_address(_First);
; 4249 :     auto _LastPtr               = _To_address(_Last);
; 4250 :     auto _DestPtr               = _To_address(_Dest);
; 4251 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4252 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4253 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4254 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4255 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

	mov	eax, DWORD PTR __Dest$[esp-4]
	sub	edx, ecx
	push	edx
	push	ecx
	sub	eax, edx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 4256 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4257 :         return static_cast<_CtgIt2>(_Result);
; 4258 :     } else {
; 4259 :         return _Dest - (_LastPtr - _FirstPtr);
; 4260 :     }
; 4261 : }

	ret	0
??$_Copy_backward_memmove@PAPAVISpatial@@PAPAV1@@std@@YAPAPAVISpatial@@PAPAV1@00@Z ENDP ; std::_Copy_backward_memmove<ISpatial * *,ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVISpatial@@@std@@YA?A_PABQAPAVISpatial@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAVISpatial@@@std@@YA?A_PABQAPAVISpatial@@@Z PROC ; std::_To_address<ISpatial * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAVISpatial@@@std@@YA?A_PABQAPAVISpatial@@@Z ENDP ; std::_To_address<ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@PAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z PROC ; std::forward<ISpatial *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAVISpatial@@@std@@YA$$QAPAVISpatial@@AAPAV1@@Z ENDP ; std::forward<ISpatial *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z PROC ; std::_Push_heap_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	push	edi
	mov	edi, edx
	mov	ebx, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen
; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+4], edi
	jge	SHORT $LN10@Push_heap_
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+8]
	push	esi
$LL4@Push_heap_:
	push	DWORD PTR [ebp]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	push	DWORD PTR [ebx+esi*4]
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN11@Push_heap_

; 5269 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5270 :         // move _Hole up to parent
; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+edi*4], eax

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$[esp+12], esi
	jl	SHORT $LL4@Push_heap_
$LN11@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR [ebp]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
$LN10@Push_heap_:

; 5273 :     }
; 5274 : 
; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+edi*4], eax
	pop	edi

; 5276 : }

	pop	ebx
	ret	0
??$_Push_heap_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ENDP ; std::_Push_heap_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00$$QAPAV1@P6A_NPAV1@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00$$QAPAV1@P6A_NPAV1@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5405 :     // pop *_First to *_Dest and reheap
; 5406 :     // precondition: _First != _Last
; 5407 :     // precondition: _First != _Dest
; 5408 :     *_Dest      = _STD move(*_First);

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 5409 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 2
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@HH$$QAPAV1@P6A_NPAV1@2@Z@Z ; std::_Pop_heap_hole_by_index<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
??$_Pop_heap_hole_unchecked@PAPAVISpatial@@PAV1@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00$$QAPAV1@P6A_NPAV1@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<ISpatial * *,ISpatial *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z PROC ; std::_Med3_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	push	DWORD PTR [edi]
	push	DWORD PTR [esi]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN19@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN19@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	DWORD PTR [esi]
	push	DWORD PTR [ebx]
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	DWORD PTR [edi]
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
$LN4@Med3_unche:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAPAVISpatial@@P6A_NPAV1@0@Z@std@@YAXPAPAVISpatial@@00P6A_NPAV1@1@Z@Z ENDP ; std::_Med3_unchecked<ISpatial * *,bool (__cdecl*)(ISpatial *,ISpatial *)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@PAVISpatial@@$0A@@std@@YAXAAPAVISpatial@@0@Z
_TEXT	SEGMENT
??$swap@PAVISpatial@@$0A@@std@@YAXAAPAVISpatial@@0@Z PROC ; std::swap<ISpatial *,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 103  : }

	ret	0
??$swap@PAVISpatial@@$0A@@std@@YAXAAPAVISpatial@@0@Z ENDP ; std::swap<ISpatial *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAPAVISpatial@@@std@@YAAAPAPAVISpatial@@AAPAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAPAVISpatial@@@std@@YAAAPAPAVISpatial@@AAPAPAV1@@Z PROC ; std::forward<ISpatial * * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAPAVISpatial@@@std@@YAAAPAPAVISpatial@@AAPAPAV1@@Z ENDP ; std::forward<ISpatial * * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.h
;	COMDAT ?ps_library@CRender@@UAEPAVCPSLibrary@@XZ
_TEXT	SEGMENT
?ps_library@CRender@@UAEPAVCPSLibrary@@XZ PROC		; CRender::ps_library, COMDAT
; _this$ = ecx

; 162  : 	virtual CPSLibrary*				ps_library				(){return &PSLibrary;}

	lea	eax, DWORD PTR [ecx+956]
	ret	0
?ps_library@CRender@@UAEPAVCPSLibrary@@XZ ENDP		; CRender::ps_library
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.h
;	COMDAT ?model_Logging@CRender@@UAEXH@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 4
?model_Logging@CRender@@UAEXH@Z PROC			; CRender::model_Logging, COMDAT
; _this$ = ecx

; 176  : 	virtual void					model_Logging			(BOOL bEnable)				{ Models->Logging(bEnable);	}

	mov	ecx, DWORD PTR [ecx+1008]
	mov	eax, DWORD PTR _bEnable$[esp-4]
	mov	DWORD PTR [ecx+44], eax
	ret	4
?model_Logging@CRender@@UAEXH@Z ENDP			; CRender::model_Logging
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.h
;	COMDAT ?getShaderPath@CRender@@UAEPBDXZ
_TEXT	SEGMENT
?getShaderPath@CRender@@UAEPBDXZ PROC			; CRender::getShaderPath, COMDAT
; _this$ = ecx

; 133  : 	virtual LPCSTR					getShaderPath			()									{ return "r1\\";	}

	mov	eax, OFFSET ??_C@_03CMCKNFAL@r1?2@
	ret	0
?getShaderPath@CRender@@UAEPBDXZ ENDP			; CRender::getShaderPath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\FStaticRender.h
;	COMDAT ?get_generation@CRender@@UAE?AW4GenerationLevel@IRender_interface@@XZ
_TEXT	SEGMENT
?get_generation@CRender@@UAE?AW4GenerationLevel@IRender_interface@@XZ PROC ; CRender::get_generation, COMDAT
; _this$ = ecx

; 109  : 	virtual	GenerationLevel			get_generation			()	{ return IRender_interface::GENERATION_R1; }

	mov	eax, 81					; 00000051H
	ret	0
?get_generation@CRender@@UAE?AW4GenerationLevel@IRender_interface@@XZ ENDP ; CRender::get_generation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z
_TEXT	SEGMENT
??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z PROC	; xr_free<_REG_INFO>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@U_REG_INFO@@@@YAXAAPAU_REG_INFO@@@Z ENDP	; xr_free<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z PROC ; xalloc<_REG_INFO>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@U_REG_INFO@@@@QBEXPAU_REG_INFO@@I@Z ENDP ; xalloc<_REG_INFO>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@U_REG_INFO@@@@@std@@YAXPAU_REG_INFO@@QAU1@AAV?$xalloc@U_REG_INFO@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@U_REG_INFO@@@@@std@@YAXPAU_REG_INFO@@QAU1@AAV?$xalloc@U_REG_INFO@@@@@Z PROC ; std::_Destroy_range<xalloc<_REG_INFO> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@U_REG_INFO@@@@@std@@YAXPAU_REG_INFO@@QAU1@AAV?$xalloc@U_REG_INFO@@@@@Z ENDP ; std::_Destroy_range<xalloc<_REG_INFO> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@0@Z PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEXPAU_REG_INFO@@0@Z ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU_REG_INFO@@@std@@YAXAAPAU_REG_INFO@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU_REG_INFO@@@std@@YAXAAPAU_REG_INFO@@@Z PROC ; std::_Destroy_in_place<_REG_INFO *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU_REG_INFO@@@std@@YAXAAPAU_REG_INFO@@@Z ENDP ; std::_Destroy_in_place<_REG_INFO *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@@Z PROC ; xalloc<_REG_INFO>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@U_REG_INFO@@@@QAEXPAU_REG_INFO@@@Z ENDP ; xalloc<_REG_INFO>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_REG_INFO@@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z
_TEXT	SEGMENT
??$destroy@U_REG_INFO@@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z PROC ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::destroy<_REG_INFO>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_REG_INFO@@@?$_Normal_allocator_traits@V?$xalloc@U_REG_INFO@@@@@std@@SAXAAV?$xalloc@U_REG_INFO@@@@PAU_REG_INFO@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<_REG_INFO> >::destroy<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_REG_INFO@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_REG_INFO@@@@XZ PROC ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@U_REG_INFO@@@@V?$_Vector_val@U?$_Simple_types@U_REG_INFO@@@std@@@std@@$00@std@@QAEAAV?$xalloc@U_REG_INFO@@@@XZ ENDP ; std::_Compressed_pair<xalloc<_REG_INFO>,std::_Vector_val<std::_Simple_types<_REG_INFO> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEAAV?$xalloc@U_REG_INFO@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEAAV?$xalloc@U_REG_INFO@@@@XZ PROC ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_REG_INFO@@V?$xalloc@U_REG_INFO@@@@@std@@AAEAAV?$xalloc@U_REG_INFO@@@@XZ ENDP ; std::vector<_REG_INFO,xalloc<_REG_INFO> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_REG_INFO@@@std@@YAPAU_REG_INFO@@PAU1@@Z
_TEXT	SEGMENT
??$_Unfancy@U_REG_INFO@@@std@@YAPAU_REG_INFO@@PAU1@@Z PROC ; std::_Unfancy<_REG_INFO>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U_REG_INFO@@@std@@YAPAU_REG_INFO@@PAU1@@Z ENDP ; std::_Unfancy<_REG_INFO>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2272 :         const value_type* _Result = _Bx._Buf;
; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2278 :     }

	ret	0
$LN6@Myptr:

; 2274 :             _Result = _Unfancy(_Bx._Ptr);
; 2275 :         }
; 2276 : 
; 2277 :         return _Result;

	mov	eax, ecx

; 2278 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::c_str, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2273 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 3888 :         return _Mypair._Myval2._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3889 :     }

	ret	0
$LN8@c_str:

; 3888 :         return _Mypair._Myval2._Myptr();

	mov	eax, ecx

; 3889 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::size, COMDAT
; _this$ = ecx

; 3906 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3907 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__ArgList$ = 8						; size = 4
_vsprintf PROC						; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 1473 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1474 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
; 1475 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 787  :     constexpr allocator() noexcept {}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0

; 2251 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

	mov	eax, ecx

; 2314 : 
; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2316 : 
; 2317 :         value_type _Buf[_BUF_SIZE];
; 2318 :         pointer _Ptr;
; 2319 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2320 :     } _Bx;
; 2321 : 
; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2322 :     size_type _Mysize = 0; // current length of string

	mov	DWORD PTR [ecx+16], 0

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4561 :         auto& _My_data   = _Mypair._Myval2;
; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR [ecx], 0

; 4579 :         }
; 4580 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2263 :         value_type* _Result = _Bx._Buf;
; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2269 :     }

	ret	0
$LN6@Myptr:

; 2265 :             _Result = _Unfancy(_Bx._Ptr);
; 2266 :         }
; 2267 : 
; 2268 :         return _Result;

	mov	eax, ecx

; 2269 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	esi

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #ifdef __cpp_lib_is_constant_evaluated
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             if (_First1 == _First2) {
; 93   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.
; 94   :             }
; 95   : 
; 96   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 97   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 98   :             bool _Loop_forward = true;
; 99   : 
; 100  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 101  :                 if (_First1 == _Src) {
; 102  :                     _Loop_forward = false;
; 103  :                     break;
; 104  :                 }
; 105  :             }
; 106  : 
; 107  :             if (_Loop_forward) {
; 108  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 109  :                     _First1[_Idx] = _First2[_Idx];
; 110  :                 }
; 111  :             } else {
; 112  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 113  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];
; 114  :                 }
; 115  :             }
; 116  : 
; 117  :             return _First1;
; 118  :         }
; 119  : #endif // __cpp_lib_is_constant_evaluated
; 120  : 
; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	DWORD PTR __Count$[esp]
	mov	esi, ecx
	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 122  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 123  : 
; 124  :         return _First1;

	mov	eax, esi
	pop	esi

; 125  :     }

	ret	0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2340 :     _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlen_strin:
	int	3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__Max$ = 8						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; __Requested$ = ecx
; __Old$ = edx

; 4453 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	esi
	push	edi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, DWORD PTR __Max$[esp+4]
	or	ecx, 15					; 0000000fH
	cmp	ecx, edi

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	esi, edx
	mov	eax, edi
	shr	esi, 1
	sub	eax, esi
	cmp	edx, eax
	ja	SHORT $LN7@Calculate_

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	ecx, eax
	pop	edi
	cmovb	ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, ecx

; 4464 :     }

	pop	esi
	ret	0
$LN7@Calculate_:

; 4460 :             return _Max;

	mov	eax, edi
	pop	edi

; 4464 :     }

	pop	esi
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 696  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4621 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4622 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 44   : }

	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 3910 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3911 :         const size_type _Storage_max = // can always store small string
; 3912 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3913 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3914 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3915 :         );
; 3916 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[esp-4]

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, 2147483647				; 7fffffffH
	or	edx, 15					; 0000000fH

; 4466 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	esi

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	esi, DWORD PTR [ecx+20]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edx, eax

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN3@Calculate_

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN5@Calculate_

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 4468 :     }

	ret	4
$LN5@Calculate_:

; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	add	ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, ecx
	cmovb	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4467 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	eax, edx
$LN3@Calculate_:

; 4468 :     }

	pop	esi
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 65   :         : _Data()

	xor	eax, eax

; 66   :     {

	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	mov	DWORD PTR [ecx+8], eax

; 67   :         _Data._What = _Message;
; 68   :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
__Message$dead$ = 8					; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 65   :         : _Data()

	xor	eax, eax
	mov	DWORD PTR [ecx+8], eax

; 131  :     }

	mov	eax, ecx

; 67   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 65   :         : _Data()

	xor	eax, eax
	mov	DWORD PTR [ecx+8], eax

; 142  :     }

	mov	eax, ecx

; 67   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 72   :     {

	push	esi
	mov	esi, ecx

; 71   :         : _Data()

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ___that$[esp+4]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 91   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 72   :     {

	push	esi
	mov	esi, ecx

; 71   :         : _Data()

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR ___that$[esp+4]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 89   :     {

	push	esi
	mov	esi, ecx

; 90   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 96   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

	push	esi
	mov	esi, ecx
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Other$[esp+4]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 74   :     }

	mov	eax, esi
	pop	esi
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 315  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	sub	esp, 12					; 0000000cH

; 316  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[esp+12]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	mov	eax, ecx
	push	eax
	call	__CxxThrowException@8
$LN3@Throw_bad_:
	int	3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT
; __Bytes$ = ecx

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	edx, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	edx, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	test	edx, edx
	mov	eax, 1
	cmovne	eax, edx
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

	ret	0
$LN7@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
??2@YAPAXI@Z PROC					; operator new, COMDAT
; _size$ = ecx

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	test	ecx, ecx
	mov	eax, 1
	cmovne	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT
; __Bytes$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	test	ecx, ecx
	mov	eax, 1
	cmovne	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 80   :     }

	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT
; __Bytes$ = ecx

; 222  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 223  : #if defined(_M_IX86) || defined(_M_X64)
; 224  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 225  :     if (!_STD is_constant_evaluated())
; 226  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 227  :     {
; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	edx, DWORD PTR [ecx+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	edx, ecx
	jbe	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	test	edx, edx
	mov	eax, 1
	cmovne	eax, edx
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 239  : }

	ret	0
$LN11@Allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN3@Allocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 239  : }

	ret	0
$LN3@Allocate:

; 235  :         return _Traits::_Allocate(_Bytes);
; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax

; 239  : }

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT
; __Count$ = ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, ecx

; 66   : }

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	eax, DWORD PTR __Count$[esp-4]
	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN4@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	SHORT $LN30@allocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	test	ecx, ecx
	mov	eax, 1
	cmovne	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN13@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	ret	4
$LN13@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@allocate:

; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN5@allocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	DWORD PTR __Count$[esp-4], eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	jmp	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
$LN5@allocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 238  :     return nullptr;

	xor	eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

	ret	4
$LN30@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN28@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	esi

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #ifdef __cpp_lib_is_constant_evaluated
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // __cpp_lib_is_constant_evaluated
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	DWORD PTR __Count$[esp]
	mov	esi, ecx
	push	edx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, esi
	pop	esi

; 68   :     }

	ret	0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 3222 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	push	DWORD PTR __Ptr$[esp+8]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3223 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 3225 :             },

	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT
; __It$ = ecx

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, ecx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

	ret	0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 143  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 144  :     if (_STD is_constant_evaluated()) {
; 145  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 146  :     } else
; 147  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 148  :     {
; 149  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 150  :     }
; 151  : }

	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = 8						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4471 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebx
	push	ebp

; 4472 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4473 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4474 :         if (_New_size > max_size()) {

	mov	ebp, DWORD PTR __New_size$[esp+4]
	mov	ebx, ecx
	cmp	ebp, 2147483647				; 7fffffffH
	ja	$LN69@Reallocate

; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, ebp

; 4476 :         }
; 4477 : 
; 4478 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	DWORD PTR __Old$1$[esp+8], ecx

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	push	edi
	cmp	esi, 2147483647				; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN67@Reallocate

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN67@Reallocate

; 4460 :             return _Max;
; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN70@Reallocate
	jmp	SHORT $LN27@Reallocate
$LN67@Reallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	esi, 2147483647				; 7fffffffH
	mov	ecx, -2147483613			; 80000023H
$LN27@Reallocate:
	test	ecx, ecx
	mov	eax, 1
	cmovne	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN57@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN17@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	edi, eax
	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebp
	push	DWORD PTR _<_Args_0>$[esp+16]

; 4482 : 
; 4483 : #ifdef __cpp_lib_constexpr_string
; 4484 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 4485 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 4486 :         }
; 4487 : #endif // __cpp_lib_constexpr_string
; 4488 :         _Mypair._Myval2._Orphan_all();
; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], ebp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	edi

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [ebx+20], esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	_memcpy

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ecx, DWORD PTR __Old$1$[esp+24]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+ebp], 0

; 4491 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN60@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN57@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN60@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4499 :         return *this;

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebp

; 4500 :     }

	pop	ebx
	ret	12					; 0000000cH
$LN57@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN71@Reallocate:
$LN69@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN70@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN72@Reallocate:
$LN66@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3210 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ecx
	push	ebx

; 3211 :         // assign [_Ptr, _Ptr + _Count)
; 3212 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	ebx, DWORD PTR __Count$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[esp+16], ecx
	cmp	ebx, ecx
	ja	SHORT $LN2@assign

; 2263 :         value_type* _Result = _Bx._Buf;

	mov	edi, esi

; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2264 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

	mov	edi, DWORD PTR [esi]
$LN5@assign:

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	DWORD PTR __Ptr$[esp+16]

; 3213 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3214 :             _Mypair._Myval2._Mysize = _Count;

	mov	DWORD PTR [esi+16], ebx

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH

; 3215 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3216 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR [edi+ebx], 0

; 3227 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	8
$LN2@assign:

; 4474 :         if (_New_size > max_size()) {

	cmp	ebx, 2147483647				; 7fffffffH
	ja	$LN80@assign

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, ebx
	or	edi, 15					; 0000000fH
	push	ebp
	cmp	edi, 2147483647				; 7fffffffH

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN77@assign

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	ja	SHORT $LN77@assign

; 4460 :             return _Max;
; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [edx+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4481 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN27@assign

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	ecx, DWORD PTR [eax+35]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	ecx, eax
	jbe	$LN81@assign
	jmp	SHORT $LN37@assign
$LN77@assign:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	edi, 2147483647				; 7fffffffH
	mov	ecx, -2147483613			; 80000023H
$LN37@assign:
	test	ecx, ecx
	mov	eax, 1
	cmovne	eax, ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN67@assign

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	ebp, DWORD PTR [eax+35]
	and	ebp, -32				; ffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebp-4], eax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN26@assign
$LN27@assign:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	eax, eax
	je	SHORT $LN28@assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	ebp, eax
	jmp	SHORT $LN26@assign
$LN28@assign:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	ebp, ebp
$LN26@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebx
	push	DWORD PTR __Ptr$[esp+20]

; 4489 :         _Mypair._Myval2._Mysize = _New_size;

	mov	DWORD PTR [esi+16], ebx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	push	ebp

; 4490 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	call	_memcpy

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	eax, DWORD PTR __Old$1$[esp+32]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	add	esp, 12					; 0000000cH

; 3224 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [ebx+ebp], 0

; 4492 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@assign

; 4493 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN70@assign

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN67@assign

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN70@assign:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3220 :         return _Reallocate_for(

	mov	DWORD PTR [esi], ebp

; 3227 :     }

	mov	eax, esi
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx
	pop	ecx
	ret	8
$LN67@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN82@assign:
$LN80@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4475 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN81@assign:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN83@assign:
$LN76@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 389  :         // find length of null-terminated string
; 390  : #if _HAS_CXX17
; 391  : #ifdef __cpp_char8_t
; 392  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 393  : #if _HAS_U8_INTRINSICS
; 394  :             return __builtin_u8strlen(_First);
; 395  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 396  :             return _Primary_char_traits::length(_First);
; 397  : #endif // _HAS_U8_INTRINSICS
; 398  :         } else
; 399  : #endif // __cpp_char8_t
; 400  :         {
; 401  :             return __builtin_strlen(_First);
; 402  :         }
; 403  : #else // _HAS_CXX17
; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edx, DWORD PTR [ecx+1]
$LL3@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@length
	sub	ecx, edx
	mov	eax, ecx

; 405  : #endif // _HAS_CXX17
; 406  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 3229 :     _CONSTEXPR20_CONTAINER basic_string& assign(_In_z_ const _Elem* const _Ptr) {

	push	esi
	push	edi
	mov	esi, ecx

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL5@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@assign
	sub	eax, edi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 3231 :     }

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2483 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	esi
	mov	esi, ecx
	push	edi

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edi, DWORD PTR [eax+1]

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
$LL15@basic_stri:

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL15@basic_stri
	sub	eax, edi

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2484 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2485 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2486 :         _Tidy_init();
; 2487 :         assign(_Ptr);
; 2488 :         _Proxy._Release();
; 2489 :     }

	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2315 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2281 : #ifdef __cpp_lib_constexpr_string
; 2282 :         if (_STD is_constant_evaluated()) {
; 2283 :             return true;
; 2284 :         }
; 2285 : #endif // __cpp_lib_constexpr_string
; 2286 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 2287 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4617 :         return _Mypair._Get_first();

	mov	eax, ecx

; 4618 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 146  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 147  :     _Bytes += _Non_user_size;

	add	DWORD PTR [edx], 35			; 00000023H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 166  : }

	ret	0
$LN7@Adjust_man:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT
; __Ptr$ = ecx
; __Bytes$ = edx

; 242  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	esi

; 243  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 244  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 245  :     if (_STD is_constant_evaluated()) {
; 246  :         ::operator delete(_Ptr);
; 247  :     } else
; 248  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	esi, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, esi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN10@Deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, esi
$LN13@Deallocate:

; 252  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 253  :         }
; 254  : #endif // defined(_M_IX86) || defined(_M_X64)
; 255  :         ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	esi

; 256  :     }
; 257  : }

	ret	0
$LN10@Deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@Deallocate:
	int	3
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 796  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 798  :     }

	ret	8
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 442  :         _Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 443  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4582 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4583 :         _Mypair._Myval2._Orphan_all();
; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN21@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy_deall

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN17@Tidy_deall

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN20@Tidy_deall:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 4604 :     }

	ret	0
$LN17@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN24@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2968 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

	push	esi
	mov	esi, ecx

; 2286 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN23@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN19@basic_stri

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN22@basic_stri:

; 255  :         ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN23@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [esi], 0
	pop	esi

; 2976 :     }

	ret	0
$LN19@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN27@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrDebug.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File I:\Vitalya\mine\NSProjectX\xrCore\xrDebug.h
;	COMDAT ?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
_TEXT	SEGMENT
_temp$ = -4096						; size = 4096
___$ReturnUdt$ = 8					; size = 4
_format$ = 12						; size = 4
?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC ; make_string, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, 4100				; 00001004H
	call	__chkstk
	push	esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h

; 1392 :         int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR _format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR _format$[ebp]
	lea	eax, DWORD PTR _temp$[esp+4116]
	push	-1
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	ecx, DWORD PTR _temp$[esp+4132]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\stdio.h

; 1392 :         int const _Result = __stdio_common_vsprintf(

	add	esp, 28					; 0000001cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	edx, DWORD PTR [ecx+1]

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	DWORD PTR [esi], 0

; 4562 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
$LL21@make_strin:

; 404  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL21@make_strin
	sub	ecx, edx

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	eax, DWORD PTR _temp$[esp+4104]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File I:\Vitalya\mine\NSProjectX\xrCore\xrDebug.h

; 49   : 	return		(temp);

	mov	eax, esi

; 50   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?make_string@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; make_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVIRenderable@@@std@@YAXAAPAPAVIRenderable@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVIRenderable@@@std@@YAXAAPAPAVIRenderable@@@Z PROC ; std::_Destroy_in_place<IRenderable * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVIRenderable@@@std@@YAXAAPAPAVIRenderable@@@Z ENDP ; std::_Destroy_in_place<IRenderable * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@@Z PROC ; xalloc<IRenderable *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVIRenderable@@@@QAEXPAPAVIRenderable@@@Z ENDP ; xalloc<IRenderable *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVIRenderable@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@@Z
_TEXT	SEGMENT
??$destroy@PAVIRenderable@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@@Z PROC ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::destroy<IRenderable *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVIRenderable@@@?$_Normal_allocator_traits@V?$xalloc@PAVIRenderable@@@@@std@@SAXAAV?$xalloc@PAVIRenderable@@@@PAPAVIRenderable@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<IRenderable *> >::destroy<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVIRenderable@@@std@@YAPAPAVIRenderable@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVIRenderable@@@std@@YAPAPAVIRenderable@@PAPAV1@@Z PROC ; std::_Unfancy<IRenderable *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVIRenderable@@@std@@YAPAPAVIRenderable@@PAPAV1@@Z ENDP ; std::_Unfancy<IRenderable *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVIRenderable@@@@@std@@YAXPAPAVIRenderable@@QAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVIRenderable@@@@@std@@YAXPAPAVIRenderable@@QAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z PROC ; std::_Destroy_range<xalloc<IRenderable *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVIRenderable@@@@@std@@YAXPAPAVIRenderable@@QAPAV1@AAV?$xalloc@PAVIRenderable@@@@@Z ENDP ; std::_Destroy_range<xalloc<IRenderable *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRenderable@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRenderable@@@@XZ PROC ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVIRenderable@@@@V?$_Vector_val@U?$_Simple_types@PAVIRenderable@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVIRenderable@@@@XZ ENDP ; std::_Compressed_pair<xalloc<IRenderable *>,std::_Vector_val<std::_Simple_types<IRenderable *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEAAV?$xalloc@PAVIRenderable@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEAAV?$xalloc@PAVIRenderable@@@@XZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEAAV?$xalloc@PAVIRenderable@@@@XZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@0@Z PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@AAEXPAPAVIRenderable@@0@Z ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXXZ PROC ; std::vector<IRenderable *,xalloc<IRenderable *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@std@@QAEXXZ ENDP ; std::vector<IRenderable *,xalloc<IRenderable *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ PROC ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVIRenderable@@V?$xalloc@PAVIRenderable@@@@@@QAEXXZ ENDP ; xr_vector<IRenderable *,xalloc<IRenderable *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h
;	COMDAT ?finalize@CLightProjector@@QAEXXZ
_TEXT	SEGMENT
?finalize@CLightProjector@@QAEXXZ PROC			; CLightProjector::finalize, COMDAT
; _this$ = ecx

; 46   : 	void					finalize		()			{ receivers.clear(); taskid.clear();	}

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+36], eax
	ret	0
?finalize@CLightProjector@@QAEXXZ ENDP			; CLightProjector::finalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h
;	COMDAT ??1CPSLibrary@@QAE@XZ
_TEXT	SEGMENT
??1CPSLibrary@@QAE@XZ PROC				; CPSLibrary::~CPSLibrary, COMDAT
; _this$ = ecx

; 25   :     		 			~CPSLibrary		(){;}

	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN8@CPSLibrary
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN8@CPSLibrary:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@CPSLibrary
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN20@CPSLibrary:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h

; 25   :     		 			~CPSLibrary		(){;}

	ret	0
??1CPSLibrary@@QAE@XZ ENDP				; CPSLibrary::~CPSLibrary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVCPEDef@PS@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCPEDef@PS@@@@QAE@XZ PROC			; xalloc<PS::CPEDef *>::xalloc<PS::CPEDef *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVCPEDef@PS@@@@QAE@XZ ENDP			; xalloc<PS::CPEDef *>::xalloc<PS::CPEDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PS::CPEDef *> >::_Vector_val<std::_Simple_types<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PS::CPEDef *> >::_Vector_val<std::_Simple_types<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPEDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPEDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1>::_Compressed_pair<xalloc<PS::CPEDef *>,std::_Vector_val<std::_Simple_types<PS::CPEDef *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXXZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@AAEXXZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~vector<PS::CPEDef *,xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVCPEDef@PS@@V?$xalloc@PAVCPEDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >::~xr_vector<PS::CPEDef *,xalloc<PS::CPEDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVCPGDef@PS@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVCPGDef@PS@@@@QAE@XZ PROC			; xalloc<PS::CPGDef *>::xalloc<PS::CPGDef *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVCPGDef@PS@@@@QAE@XZ ENDP			; xalloc<PS::CPGDef *>::xalloc<PS::CPGDef *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PS::CPGDef *> >::_Vector_val<std::_Simple_types<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PS::CPGDef *> >::_Vector_val<std::_Simple_types<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVCPGDef@PS@@@@V?$_Vector_val@U?$_Simple_types@PAVCPGDef@PS@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1>::_Compressed_pair<xalloc<PS::CPGDef *>,std::_Vector_val<std::_Simple_types<PS::CPGDef *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXXZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@AAEXXZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ PROC ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~vector<PS::CPGDef *,xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@std@@QAE@XZ ENDP ; std::vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ PROC ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVCPGDef@PS@@V?$xalloc@PAVCPGDef@PS@@@@@@QAE@XZ ENDP ; xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >::~xr_vector<PS::CPGDef *,xalloc<PS::CPGDef *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h
;	COMDAT ??0CPSLibrary@@QAE@XZ
_TEXT	SEGMENT
??0CPSLibrary@@QAE@XZ PROC				; CPSLibrary::CPSLibrary, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h

; 24   : 						CPSLibrary		(){;}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\PSLibrary.h

; 24   : 						CPSLibrary		(){;}

	ret	0
??0CPSLibrary@@QAE@XZ ENDP				; CPSLibrary::CPSLibrary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1R_dsgraph_structure@@UAE@XZ
_TEXT	SEGMENT
??1R_dsgraph_structure@@UAE@XZ PROC			; R_dsgraph_structure::~R_dsgraph_structure, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+604]
	test	ecx, ecx
	je	SHORT $LN8@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+604], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+608], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+612], 0
$LN8@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+592]
	test	ecx, ecx
	je	SHORT $LN17@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+592], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+596], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+600], 0
$LN17@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+580]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN26@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+580], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+584], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+588], 0
$LN26@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+568]
	test	eax, eax
	je	SHORT $LN38@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+568], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+572], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+576], 0
$LN38@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+556]
	test	ecx, ecx
	je	SHORT $LN50@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+556], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+560], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+564], 0
$LN50@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+544]
	test	ecx, ecx
	je	SHORT $LN59@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+544], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+548], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+552], 0
$LN59@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+532]
	test	ecx, ecx
	je	SHORT $LN68@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+532], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+536], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+540], 0
$LN68@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+520]
	test	ecx, ecx
	je	SHORT $LN77@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+520], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+524], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+528], 0
$LN77@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+508]
	test	ecx, ecx
	je	SHORT $LN86@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+508], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+512], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+516], 0
$LN86@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+496]
	test	ecx, ecx
	je	SHORT $LN95@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+496], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+500], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+504], 0
$LN95@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+484]
	test	ecx, ecx
	je	SHORT $LN104@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+484], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+488], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+492], 0
$LN104@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+472]
	test	ecx, ecx
	je	SHORT $LN113@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+472], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+476], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+480], 0
$LN113@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+460]
	test	ecx, ecx
	je	SHORT $LN122@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+460], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+464], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+468], 0
$LN122@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+448]
	test	ecx, ecx
	je	SHORT $LN131@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+448], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+452], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+456], 0
$LN131@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+436]
	test	ecx, ecx
	je	SHORT $LN140@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+436], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+440], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+444], 0
$LN140@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+424]
	test	ecx, ecx
	je	SHORT $LN149@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+424], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+428], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+432], 0
$LN149@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+412]
	test	ecx, ecx
	je	SHORT $LN158@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+412], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+416], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+420], 0
$LN158@R_dsgraph_:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+400]
	test	ecx, ecx
	je	SHORT $LN167@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+400], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+404], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+408], 0
$LN167@R_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+388]
	test	ecx, ecx
	je	SHORT $LN177@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+388], 0
$LN177@R_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+376]
	test	ecx, ecx
	je	SHORT $LN189@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+376], 0
$LN189@R_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+364]
	test	ecx, ecx
	je	SHORT $LN201@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+364], 0
$LN201@R_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+352]
	lea	edi, DWORD PTR [esi+352]
	test	ecx, ecx
	je	SHORT $LN213@R_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN213@R_dsgraph_:
	mov	ebx, 2
	npad	8
$LL220@R_dsgraph_:
	sub	edi, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 118  : 		destroy	();

	mov	ecx, edi
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
	sub	ebx, 1
	jne	SHORT $LL220@R_dsgraph_
	lea	edi, DWORD PTR [ebx+2]
	lea	ebx, DWORD PTR [esi+328]
	npad	8
$LL228@R_dsgraph_:
	sub	ebx, 12					; 0000000cH
	mov	ecx, ebx
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy
	sub	edi, 1
	jne	SHORT $LL228@R_dsgraph_
	pop	edi
	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	DWORD PTR __imp_??1IRender_interface@@UAE@XZ
??1R_dsgraph_structure@@UAE@XZ ENDP			; R_dsgraph_structure::~R_dsgraph_structure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z
_TEXT	SEGMENT
_M$ = 8							; size = 4
?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z PROC ; R_dsgraph_structure::set_Transform, COMDAT
; _this$ = ecx

; 76   : 	virtual		void					set_Transform			(Fmatrix*	M	)				{ VERIFY(M);	val_pTransform = M;	}

	mov	eax, DWORD PTR _M$[esp-4]
	mov	DWORD PTR [ecx+264], eax
	ret	4
?set_Transform@R_dsgraph_structure@@UAEXPAU?$_matrix@M@@@Z ENDP ; R_dsgraph_structure::set_Transform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?set_HUD@R_dsgraph_structure@@UAEXH@Z
_TEXT	SEGMENT
_V$ = 8							; size = 4
?set_HUD@R_dsgraph_structure@@UAEXH@Z PROC		; R_dsgraph_structure::set_HUD, COMDAT
; _this$ = ecx

; 77   : 	virtual		void					set_HUD					(BOOL 		V	)				{ val_bHUD		= V;				}

	mov	eax, DWORD PTR _V$[esp-4]
	mov	DWORD PTR [ecx+268], eax
	ret	4
?set_HUD@R_dsgraph_structure@@UAEXH@Z ENDP		; R_dsgraph_structure::set_HUD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?get_HUD@R_dsgraph_structure@@UAEHXZ
_TEXT	SEGMENT
?get_HUD@R_dsgraph_structure@@UAEHXZ PROC		; R_dsgraph_structure::get_HUD, COMDAT
; _this$ = ecx

; 78   : 	virtual		BOOL					get_HUD					()								{ return		val_bHUD;			}

	mov	eax, DWORD PTR [ecx+268]
	ret	0
?get_HUD@R_dsgraph_structure@@UAEHXZ ENDP		; R_dsgraph_structure::get_HUD
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?set_Invisible@R_dsgraph_structure@@UAEXH@Z
_TEXT	SEGMENT
_V$ = 8							; size = 4
?set_Invisible@R_dsgraph_structure@@UAEXH@Z PROC	; R_dsgraph_structure::set_Invisible, COMDAT
; _this$ = ecx

; 79   : 	virtual		void					set_Invisible			(BOOL 		V	)				{ val_bInvisible= V;				}

	mov	eax, DWORD PTR _V$[esp-4]
	mov	DWORD PTR [ecx+272], eax
	ret	4
?set_Invisible@R_dsgraph_structure@@UAEXH@Z ENDP	; R_dsgraph_structure::set_Invisible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\doug_lea_memory_allocator.c
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\doug_lea_memory_allocator.c
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?memory_usage@R_dsgraph_structure@@UAEIXZ
_TEXT	SEGMENT
_mfree$1$ = -8						; size = 4
_s$1$ = -4						; size = 4
?memory_usage@R_dsgraph_structure@@UAEIXZ PROC		; R_dsgraph_structure::memory_usage, COMDAT
; _this$ = ecx

; 157  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\doug_lea_memory_allocator.c

; 2792 :     if (is_initialized(m)) {

	mov	edx, DWORD PTR __gm_+24
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 157  : 	{

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\doug_lea_memory_allocator.c

; 2792 :     if (is_initialized(m)) {

	test	edx, edx
	je	$LN26@memory_usa

; 2793 :       size_t nfree = SIZE_T_ONE; /* top always free */
; 2794 :       size_t mfree = m->topsize + TOP_FOOT_SIZE;

	mov	ecx, DWORD PTR __gm_+12

; 2795 :       size_t sum = mfree;
; 2796 :       msegmentptr s = &m->seg;

	mov	edi, OFFSET __gm_+440
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _s$1$[esp+24], edi
	mov	DWORD PTR _mfree$1$[esp+24], ecx
$LL6@memory_usa:

; 2797 :       while (s != 0) {
; 2798 :         mchunkptr q = align_as_chunk(s->base);

	mov	esi, DWORD PTR [edi]
	mov	eax, esi
	and	eax, 7
	je	SHORT $LN17@memory_usa
$LN16@memory_usa:
	neg	eax
	and	eax, 7
$LN17@memory_usa:
	add	eax, esi

; 2799 :         while (segment_holds(s, q) &&
; 2800 :                q != m->top && q->head != FENCEPOST_HEAD) {

	cmp	eax, esi
	jb	SHORT $LN9@memory_usa
	mov	edi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _mfree$1$[esp+24]
	add	edi, esi
	npad	3
$LL8@memory_usa:
	cmp	eax, edi
	jae	SHORT $LN27@memory_usa
	cmp	eax, edx
	je	SHORT $LN27@memory_usa
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, 7
	je	SHORT $LN27@memory_usa

; 2801 :           size_t sz = chunksize(q);
; 2802 :           sum += sz;
; 2803 :           if (!cinuse(q)) {
; 2804 :             mfree += sz;
; 2805 :             ++nfree;
; 2806 :           }
; 2807 :           q = next_chunk(q);

	mov	ecx, ebx
	mov	edx, ebx
	and	ecx, -4					; fffffffcH
	and	edx, -4					; fffffffcH
	add	eax, ecx
	test	bl, 2
	mov	ebx, DWORD PTR _mfree$1$[esp+24]
	lea	ecx, DWORD PTR [edx+ebx]
	mov	edx, DWORD PTR __gm_+24
	cmovne	ecx, ebx
	mov	DWORD PTR _mfree$1$[esp+24], ecx
	cmp	eax, esi
	jae	SHORT $LL8@memory_usa
$LN27@memory_usa:
	mov	edi, DWORD PTR _s$1$[esp+24]
$LN9@memory_usa:

; 2808 :         }
; 2809 :         s = s->next;

	mov	edi, DWORD PTR [edi+8]
	mov	DWORD PTR _s$1$[esp+24], edi
	test	edi, edi
	jne	SHORT $LL6@memory_usa

; 2810 :       }
; 2811 : 
; 2812 :       nm.arena    = sum;
; 2813 :       nm.ordblks  = nfree;
; 2814 :       nm.hblkhd   = m->footprint - sum;
; 2815 :       nm.usmblks  = m->max_footprint;
; 2816 :       nm.uordblks = m->footprint - mfree;

	mov	eax, DWORD PTR __gm_+428
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 163  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@memory_usa:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?memory_usage@R_dsgraph_structure@@UAEIXZ ENDP		; R_dsgraph_structure::memory_usage
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GR_dsgraph_structure@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GR_dsgraph_structure@@UAEPAXI@Z PROC			; R_dsgraph_structure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1R_dsgraph_structure@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	628					; 00000274H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GR_dsgraph_structure@@UAEPAXI@Z ENDP			; R_dsgraph_structure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0

; 114  : 		limit	= 0;
; 115  : 		nodes	= 0; 
; 116  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0mapNormalVS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??0mapNormalVS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapNormalVS::mapNormalVS, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx

; 114  : 		limit	= 0;

	mov	DWORD PTR [ecx+8], 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR [ecx], 0
	ret	0
??0mapNormalVS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapNormalVS::mapNormalVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy
??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1mapNormalVS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalVS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapNormalVS::~mapNormalVS, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy
??1mapNormalVS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapNormalVS::~mapNormalVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0

; 114  : 		limit	= 0;
; 115  : 		nodes	= 0; 
; 116  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0mapMatrixVS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??0mapMatrixVS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapMatrixVS::mapMatrixVS, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx

; 114  : 		limit	= 0;

	mov	DWORD PTR [ecx+8], 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR [ecx], 0
	ret	0
??0mapMatrixVS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapMatrixVS::mapMatrixVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
??1?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::~FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1mapMatrixVS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixVS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapMatrixVS::~mapMatrixVS, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
??1mapMatrixVS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapMatrixVS::~mapMatrixVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0

; 114  : 		limit	= 0;
; 115  : 		nodes	= 0; 
; 116  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	esi
	mov	esi, ecx

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN7@FixedMAP:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	ret	0
??1?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??0?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 113  : 		pool	= 0;

	mov	DWORD PTR [ecx+4], 0

; 114  : 		limit	= 0;
; 115  : 		nodes	= 0; 
; 116  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	esi
	mov	esi, ecx

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN7@FixedMAP:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	ret	0
??1?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::~FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ PROC ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@QAE@XZ ENDP ; doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>::doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@V?$_Vector_val@U?$_Simple_types@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1>::_Compressed_pair<doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *>,std::_Vector_val<std::_Simple_types<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@AAEXXZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ PROC ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@std@@QAE@XZ ENDP ; std::vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ PROC ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@V?$doug_lea_alloc@PAUTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@@@@@QAE@XZ ENDP ; xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >::~xr_vector<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *,doug_lea_alloc<FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAE@XZ PROC	; doug_lea_alloc<R_dsgraph::_LodItem>::doug_lea_alloc<R_dsgraph::_LodItem>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAE@XZ ENDP	; doug_lea_alloc<R_dsgraph::_LodItem>::doug_lea_alloc<R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::~xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@H@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@H@@QAE@XZ PROC			; doug_lea_alloc<int>::doug_lea_alloc<int>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@H@@QAE@XZ ENDP			; doug_lea_alloc<int>::doug_lea_alloc<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ PROC	; std::vector<int,doug_lea_alloc<int> >::vector<int,doug_lea_alloc<int> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ ENDP	; std::vector<int,doug_lea_alloc<int> >::vector<int,doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ PROC	; xr_vector<int,doug_lea_alloc<int> >::xr_vector<int,doug_lea_alloc<int> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ ENDP	; xr_vector<int,doug_lea_alloc<int> >::xr_vector<int,doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXXZ PROC	; std::vector<int,doug_lea_alloc<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXXZ ENDP	; std::vector<int,doug_lea_alloc<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ PROC	; std::vector<int,doug_lea_alloc<int> >::~vector<int,doug_lea_alloc<int> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@HV?$doug_lea_alloc@H@@@std@@QAE@XZ ENDP	; std::vector<int,doug_lea_alloc<int> >::~vector<int,doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ PROC	; xr_vector<int,doug_lea_alloc<int> >::~xr_vector<int,doug_lea_alloc<int> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@HV?$doug_lea_alloc@H@@@@QAE@XZ ENDP	; xr_vector<int,doug_lea_alloc<int> >::~xr_vector<int,doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVISpatial@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVISpatial@@@@QAE@XZ PROC			; xalloc<ISpatial *>::xalloc<ISpatial *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVISpatial@@@@QAE@XZ ENDP			; xalloc<ISpatial *>::xalloc<ISpatial *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<ISpatial *> >::_Vector_val<std::_Simple_types<ISpatial *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<ISpatial *> >::_Vector_val<std::_Simple_types<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::vector<ISpatial *,xalloc<ISpatial *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::vector<ISpatial *,xalloc<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::xr_vector<ISpatial *,xalloc<ISpatial *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::xr_vector<ISpatial *,xalloc<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVISpatial@@@@YAXAAPAPAVISpatial@@@Z
_TEXT	SEGMENT
??$xr_free@PAVISpatial@@@@YAXAAPAPAVISpatial@@@Z PROC	; xr_free<ISpatial *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVISpatial@@@@YAXAAPAPAVISpatial@@@Z ENDP	; xr_free<ISpatial *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVISpatial@@@@QBEXPAPAVISpatial@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVISpatial@@@@QBEXPAPAVISpatial@@I@Z PROC ; xalloc<ISpatial *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVISpatial@@@@QBEXPAPAVISpatial@@I@Z ENDP ; xalloc<ISpatial *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXXZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXXZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::~vector<ISpatial *,xalloc<ISpatial *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAE@XZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::~vector<ISpatial *,xalloc<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::~xr_vector<ISpatial *,xalloc<ISpatial *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAE@XZ ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::~xr_vector<ISpatial *,xalloc<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??0?$doug_lea_alloc@PAVIRender_Visual@@@@QAE@XZ
_TEXT	SEGMENT
??0?$doug_lea_alloc@PAVIRender_Visual@@@@QAE@XZ PROC	; doug_lea_alloc<IRender_Visual *>::doug_lea_alloc<IRender_Visual *>, COMDAT
; _this$ = ecx

; 29   : 														doug_lea_alloc	()										{	}

	mov	eax, ecx
	ret	0
??0?$doug_lea_alloc@PAVIRender_Visual@@@@QAE@XZ ENDP	; doug_lea_alloc<IRender_Visual *>::doug_lea_alloc<IRender_Visual *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$doug_lea_alloc@PAVIRender_Visual@@@@V?$_Vector_val@U?$_Simple_types@PAVIRender_Visual@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1>::_Compressed_pair<doug_lea_alloc<IRender_Visual *>,std::_Vector_val<std::_Simple_types<IRender_Visual *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ PROC ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@AAEXXZ PROC ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@AAEXXZ ENDP ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ PROC ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@std@@QAE@XZ ENDP ; std::vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ PROC ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVIRender_Visual@@V?$doug_lea_alloc@PAVIRender_Visual@@@@@@QAE@XZ ENDP ; xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >::~xr_vector<IRender_Visual *,doug_lea_alloc<IRender_Visual *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?r_pmask@R_dsgraph_structure@@QAEX_N00@Z
_TEXT	SEGMENT
__1$dead$ = 8						; size = 1
__2$ = 12						; size = 1
__wm$dead$ = 16						; size = 1
?r_pmask@R_dsgraph_structure@@QAEX_N00@Z PROC		; R_dsgraph_structure::r_pmask, COMDAT
; _this$ = ecx

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	al, BYTE PTR __2$[esp-4]
	mov	BYTE PTR [ecx+300], 1
	mov	BYTE PTR [ecx+301], al
	mov	BYTE PTR [ecx+302], 0
	ret	12					; 0000000cH
?r_pmask@R_dsgraph_structure@@QAEX_N00@Z ENDP		; R_dsgraph_structure::r_pmask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ??0R_dsgraph_structure@@QAE@XZ
_TEXT	SEGMENT
??0R_dsgraph_structure@@QAE@XZ PROC			; R_dsgraph_structure::R_dsgraph_structure, COMDAT
; _this$dead$ = ecx

; 85   : 	R_dsgraph_structure	()

	mov	DWORD PTR ?RImplementation@@3VCRender@@A, OFFSET ??_7R_dsgraph_structure@@6BIRender_interface@@@
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+256, OFFSET ??_7R_dsgraph_structure@@6BpureFrame@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+308, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+312, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+304, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+320, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+324, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+316, 0

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+332, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+336, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+328, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+344, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+348, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+340, 0

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+356, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+360, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+352, 0

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+368, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+372, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+364, 0

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+380, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+384, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+376, 0

; 113  : 		pool	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+392, 0

; 114  : 		limit	= 0;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+396, 0

; 115  : 		nodes	= 0; 

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+388, 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+400, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+404, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+408, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+412, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+416, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+420, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+424, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+428, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+432, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+436, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+440, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+444, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+448, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+452, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+456, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+460, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+464, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+468, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+472, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+476, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+480, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+484, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+488, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+492, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+496, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+500, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+504, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+508, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+512, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+516, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+520, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+524, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+528, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+532, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+536, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+540, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+544, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+548, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+552, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+556, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+560, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+564, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+568, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+572, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+576, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+580, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+584, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+588, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+592, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+596, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+600, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+604, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+608, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+612, 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 87   : 		val_pObject			= NULL	;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+260, 0

; 88   : 		val_pTransform		= NULL	;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+264, 0

; 98   : 	};

	mov	eax, OFFSET ?RImplementation@@3VCRender@@A ; RImplementation
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+272, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+276, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+280, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+284, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+288, 0
	mov	DWORD PTR ?RImplementation@@3VCRender@@A+296, 0

; 139  : 	void		r_pmask											(bool _1, bool _2, bool _wm=false)				{ pmask[0]=_1; pmask[1]=_2;	pmask_wmark = _wm; }

	mov	WORD PTR ?RImplementation@@3VCRender@@A+300, 257 ; 00000101H
	mov	BYTE PTR ?RImplementation@@3VCRender@@A+302, 0

; 89   : 		val_bHUD			= FALSE	;
; 90   : 		val_bInvisible		= FALSE	;
; 91   : 		val_bRecordMP		= FALSE	;
; 92   : 		val_feedback		= 0;
; 93   : 		val_feedback_breakp	= 0;
; 94   : 		val_recorder		= 0;
; 95   : 		marker				= 0;
; 96   : 		r_pmask				(true,true);
; 97   : 		b_loaded			= FALSE	;

	mov	DWORD PTR ?RImplementation@@3VCRender@@A+624, 0

; 98   : 	};

	ret	0
??0R_dsgraph_structure@@QAE@XZ ENDP			; R_dsgraph_structure::R_dsgraph_structure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\hom.h
;	COMDAT ?occlude@CHOM@@QAEXAAV?$_box2@M@@@Z
_TEXT	SEGMENT
_space$dead$ = 8					; size = 4
?occlude@CHOM@@QAEXAAV?$_box2@M@@@Z PROC		; CHOM::occlude, COMDAT
; _this$dead$ = ecx

; 38   : 	void					occlude		(Fbox2&		space) { }

	ret	4
?occlude@CHOM@@QAEXAAV?$_box2@M@@@Z ENDP		; CHOM::occlude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEAAUShader@@XZ
_TEXT	SEGMENT
??D?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEAAUShader@@XZ PROC ; resptr_core<Shader,resptrcode_shader>::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@UShader@@Uresptrcode_shader@@@@QBEAAUShader@@XZ ENDP ; resptr_core<Shader,resptrcode_shader>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVISpatial@@@std@@YAXAAPAPAVISpatial@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVISpatial@@@std@@YAXAAPAPAVISpatial@@@Z PROC ; std::_Destroy_in_place<ISpatial * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVISpatial@@@std@@YAXAAPAPAVISpatial@@@Z ENDP ; std::_Destroy_in_place<ISpatial * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVISpatial@@@@QAEXPAPAVISpatial@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVISpatial@@@@QAEXPAPAVISpatial@@@Z PROC ; xalloc<ISpatial *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVISpatial@@@@QAEXPAPAVISpatial@@@Z ENDP ; xalloc<ISpatial *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVISpatial@@@?$_Normal_allocator_traits@V?$xalloc@PAVISpatial@@@@@std@@SAXAAV?$xalloc@PAVISpatial@@@@PAPAVISpatial@@@Z
_TEXT	SEGMENT
??$destroy@PAVISpatial@@@?$_Normal_allocator_traits@V?$xalloc@PAVISpatial@@@@@std@@SAXAAV?$xalloc@PAVISpatial@@@@PAPAVISpatial@@@Z PROC ; std::_Normal_allocator_traits<xalloc<ISpatial *> >::destroy<ISpatial *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVISpatial@@@?$_Normal_allocator_traits@V?$xalloc@PAVISpatial@@@@@std@@SAXAAV?$xalloc@PAVISpatial@@@@PAPAVISpatial@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<ISpatial *> >::destroy<ISpatial *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z PROC ; std::_Unfancy<ISpatial *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVISpatial@@@std@@YAPAPAVISpatial@@PAPAV1@@Z ENDP ; std::_Unfancy<ISpatial *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVISpatial@@@@@std@@YAXPAPAVISpatial@@QAPAV1@AAV?$xalloc@PAVISpatial@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVISpatial@@@@@std@@YAXPAPAVISpatial@@QAPAV1@AAV?$xalloc@PAVISpatial@@@@@Z PROC ; std::_Destroy_range<xalloc<ISpatial *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVISpatial@@@@@std@@YAXPAPAVISpatial@@QAPAV1@AAV?$xalloc@PAVISpatial@@@@@Z ENDP ; std::_Destroy_range<xalloc<ISpatial *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVISpatial@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVISpatial@@@@XZ PROC ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVISpatial@@@@V?$_Vector_val@U?$_Simple_types@PAVISpatial@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVISpatial@@@@XZ ENDP ; std::_Compressed_pair<xalloc<ISpatial *>,std::_Vector_val<std::_Simple_types<ISpatial *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEAAV?$xalloc@PAVISpatial@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEAAV?$xalloc@PAVISpatial@@@@XZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEAAV?$xalloc@PAVISpatial@@@@XZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXPAPAVISpatial@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXPAPAVISpatial@@0@Z PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@AAEXPAPAVISpatial@@0@Z ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAEXXZ PROC ; std::vector<ISpatial *,xalloc<ISpatial *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@std@@QAEXXZ ENDP ; std::vector<ISpatial *,xalloc<ISpatial *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ PROC ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAVISpatial@@V?$xalloc@PAVISpatial@@@@@@QAEXXZ ENDP ; xr_vector<ISpatial *,xalloc<ISpatial *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXXZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@AAEXXZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U_NormalItem@R_dsgraph@@V?$doug_lea_alloc@U_NormalItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >::~xr_vector<R_dsgraph::_NormalItem,doug_lea_alloc<R_dsgraph::_NormalItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1mapNormalItems@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalItems@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapNormalItems::~mapNormalItems, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@mapNormalI
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN8@mapNormalI:
	pop	esi
	ret	0
??1mapNormalItems@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapNormalItems::~mapNormalItems
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1TNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN10@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN10@TNode:
	pop	esi
	ret	0
??1TNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN17@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN17@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN3@destroy
	npad	3
$LL4@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN21@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN21@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL4@destroy
	mov	esi, edx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	esi
	ret	0
?destroy@?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN5@FixedMAP
	npad	3
$LL6@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN23@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN23@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL6@FixedMAP
	mov	esi, edx
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN7@FixedMAP:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	esi
	ret	0
??1?$FixedMAP@PAUSTextureList@@UmapNormalItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapNormalItems,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapNormalTextures@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalTextures@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapNormalTextures::~mapNormalTextures, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN9@mapNormalT

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN7@mapNormalT
	npad	3
$LL8@mapNormalT:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN25@mapNormalT
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN25@mapNormalT:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL8@mapNormalT
	mov	esi, edx
$LN7@mapNormalT:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN9@mapNormalT:
	pop	edi
	pop	esi
	ret	0
??1mapNormalTextures@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapNormalTextures::~mapNormalTextures
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN9@TNode
	npad	2
$LL10@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN27@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN27@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL10@TNode
	mov	esi, edx
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN11@TNode:
	pop	edi
	pop	esi
	ret	0
??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN40@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN12@scalar
	npad	2
$LL13@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN30@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN30@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL13@scalar
	mov	esi, edx
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN40@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebx
	mov	ebx, ecx
	push	edi

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN3@destroy
	push	esi
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN56@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN53@destroy
$LL21@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN38@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN38@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL21@destroy
	jmp	SHORT $LN20@destroy
$LN53@destroy:
	mov	edx, esi
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN56@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL4@destroy
	mov	edi, edx
	pop	esi
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebx
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	ebx
	mov	ebx, ecx
	push	edi

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN5@FixedMAP
	push	esi
$LL6@FixedMAP:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN58@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN55@FixedMAP
$LL23@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN40@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN40@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL23@FixedMAP
	jmp	SHORT $LN22@FixedMAP
$LN55@FixedMAP:
	mov	edx, esi
$LN22@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN58@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL6@FixedMAP
	mov	edi, edx
	pop	esi
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN7@FixedMAP:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	ebx
	ret	0
??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapNormalTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapNormalTextures,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapNormalStates@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalStates@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapNormalStates::~mapNormalStates, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN9@mapNormalS

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN7@mapNormalS
	push	esi
$LL8@mapNormalS:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN60@mapNormalS

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN57@mapNormalS
$LL25@mapNormalS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN42@mapNormalS
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN42@mapNormalS:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL25@mapNormalS
	jmp	SHORT $LN24@mapNormalS
$LN57@mapNormalS:
	mov	edx, esi
$LN24@mapNormalS:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN60@mapNormalS:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL8@mapNormalS
	mov	edi, edx
	pop	esi
$LN7@mapNormalS:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN9@mapNormalS:
	pop	edi
	pop	ebx
	ret	0
??1mapNormalStates@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapNormalStates::~mapNormalStates
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN9@TNode
	push	esi
$LL10@TNode:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN62@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN59@TNode
$LL27@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN44@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN44@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL27@TNode
	jmp	SHORT $LN26@TNode
$LN59@TNode:
	mov	edx, esi
$LN26@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN62@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL10@TNode
	mov	edi, edx
	pop	esi
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN11@TNode:
	pop	edi
	pop	ebx
	ret	0
??1TNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN66@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN12@scalar
	push	esi
$LL13@scalar:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN65@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN62@scalar
$LL30@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN47@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN47@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL30@scalar
	jmp	SHORT $LN29@scalar
$LN62@scalar:
	mov	edx, esi
$LN29@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN65@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL13@scalar
	mov	edi, edx
	pop	esi
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN66@scalar:
	pop	edi
	mov	eax, ebx
	pop	ebx
	ret	4
??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebx
	push	ebp
	mov	ebp, ecx

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN3@destroy
	push	esi
	push	edi
	npad	8
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN81@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN75@destroy
$LL21@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN82@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN77@destroy
	npad	4
$LL38@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN55@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN55@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL38@destroy
	jmp	SHORT $LN37@destroy
$LN77@destroy:
	mov	edx, esi
$LN37@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN82@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL21@destroy
	jmp	SHORT $LN20@destroy
$LN75@destroy:
	mov	edx, edi
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN81@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL4@destroy
	pop	edi
	mov	ebx, edx
	pop	esi
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN5@destroy:
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebx
	ret	0
?destroy@?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN5@FixedMAP
	push	esi
	push	edi
	npad	8
$LL6@FixedMAP:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN83@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN77@FixedMAP
$LL23@FixedMAP:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN84@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN79@FixedMAP
	npad	4
$LL40@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN57@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN57@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL40@FixedMAP
	jmp	SHORT $LN39@FixedMAP
$LN79@FixedMAP:
	mov	edx, esi
$LN39@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN84@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL23@FixedMAP
	jmp	SHORT $LN22@FixedMAP
$LN77@FixedMAP:
	mov	edx, edi
$LN22@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN83@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL6@FixedMAP
	pop	edi
	mov	ebx, edx
	pop	esi
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN7@FixedMAP:
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	ebx
	ret	0
??1?$FixedMAP@PAVR_constant_table@@UmapNormalStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapNormalStates,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapNormalCS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalCS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapNormalCS::~mapNormalCS, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN9@mapNormalC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN7@mapNormalC
	push	esi
	push	edi
	npad	8
$LL8@mapNormalC:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN85@mapNormalC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN79@mapNormalC
$LL25@mapNormalC:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN86@mapNormalC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN81@mapNormalC
	npad	4
$LL42@mapNormalC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN59@mapNormalC
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN59@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL42@mapNormalC
	jmp	SHORT $LN41@mapNormalC
$LN81@mapNormalC:
	mov	edx, esi
$LN41@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN86@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL25@mapNormalC
	jmp	SHORT $LN24@mapNormalC
$LN79@mapNormalC:
	mov	edx, edi
$LN24@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN85@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL8@mapNormalC
	pop	edi
	mov	ebx, edx
	pop	esi
$LN7@mapNormalC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN9@mapNormalC:
	pop	ebp
	pop	ebx
	ret	0
??1mapNormalCS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapNormalCS::~mapNormalCS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN9@TNode
	push	esi
	push	edi
	npad	8
$LL10@TNode:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN87@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN81@TNode
$LL27@TNode:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN88@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN83@TNode
	npad	4
$LL44@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN61@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN61@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL44@TNode
	jmp	SHORT $LN43@TNode
$LN83@TNode:
	mov	edx, esi
$LN43@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN88@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL27@TNode
	jmp	SHORT $LN26@TNode
$LN81@TNode:
	mov	edx, edi
$LN26@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN87@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL10@TNode
	pop	edi
	mov	ebx, edx
	pop	esi
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN11@TNode:
	pop	ebp
	pop	ebx
	ret	0
??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN92@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN12@scalar
	push	esi
	push	edi
	npad	8
$LL13@scalar:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN90@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN84@scalar
$LL30@scalar:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN91@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN86@scalar
	npad	4
$LL47@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN64@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN64@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL47@scalar
	jmp	SHORT $LN46@scalar
$LN86@scalar:
	mov	edx, esi
$LN46@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN91@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL30@scalar
	jmp	SHORT $LN29@scalar
$LN84@scalar:
	mov	edx, edi
$LN29@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN90@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL13@scalar
	pop	edi
	mov	ebx, edx
	pop	esi
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN92@scalar:
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[esp+12], esi

; 122  : 		if (nodes) {

	mov	ebp, DWORD PTR [esi]
	test	ebp, ebp
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ecx*4]
	add	eax, ebp

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebp, eax
	je	$LN3@destroy
	push	ebx
	push	edi
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN106@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN97@destroy
$LL21@destroy:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN107@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN99@destroy
$LL38@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN108@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN101@destroy
$LL55@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN72@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN72@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL55@destroy
	jmp	SHORT $LN54@destroy
$LN101@destroy:
	mov	edx, esi
$LN54@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN108@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL38@destroy
	jmp	SHORT $LN37@destroy
$LN99@destroy:
	mov	edx, edi
$LN37@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN107@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL21@destroy
	mov	esi, DWORD PTR _this$1$[esp+20]
	jmp	SHORT $LN20@destroy
$LN97@destroy:
	mov	edx, ebx
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN106@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [esi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebp, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebp, eax
	jne	$LL4@destroy
	pop	edi
	mov	ebp, edx
	pop	ebx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebp
	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN5@destroy:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebp
	pop	ecx
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1mapNormalPS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapNormalPS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapNormalPS::~mapNormalPS, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
??1mapNormalPS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapNormalPS::~mapNormalPS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
	add	ecx, 4

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+4]
	call	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy
	mov	eax, esi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN3@destroy
	npad	3
$LL4@destroy:

; 118  : 		destroy	();

	lea	ecx, DWORD PTR [esi+4]
	call	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapNormalCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapNormalCS,doug_lea_allocator>::destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL4@destroy
	mov	esi, edx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	esi
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@AAEXXZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ PROC ; xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@U_MatrixItem@R_dsgraph@@V?$doug_lea_alloc@U_MatrixItem@R_dsgraph@@@@@@QAE@XZ ENDP ; xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >::~xr_vector<R_dsgraph::_MatrixItem,doug_lea_alloc<R_dsgraph::_MatrixItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1mapMatrixItems@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixItems@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapMatrixItems::~mapMatrixItems, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@mapMatrixI
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN8@mapMatrixI:
	pop	esi
	ret	0
??1mapMatrixItems@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapMatrixItems::~mapMatrixItems
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1TNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN10@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN10@TNode:
	pop	esi
	ret	0
??1TNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_GTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN17@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN17@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN3@destroy
	npad	3
$LL4@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN21@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN21@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL4@destroy
	mov	esi, edx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	esi
	ret	0
?destroy@?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN5@FixedMAP
	npad	3
$LL6@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN23@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN23@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL6@FixedMAP
	mov	esi, edx
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN7@FixedMAP:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	esi
	ret	0
??1?$FixedMAP@PAUSTextureList@@UmapMatrixItems@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>::~FixedMAP<STextureList *,R_dsgraph::mapMatrixItems,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapMatrixTextures@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixTextures@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapMatrixTextures::~mapMatrixTextures, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN9@mapMatrixT

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN7@mapMatrixT
	npad	3
$LL8@mapMatrixT:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN25@mapMatrixT
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN25@mapMatrixT:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL8@mapMatrixT
	mov	esi, edx
$LN7@mapMatrixT:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN9@mapMatrixT:
	pop	edi
	pop	esi
	ret	0
??1mapMatrixTextures@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapMatrixTextures::~mapMatrixTextures
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN9@TNode
	npad	2
$LL10@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN27@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN27@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL10@TNode
	mov	esi, edx
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN11@TNode:
	pop	edi
	pop	esi
	ret	0
??1TNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN40@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN12@scalar
	npad	2
$LL13@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN30@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN30@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL13@scalar
	mov	esi, edx
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN40@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebx
	mov	ebx, ecx
	push	edi

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN3@destroy
	push	esi
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN56@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN53@destroy
$LL21@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN38@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN38@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL21@destroy
	jmp	SHORT $LN20@destroy
$LN53@destroy:
	mov	edx, esi
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN56@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL4@destroy
	mov	edi, edx
	pop	esi
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebx
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	ebx
	mov	ebx, ecx
	push	edi

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN5@FixedMAP
	push	esi
$LL6@FixedMAP:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN58@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN55@FixedMAP
$LL23@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN40@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN40@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL23@FixedMAP
	jmp	SHORT $LN22@FixedMAP
$LN55@FixedMAP:
	mov	edx, esi
$LN22@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN58@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL6@FixedMAP
	mov	edi, edx
	pop	esi
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN7@FixedMAP:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	ebx
	ret	0
??1?$FixedMAP@PAUIDirect3DStateBlock9@@UmapMatrixTextures@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>::~FixedMAP<IDirect3DStateBlock9 *,R_dsgraph::mapMatrixTextures,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapMatrixStates@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixStates@R_dsgraph@@QAE@XZ PROC		; R_dsgraph::mapMatrixStates::~mapMatrixStates, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	$LN9@mapMatrixS

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN7@mapMatrixS
	push	esi
$LL8@mapMatrixS:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN60@mapMatrixS

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN57@mapMatrixS
$LL25@mapMatrixS:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN42@mapMatrixS
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN42@mapMatrixS:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL25@mapMatrixS
	jmp	SHORT $LN24@mapMatrixS
$LN57@mapMatrixS:
	mov	edx, esi
$LN24@mapMatrixS:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN60@mapMatrixS:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL8@mapMatrixS
	mov	edi, edx
	pop	esi
$LN7@mapMatrixS:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx], 0
$LN9@mapMatrixS:
	pop	edi
	pop	ebx
	ret	0
??1mapMatrixStates@R_dsgraph@@QAE@XZ ENDP		; R_dsgraph::mapMatrixStates::~mapMatrixStates
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN9@TNode
	push	esi
$LL10@TNode:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN62@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN59@TNode
$LL27@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN44@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN44@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL27@TNode
	jmp	SHORT $LN26@TNode
$LN59@TNode:
	mov	edx, esi
$LN26@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN62@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL10@TNode
	mov	edi, edx
	pop	esi
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN11@TNode:
	pop	edi
	pop	ebx
	ret	0
??1TNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN66@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN12@scalar
	push	esi
$LL13@scalar:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN65@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN62@scalar
$LL30@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN47@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN47@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL30@scalar
	jmp	SHORT $LN29@scalar
$LN62@scalar:
	mov	edx, esi
$LN29@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN65@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL13@scalar
	mov	edi, edx
	pop	esi
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edi
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN66@scalar:
	pop	edi
	mov	eax, ebx
	pop	ebx
	ret	4
??_GTNode@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebx
	push	ebp
	mov	ebp, ecx

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN3@destroy
	push	esi
	push	edi
	npad	8
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN81@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN75@destroy
$LL21@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN82@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN77@destroy
	npad	4
$LL38@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN55@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN55@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL38@destroy
	jmp	SHORT $LN37@destroy
$LN77@destroy:
	mov	edx, esi
$LN37@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN82@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL21@destroy
	jmp	SHORT $LN20@destroy
$LN75@destroy:
	mov	edx, edi
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN81@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL4@destroy
	pop	edi
	mov	ebx, edx
	pop	esi
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN5@destroy:
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebx
	ret	0
?destroy@?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 117  : 	~FixedMAP() {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN7@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN5@FixedMAP
	push	esi
	push	edi
	npad	8
$LL6@FixedMAP:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN83@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN77@FixedMAP
$LL23@FixedMAP:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN84@FixedMAP

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN79@FixedMAP
	npad	4
$LL40@FixedMAP:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN57@FixedMAP
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN57@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL40@FixedMAP
	jmp	SHORT $LN39@FixedMAP
$LN79@FixedMAP:
	mov	edx, esi
$LN39@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN84@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL23@FixedMAP
	jmp	SHORT $LN22@FixedMAP
$LN77@FixedMAP:
	mov	edx, edi
$LN22@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN83@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL6@FixedMAP
	pop	edi
	mov	ebx, edx
	pop	esi
$LN5@FixedMAP:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN7@FixedMAP:
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 119  : 	}

	pop	ebx
	ret	0
??1?$FixedMAP@PAVR_constant_table@@UmapMatrixStates@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>::~FixedMAP<R_constant_table *,R_dsgraph::mapMatrixStates,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1mapMatrixCS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixCS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapMatrixCS::~mapMatrixCS, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp]
	test	ebx, ebx
	je	$LN9@mapMatrixC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN7@mapMatrixC
	push	esi
	push	edi
	npad	8
$LL8@mapMatrixC:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN85@mapMatrixC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN79@mapMatrixC
$LL25@mapMatrixC:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN86@mapMatrixC

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN81@mapMatrixC
	npad	4
$LL42@mapMatrixC:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN59@mapMatrixC
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN59@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL42@mapMatrixC
	jmp	SHORT $LN41@mapMatrixC
$LN81@mapMatrixC:
	mov	edx, esi
$LN41@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN86@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL25@mapMatrixC
	jmp	SHORT $LN24@mapMatrixC
$LN79@mapMatrixC:
	mov	edx, edi
$LN24@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN85@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL8@mapMatrixC
	pop	edi
	mov	ebx, edx
	pop	esi
$LN7@mapMatrixC:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp], 0
$LN9@mapMatrixC:
	pop	ebp
	pop	ebx
	ret	0
??1mapMatrixCS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapMatrixCS::~mapMatrixCS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN11@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN9@TNode
	push	esi
	push	edi
	npad	8
$LL10@TNode:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN87@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN81@TNode
$LL27@TNode:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN88@TNode

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN83@TNode
	npad	4
$LL44@TNode:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN61@TNode
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN61@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL44@TNode
	jmp	SHORT $LN43@TNode
$LN83@TNode:
	mov	edx, esi
$LN43@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN88@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL27@TNode
	jmp	SHORT $LN26@TNode
$LN81@TNode:
	mov	edx, edi
$LN26@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN87@TNode:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL10@TNode
	pop	edi
	mov	ebx, edx
	pop	esi
$LN9@TNode:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN11@TNode:
	pop	ebp
	pop	ebx
	ret	0
??1TNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN92@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN12@scalar
	push	esi
	push	edi
	npad	8
$LL13@scalar:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN90@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN84@scalar
$LL30@scalar:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN91@scalar

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN86@scalar
	npad	4
$LL47@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN64@scalar
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN64@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL47@scalar
	jmp	SHORT $LN46@scalar
$LN86@scalar:
	mov	edx, esi
$LN46@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN91@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	$LL30@scalar
	jmp	SHORT $LN29@scalar
$LN84@scalar:
	mov	edx, edi
$LN29@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN90@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL13@scalar
	pop	edi
	mov	ebx, edx
	pop	esi
$LN12@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN92@scalar:
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[esp+12], esi

; 122  : 		if (nodes) {

	mov	ebp, DWORD PTR [esi]
	test	ebp, ebp
	je	$LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ecx*4]
	add	eax, ebp

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebp, eax
	je	$LN3@destroy
	push	ebx
	push	edi
$LL4@destroy:

; 122  : 		if (nodes) {

	mov	ebx, DWORD PTR [ebp+4]
	test	ebx, ebx
	je	$LN106@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [ebx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	je	$LN97@destroy
$LL21@destroy:

; 122  : 		if (nodes) {

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	je	$LN107@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	je	$LN99@destroy
$LL38@destroy:

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN108@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN101@destroy
$LL55@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN72@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN72@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL55@destroy
	jmp	SHORT $LN54@destroy
$LN101@destroy:
	mov	edx, esi
$LN54@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [edi+4], 0
$LN108@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebx+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	edi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	edi, eax
	jne	SHORT $LL38@destroy
	jmp	SHORT $LN37@destroy
$LN99@destroy:
	mov	edx, edi
$LN37@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebx+4], 0
$LN107@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ebp+12]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebx, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebx, eax
	jne	$LL21@destroy
	mov	esi, DWORD PTR _this$1$[esp+20]
	jmp	SHORT $LN20@destroy
$LN97@destroy:
	mov	edx, ebx
$LN20@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, edx
	call	_dlfree
	mov	DWORD PTR [ebp+4], 0
$LN106@destroy:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [esi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	ebp, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	ebp, eax
	jne	$LL4@destroy
	pop	edi
	mov	ebp, edx
	pop	ebx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, ebp
	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN5@destroy:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	ebp
	pop	ecx
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
??1?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::~FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1mapMatrixPS@R_dsgraph@@QAE@XZ
_TEXT	SEGMENT
??1mapMatrixPS@R_dsgraph@@QAE@XZ PROC			; R_dsgraph::mapMatrixPS::~mapMatrixPS, COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
??1mapMatrixPS@R_dsgraph@@QAE@XZ ENDP			; R_dsgraph::mapMatrixPS::~mapMatrixPS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ
_TEXT	SEGMENT
??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::~TNode, COMDAT
; _this$ = ecx
	add	ecx, 4

; 118  : 		destroy	();

	jmp	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
??1TNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAE@XZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::~TNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 118  : 		destroy	();

	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+4]
	call	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy
	mov	eax, esi
	pop	esi
	ret	4
??_GTNode@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAXI@Z ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::TNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi
	mov	edi, ecx

; 122  : 		if (nodes) {

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN5@destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [esi+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	je	SHORT $LN3@destroy
	npad	3
$LL4@destroy:

; 118  : 		destroy	();

	lea	ecx, DWORD PTR [esi+4]
	call	?destroy@?$FixedMAP@PAUIDirect3DPixelShader9@@UmapMatrixCS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DPixelShader9 *,R_dsgraph::mapMatrixCS,doug_lea_allocator>::destroy

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [edi+8]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	add	esi, 28					; 0000001cH

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]

; 123  : 			for (TNode* cur = begin(); cur!=last(); cur++)

	cmp	esi, eax
	jne	SHORT $LL4@destroy
	mov	esi, edx
$LN3@destroy:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	mov	ecx, esi
	call	_dlfree
	mov	DWORD PTR [edi], 0
$LN5@destroy:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	pop	esi
	ret	0
?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?begin@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?begin@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::begin, COMDAT
; _this$ = ecx

; 200  : 	IC TNode*	begin()		{ return nodes;			}

	mov	eax, DWORD PTR [ecx]
	ret	0
?begin@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]
	ret	0
?last@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	mov	esi, ecx

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN5@destroy:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	ret	0
?destroy@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?begin@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?begin@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::begin, COMDAT
; _this$ = ecx

; 200  : 	IC TNode*	begin()		{ return nodes;			}

	mov	eax, DWORD PTR [ecx]
	ret	0
?begin@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?last@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ
_TEXT	SEGMENT
?last@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::last, COMDAT
; _this$ = ecx

; 202  : 	IC TNode*	last()		{ return nodes+limit;	}	// for setup only

	imul	eax, DWORD PTR [ecx+8], 92
	add	eax, DWORD PTR [ecx]
	ret	0
?last@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEPAUTNode@1@XZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?destroy@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::destroy, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	mov	esi, ecx

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@destroy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi], 0
$LN5@destroy:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 127  : 	}

	ret	0
?destroy@?$FixedMAP@MU_MatrixItemS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<float,R_dsgraph::_MatrixItemS,doug_lea_allocator>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h
;	COMDAT ?r_dsgraph_destroy@R_dsgraph_structure@@QAEXXZ
_TEXT	SEGMENT
?r_dsgraph_destroy@R_dsgraph_structure@@QAEXXZ PROC	; R_dsgraph_structure::r_dsgraph_destroy, COMDAT
; _this$ = ecx

; 101  : 	{

	push	esi
	mov	esi, ecx

; 102  : 		nrmVS.clear				();

	mov	eax, DWORD PTR [esi+400]

; 103  : 		nrmPS.clear				();
; 104  : 		nrmCS.clear				();
; 105  : 		nrmStates.clear			();
; 106  : 		nrmTextures.clear		();
; 107  : 		nrmTexturesTemp.clear	();
; 108  : 
; 109  : 		matVS.clear				();
; 110  : 		matPS.clear				();
; 111  : 		matCS.clear				();
; 112  : 		matStates.clear			();
; 113  : 		matTextures.clear		();
; 114  : 		matTexturesTemp.clear	();
; 115  : 
; 116  : 		lstLODs.clear			();
; 117  : 		lstLODgroups.clear		();
; 118  : 		lstRenderables.clear	();
; 119  : 		lstSpatial.clear		();
; 120  : 		lstVisuals.clear		();
; 121  : 
; 122  : 		lstRecorded.clear		();
; 123  : 
; 124  : 		mapNormal[0].destroy	();

	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR [esi+404], eax
	mov	eax, DWORD PTR [esi+412]
	mov	DWORD PTR [esi+416], eax
	mov	eax, DWORD PTR [esi+424]
	mov	DWORD PTR [esi+428], eax
	mov	eax, DWORD PTR [esi+436]
	mov	DWORD PTR [esi+440], eax
	mov	eax, DWORD PTR [esi+448]
	mov	DWORD PTR [esi+452], eax
	mov	eax, DWORD PTR [esi+460]
	mov	DWORD PTR [esi+464], eax
	mov	eax, DWORD PTR [esi+472]
	mov	DWORD PTR [esi+476], eax
	mov	eax, DWORD PTR [esi+484]
	mov	DWORD PTR [esi+488], eax
	mov	eax, DWORD PTR [esi+496]
	mov	DWORD PTR [esi+500], eax
	mov	eax, DWORD PTR [esi+508]
	mov	DWORD PTR [esi+512], eax
	mov	eax, DWORD PTR [esi+520]
	mov	DWORD PTR [esi+524], eax
	mov	eax, DWORD PTR [esi+532]
	mov	DWORD PTR [esi+536], eax
	mov	eax, DWORD PTR [esi+544]
	mov	DWORD PTR [esi+548], eax
	mov	eax, DWORD PTR [esi+556]
	mov	DWORD PTR [esi+560], eax
	mov	eax, DWORD PTR [esi+568]
	mov	DWORD PTR [esi+572], eax
	mov	eax, DWORD PTR [esi+580]
	mov	DWORD PTR [esi+584], eax
	mov	eax, DWORD PTR [esi+592]
	mov	DWORD PTR [esi+596], eax
	mov	eax, DWORD PTR [esi+604]
	mov	DWORD PTR [esi+608], eax
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy

; 125  : 		mapNormal[1].destroy	();

	lea	ecx, DWORD PTR [esi+316]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapNormalPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapNormalPS,doug_lea_allocator>::destroy

; 126  : 		mapMatrix[0].destroy	();

	lea	ecx, DWORD PTR [esi+328]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy

; 127  : 		mapMatrix[1].destroy	();

	lea	ecx, DWORD PTR [esi+340]
	call	?destroy@?$FixedMAP@PAUIDirect3DVertexShader9@@UmapMatrixPS@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<IDirect3DVertexShader9 *,R_dsgraph::mapMatrixPS,doug_lea_allocator>::destroy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+352]
	test	ecx, ecx
	je	SHORT $LN7@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+352], 0
$LN7@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+364]
	test	ecx, ecx
	je	SHORT $LN17@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+364], 0
$LN17@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+376]
	test	ecx, ecx
	je	SHORT $LN27@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+376], 0
$LN27@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 122  : 		if (nodes) {

	mov	ecx, DWORD PTR [esi+388]
	test	ecx, ecx
	je	SHORT $LN37@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 53   : 		static	void	dealloc		(T *&p)			{	dlfree(p);	p=0;			}

	call	_dlfree
	mov	DWORD PTR [esi+388], 0
$LN37@r_dsgraph_:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_structure.h

; 137  : 	}

	ret	0
?r_dsgraph_destroy@R_dsgraph_structure@@QAEXXZ ENDP	; R_dsgraph_structure::r_dsgraph_destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\lightProjector.h
;	COMDAT ?shadowing@CLightProjector@@QAEHXZ
_TEXT	SEGMENT
?shadowing@CLightProjector@@QAEHXZ PROC			; CLightProjector::shadowing, COMDAT
; _this$ = ecx

; 43   : 	BOOL					shadowing		()			{ return current!=0;	}

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	setne	al
	ret	0
?shadowing@CLightProjector@@QAEHXZ ENDP			; CLightProjector::shadowing
_TEXT	ENDS
END
