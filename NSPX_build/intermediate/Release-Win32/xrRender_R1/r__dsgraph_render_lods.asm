; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\r__dsgraph_render_lods.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp_??1ShaderElement@@QAE@XZ:PROC
;	COMDAT ?vid@?L@??r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z@4PAHA
CONST	SEGMENT
?vid@?L@??r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z@4PAHA DD 03H ; `R_dsgraph_structure::r_dsgraph_render_lods'::`11'::vid
	DD	00H
	DD	02H
	DD	01H
PUBLIC	?clear@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear
PUBLIC	?clear_and_free@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear_and_free
PUBLIC	?clear@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear
PUBLIC	?_Destroy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Destroy
PUBLIC	?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first
PUBLIC	??$_Destroy_range@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAXPAU_LodItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??$_Unfancy@U_LodItem@R_dsgraph@@@std@@YAPAU_LodItem@R_dsgraph@@PAU12@@Z ; std::_Unfancy<R_dsgraph::_LodItem>
PUBLIC	??$destroy@U_LodItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::destroy<R_dsgraph::_LodItem>
PUBLIC	?destroy@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@@Z ; doug_lea_alloc<R_dsgraph::_LodItem>::destroy
PUBLIC	??$_Destroy_in_place@PAU_LodItem@R_dsgraph@@@std@@YAXAAPAU_LodItem@R_dsgraph@@@Z ; std::_Destroy_in_place<R_dsgraph::_LodItem *>
PUBLIC	?clear@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ ; xr_vector<int,doug_lea_alloc<int> >::clear
PUBLIC	?clear_and_free@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ ; xr_vector<int,doug_lea_alloc<int> >::clear_and_free
PUBLIC	?clear@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXXZ ; std::vector<int,doug_lea_alloc<int> >::clear
PUBLIC	?_Destroy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH0@Z ; std::vector<int,doug_lea_alloc<int> >::_Destroy
PUBLIC	?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEAAV?$doug_lea_alloc@H@@XZ ; std::vector<int,doug_lea_alloc<int> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@H@@XZ ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??$_Destroy_range@V?$doug_lea_alloc@H@@@std@@YAXPAHQAHAAV?$doug_lea_alloc@H@@@Z ; std::_Destroy_range<doug_lea_alloc<int> >
PUBLIC	??$destroy@H@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH@Z ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::destroy<int>
PUBLIC	?destroy@?$doug_lea_alloc@H@@QAEXPAH@Z		; doug_lea_alloc<int>::destroy
PUBLIC	?deallocate@?$doug_lea_alloc@H@@QBEXPAHI@Z	; doug_lea_alloc<int>::deallocate
PUBLIC	?deallocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEXPAU_LodItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_LodItem>::deallocate
PUBLIC	??$move@AAI@std@@YA$$QAIAAI@Z			; std::move<unsigned int &>
PUBLIC	??$swap@I$0A@@std@@YAXAAI0@Z			; std::swap<unsigned int,0>
PUBLIC	??$_Swap_adl@I@std@@YAXAAI0@Z			; std::_Swap_adl<unsigned int>
PUBLIC	??$_Swap_adl@M@std@@YAXAAM0@Z			; std::_Swap_adl<float>
PUBLIC	??$addressof@U?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@AAU10@@Z ; std::addressof<std::pair<float,unsigned int> >
PUBLIC	?swap@?$pair@MI@std@@QAEXAAU12@@Z		; std::pair<float,unsigned int>::swap
PUBLIC	??$forward@AAPAU?$pair@MI@std@@@std@@YAAAPAU?$pair@MI@0@AAPAU10@@Z ; std::forward<std::pair<float,unsigned int> * &>
PUBLIC	??$swap@MI$0A@@std@@YAXAAU?$pair@MI@0@0@Z	; std::swap<float,unsigned int,0>
PUBLIC	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Push_heap_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Push_heap_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$forward@U?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z ; std::forward<std::pair<float,unsigned int> >
PUBLIC	??$forward@I@std@@YA$$QAIAAI@Z			; std::forward<unsigned int>
PUBLIC	??$construct@U_LodItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@$$QAU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem>
PUBLIC	??$forward@U_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z ; std::forward<R_dsgraph::_LodItem>
PUBLIC	??$construct@HH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH$$QAH@Z ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int>
PUBLIC	??$?0AAPAU?$pair@MI@std@@AAPAU01@$0A@@?$pair@PAU?$pair@MI@std@@PAU12@@std@@QAE@AAPAU?$pair@MI@1@0@Z ; std::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *><std::pair<float,unsigned int> * &,std::pair<float,unsigned int> * &,0>
PUBLIC	??$iter_swap@PAU?$pair@MI@std@@PAU12@@std@@YAXPAU?$pair@MI@0@0@Z ; std::iter_swap<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
PUBLIC	??$_Next_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z ; std::_Next_iter<std::pair<float,unsigned int> *>
PUBLIC	??$_Guess_median_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Guess_median_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Prev_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z ; std::_Prev_iter<std::pair<float,unsigned int> *>
PUBLIC	??$_Pop_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ; std::_Pop_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Move_backward_unchecked@PAU?$pair@MI@std@@PAU12@@std@@YAPAU?$pair@MI@0@PAU10@00@Z ; std::_Move_backward_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
PUBLIC	??$move@AAU?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z ; std::move<std::pair<float,unsigned int> &>
PUBLIC	??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@$$QAU01@@Z ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>
PUBLIC	??$_Emplace_back@U_LodItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEX$$QAU_LodItem@R_dsgraph@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back<R_dsgraph::_LodItem>
PUBLIC	??$move@AAU_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z ; std::move<R_dsgraph::_LodItem &>
PUBLIC	??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEX$$QAH@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Emplace_back<int>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@MI@std@@PAU12@@0@PAU?$pair@MI@0@0P6A_NABU20@1@Z@Z ; std::_Partition_by_median_guess_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Sort_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Make_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ; std::_Make_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Insertion_sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@MI@0@QAU10@0P6A_NABU10@1@Z@Z ; std::_Insertion_sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$forward@AAI@std@@YAAAIAAI@Z			; std::forward<unsigned int &>
PUBLIC	??$forward@AAM@std@@YAAAMAAM@Z			; std::forward<float &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@PAHAAV?$doug_lea_alloc@H@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Uninitialized_backout_al<doug_lea_alloc<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::~_Uninitialized_backout_al<doug_lea_alloc<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@PAU_LodItem@R_dsgraph@@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@XZ ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Release
PUBLIC	??$_Get_unwrapped@ABQAU_LodItem@R_dsgraph@@@std@@YA?A_TABQAU_LodItem@R_dsgraph@@@Z ; std::_Get_unwrapped<R_dsgraph::_LodItem * const &>
PUBLIC	??$_Uninitialized_move@PAU_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAPAU_LodItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ; std::_Uninitialized_move<R_dsgraph::_LodItem *,doug_lea_alloc<R_dsgraph::_LodItem> >
PUBLIC	??$_Uninitialized_move@PAHV?$doug_lea_alloc@H@@@std@@YAPAHQAH0PAHAAV?$doug_lea_alloc@H@@@Z ; std::_Uninitialized_move<int *,doug_lea_alloc<int> >
PUBLIC	??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$_Pass_fn@P6A_NABU?$pair@MI@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@MI@0@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &),0>
PUBLIC	??$_Adl_verify_range@PAU?$pair@MI@std@@PAU12@@std@@YAXABQAU?$pair@MI@0@0@Z ; std::_Adl_verify_range<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
PUBLIC	??$?0AAMAAI$0A@@?$pair@MI@std@@QAE@AAMAAI@Z	; std::pair<float,unsigned int>::pair<float,unsigned int><float &,unsigned int &,0>
PUBLIC	?max_size@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEIXZ ; doug_lea_alloc<R_dsgraph::_LodItem>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first
PUBLIC	?max_size@?$doug_lea_alloc@H@@QBEIXZ		; doug_lea_alloc<int>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@H@@XZ ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::max_size
PUBLIC	?capacity@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAIABV?$doug_lea_alloc@H@@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ; std::vector<int,doug_lea_alloc<int> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEABV?$doug_lea_alloc@H@@XZ ; std::vector<int,doug_lea_alloc<int> >::_Getal
PUBLIC	??_GShaderElement@@QAEPAXI@Z			; ShaderElement::`scalar deleting destructor'
PUBLIC	?allocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEPAU_LodItem@R_dsgraph@@IPBX@Z ; doug_lea_alloc<R_dsgraph::_LodItem>::allocate
PUBLIC	?construct@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@ABU23@@Z ; doug_lea_alloc<R_dsgraph::_LodItem>::construct
PUBLIC	?max_size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::max_size
PUBLIC	?_Umove@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEPAU_LodItem@R_dsgraph@@PAU34@00@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEII@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXQAU_LodItem@R_dsgraph@@II@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Change_array
PUBLIC	?_Xlength@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Xlength
PUBLIC	?allocate@?$doug_lea_alloc@H@@QBEPAHIPBX@Z	; doug_lea_alloc<int>::allocate
PUBLIC	?construct@?$doug_lea_alloc@H@@QAEXPAHABH@Z	; doug_lea_alloc<int>::construct
PUBLIC	?max_size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ; std::vector<int,doug_lea_alloc<int> >::max_size
PUBLIC	?_Umove@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEPAHPAH00@Z ; std::vector<int,doug_lea_alloc<int> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00@Z ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEII@Z ; std::vector<int,doug_lea_alloc<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXQAHII@Z ; std::vector<int,doug_lea_alloc<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$doug_lea_alloc@H@@@std@@CAXXZ ; std::vector<int,doug_lea_alloc<int> >::_Xlength
PUBLIC	??R?$xr_special_free@$0A@UShaderElement@@@@QAEXAAPAUShaderElement@@@Z ; xr_special_free<0,ShaderElement>::operator()
PUBLIC	??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
PUBLIC	??$construct@U_LodItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@ABU34@@Z ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem const &>
PUBLIC	??$forward@ABU_LodItem@R_dsgraph@@@std@@YAABU_LodItem@R_dsgraph@@ABU12@@Z ; std::forward<R_dsgraph::_LodItem const &>
PUBLIC	??$xr_delete@UShaderElement@@@@YAXAAPAUShaderElement@@@Z ; xr_delete<ShaderElement>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$construct@HABH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAHABH@Z ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int const &>
PUBLIC	??$?0MI$0A@@?$pair@MI@std@@QAE@XZ		; std::pair<float,unsigned int>::pair<float,unsigned int><float,unsigned int,0>
PUBLIC	??$_Get_unwrapped@ABQAU?$pair@MI@std@@@std@@YA?A_TABQAU?$pair@MI@0@@Z ; std::_Get_unwrapped<std::pair<float,unsigned int> * const &>
PUBLIC	??$sort@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXQAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ; std::sort<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
PUBLIC	??$mk_pair@MI@@YA?AU?$pair@MI@std@@MI@Z		; mk_pair<float,unsigned int>
PUBLIC	??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@ABU01@@Z ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>
PUBLIC	??$?8UShaderElement@@U0@V?$resptr_base@UShaderElement@@@@@@YA_NABV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@0@Z ; operator==<ShaderElement,ShaderElement,resptr_base<ShaderElement> >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Verify_offset
PUBLIC	?_Orphan_range@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEXPAU_LodItem@R_dsgraph@@0@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Orphan_range
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=
PUBLIC	?_set@?$resptr_base@UShaderElement@@@@QAEXPAUShaderElement@@@Z ; resptr_base<ShaderElement>::_set
PUBLIC	??$_Emplace_back_with_unused_capacity@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAE?A_TABU_LodItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_LodItem const &>
PUBLIC	??$emplace_back@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?A_TABU_LodItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::emplace_back<R_dsgraph::_LodItem const &>
PUBLIC	?push_back@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXABU_LodItem@R_dsgraph@@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::push_back
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEABU_LodItem@R_dsgraph@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
PUBLIC	?_inc@?$resptr_base@UShaderElement@@@@IAEXXZ	; resptr_base<ShaderElement>::_inc
PUBLIC	?_dec@?$resptr_base@UShaderElement@@@@IAEXXZ	; resptr_base<ShaderElement>::_dec
PUBLIC	?_set@?$resptr_base@UShaderElement@@@@QAEXABV1@@Z ; resptr_base<ShaderElement>::_set
PUBLIC	?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
PUBLIC	?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
PUBLIC	?begin@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@2@XZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::begin
PUBLIC	?size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size
PUBLIC	?begin@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,doug_lea_alloc<int> >::begin
PUBLIC	?size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ; std::vector<int,doug_lea_alloc<int> >::size
PUBLIC	?_Orphan_range@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEXPAH0@Z ; std::vector<int,doug_lea_alloc<int> >::_Orphan_range
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEAAU_LodItem@R_dsgraph@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+
PUBLIC	??0?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@ABV0@@Z ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::resptr_core<ShaderElement,resptr_base<ShaderElement> >
PUBLIC	??1?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@XZ ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::~resptr_core<ShaderElement,resptr_base<ShaderElement> >
PUBLIC	??4?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAEAAV0@ABV0@@Z ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator=
PUBLIC	?clear@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::clear
PUBLIC	?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
PUBLIC	?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
PUBLIC	?empty@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBE_NXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::empty
PUBLIC	?size@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QBEIXZ ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size
PUBLIC	??A?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEAAU_LodItem@R_dsgraph@@I@Z ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::operator[]
PUBLIC	??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@AAE?A_TABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$emplace_back@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?A_TABH@Z ; std::vector<int,doug_lea_alloc<int> >::emplace_back<int const &>
PUBLIC	?push_back@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXABH@Z ; std::vector<int,doug_lea_alloc<int> >::push_back
PUBLIC	?size@?$xr_vector@HV?$doug_lea_alloc@H@@@@QBEIXZ ; xr_vector<int,doug_lea_alloc<int> >::size
PUBLIC	??A?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEAAHI@Z ; xr_vector<int,doug_lea_alloc<int> >::operator[]
PUBLIC	??0?$svector@U?$pair@MI@std@@$07@@QAE@XZ	; svector<std::pair<float,unsigned int>,8>::svector<std::pair<float,unsigned int>,8>
PUBLIC	?begin@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ ; svector<std::pair<float,unsigned int>,8>::begin
PUBLIC	?end@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ ; svector<std::pair<float,unsigned int>,8>::end
PUBLIC	?size@?$svector@U?$pair@MI@std@@$07@@QBEIXZ	; svector<std::pair<float,unsigned int>,8>::size
PUBLIC	?push_back@?$svector@U?$pair@MI@std@@$07@@QAEXU?$pair@MI@std@@@Z ; svector<std::pair<float,unsigned int>,8>::push_back
PUBLIC	??A?$svector@U?$pair@MI@std@@$07@@QAEAAU?$pair@MI@std@@I@Z ; svector<std::pair<float,unsigned int>,8>::operator[]
PUBLIC	?r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z ; R_dsgraph_structure::r_dsgraph_render_lods
PUBLIC	?pred_dot@@YA_NABU?$pair@MI@std@@0@Z		; pred_dot
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z$2
__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
;	COMDAT ?pred_dot@@YA_NABU?$pair@MI@std@@0@Z
_TEXT	SEGMENT
__1$ = 8						; size = 4
__2$ = 12						; size = 4
?pred_dot@@YA_NABU?$pair@MI@std@@0@Z PROC		; pred_dot, COMDAT

; 15   : ICF		bool	pred_dot		(const std::pair<float,u32>& _1, const std::pair<float,u32>& _2)	{ return _1.first < _2.first; }

	mov	eax, DWORD PTR __2$[esp-4]
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR __1$[esp-4]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN3@pred_dot
	mov	al, 1
	ret	0
$LN3@pred_dot:
	xor	al, al
	ret	0
?pred_dot@@YA_NABU?$pair@MI@std@@0@Z ENDP		; pred_dot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp
_TEXT	SEGMENT
_e$ = -160						; size = 8
$T2 = -148						; size = 4
$T3 = -148						; size = 4
_current$1$ = -144					; size = 4
_cur_count$ = -144					; size = 4
$T4 = -140						; size = 4
_cur_S$1$ = -140					; size = 4
_a$5 = -140						; size = 4
$T6 = -136						; size = 8
_g$1$ = -128						; size = 4
_this$1$ = -128						; size = 4
_shift$1$sroa$2338$1$ = -124				; size = 4
_baseV$1$ = -124					; size = 4
__vb$1$ = -124						; size = 4
_i$1$ = -120						; size = 4
_lodV$1$ = -116						; size = 4
_a$7 = -116						; size = 4
_cur_count$1$ = -112					; size = 4
tv4366 = -108						; size = 4
_vOffset$ = -104					; size = 4
_shift$1$sroa$2341$1$ = -100				; size = 4
_p_count$1$ = -100					; size = 4
_firstV$1$ = -96					; size = 4
tv4329 = -92						; size = 4
_id_best$1$ = -88					; size = 4
_facets$1$ = -84					; size = 4
_id_next$1$ = -80					; size = 4
tv4278 = -76						; size = 4
_selector$8 = -72					; size = 68
__setup_zb$ = 8						; size = 1
__clear$ = 12						; size = 1
?r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z PROC ; R_dsgraph_structure::r_dsgraph_render_lods
; _this$ = ecx

; 17   : {

	sub	esp, 164				; 000000a4H

; 18   : 	if (_setup_zb)	mapLOD.getLR	(lstLODs)	;	// front-to-back

	cmp	BYTE PTR __setup_zb$[esp+160], 0
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+180], ebx
	lea	ecx, DWORD PTR [ebx+376]
	je	SHORT $LN14@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 217  : 	{ if (pool)	getLR(nodes,D); }

	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN26@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 18   : 	if (_setup_zb)	mapLOD.getLR	(lstLODs)	;	// front-to-back

	lea	eax, DWORD PTR [ebx+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 217  : 	{ if (pool)	getLR(nodes,D); }

	push	eax
	push	DWORD PTR [ecx]
	call	?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 18   : 	if (_setup_zb)	mapLOD.getLR	(lstLODs)	;	// front-to-back

	jmp	SHORT $LN26@r_dsgraph_
$LN14@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 221  : 	{ if (pool)	getRL(nodes,D); }

	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN26@r_dsgraph_
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 19   : 	else			mapLOD.getRL	(lstLODs)	;	// back-to-front

	lea	eax, DWORD PTR [ebx+544]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 221  : 	{ if (pool)	getRL(nodes,D); }

	push	eax
	push	DWORD PTR [ecx]
	call	?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
$LN26@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	ecx, DWORD PTR [ebx+548]
	mov	edx, DWORD PTR [ebx+544]
	cmp	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 20   : 	if (lstLODs.empty())			return		;

	je	$LN276@r_dsgraph_

; 21   :  
; 22   : 	// *** Fill VB and generate groups
; 23   : 	u32		shid							= _setup_zb?SE_R1_LMODELS:SE_R1_NORMAL_LQ;
; 24   : 	FLOD*						firstV		= (FLOD*)lstLODs[0].pVisual;

	mov	edx, DWORD PTR [edx+4]

; 27   : 	ref_selement				cur_S		= firstV->shader->E[shid];

	mov	esi, 24					; 00000018H
	cmp	BYTE PTR __setup_zb$[esp+176], 0
	mov	eax, 12					; 0000000cH
	mov	DWORD PTR _firstV$1$[esp+180], edx
	cmovne	eax, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	esi, DWORD PTR [edx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 27   : 	ref_selement				cur_S		= firstV->shader->E[shid];

	mov	DWORD PTR tv4366[esp+180], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	esi, DWORD PTR [eax+esi]
	mov	DWORD PTR _cur_S$1$[esp+180], esi
	test	esi, esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN49@r_dsgraph_
	inc	DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx+548]
$LN49@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	ecx, DWORD PTR [ebx+544]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 31   : 	FLOD::_hw*					V			= (FLOD::_hw*)RCache.Vertex.Lock	(lstLODs.size()*4,firstV->geom->vb_stride, vOffset);

	lea	eax, DWORD PTR _vOffset$[esp+180]
	push	eax
	mov	eax, DWORD PTR [edx+84]
	xor	edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ecx, 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 29   : 	int							cur_count	= 0;

	mov	DWORD PTR _cur_count$[esp+184], edi

; 31   : 	FLOD::_hw*					V			= (FLOD::_hw*)RCache.Vertex.Lock	(lstLODs.size()*4,firstV->geom->vb_stride, vOffset);

	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	eax
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z

; 32   : 	float	ssaRange						= r_ssaLOD_A - r_ssaLOD_B;

	movss	xmm0, DWORD PTR ?r_ssaLOD_A@@3MA
	mov	ebp, eax
	subss	xmm0, DWORD PTR ?r_ssaLOD_B@@3MA

; 33   : 	if		(ssaRange<EPS_S)	ssaRange	= EPS_S;

	movss	xmm1, DWORD PTR __real@33d6bf95
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@r_dsgraph_
	movaps	xmm0, xmm1
$LN17@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebx+544]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 34   : 	for (u32 i=0; i<lstLODs.size(); i++)

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+548]
	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 34   : 	for (u32 i=0; i<lstLODs.size(); i++)

	mov	DWORD PTR _i$1$[esp+180], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 3
	mov	DWORD PTR $T2[esp+180], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 34   : 	for (u32 i=0; i<lstLODs.size(); i++)

	test	eax, eax
	je	$LN327@r_dsgraph_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	movss	xmm5, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 38   : 		if (P.pVisual->shader->E[shid]==cur_S)	cur_count++	;

	add	ebp, 20					; 00000014H
	movaps	xmm1, xmm5
	divss	xmm1, xmm0
	movss	DWORD PTR tv4329[esp+180], xmm1
	npad	1
$LL4@r_dsgraph_:
	mov	eax, DWORD PTR [edx+ecx*8+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	ebx, DWORD PTR tv4366[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 38   : 		if (P.pVisual->shader->E[shid]==cur_S)	cur_count++	;

	mov	DWORD PTR _lodV$1$[esp+180], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	eax, DWORD PTR [eax+64]
	cmp	DWORD PTR [ebx+eax], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 38   : 		if (P.pVisual->shader->E[shid]==cur_S)	cur_count++	;

	mov	ebx, DWORD PTR _this$1$[esp+180]
	jne	SHORT $LN18@r_dsgraph_
	inc	edi
	jmp	$LN328@r_dsgraph_
$LN18@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+560]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 40   : 			lstLODgroups.push_back	(cur_count);

	lea	ecx, DWORD PTR [ebx+556]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN82@r_dsgraph_

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN81@r_dsgraph_
$LN82@r_dsgraph_:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _cur_count$[esp+180]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>
	mov	edx, DWORD PTR $T2[esp+180]
$LN81@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	ecx, DWORD PTR _i$1$[esp+180]
	mov	ebx, DWORD PTR tv4366[esp+180]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	eax, DWORD PTR [eax+64]
	mov	edi, DWORD PTR [ebx+eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN91@r_dsgraph_
	inc	DWORD PTR [edi]
$LN91@r_dsgraph_:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	esi, esi
	je	SHORT $LN98@r_dsgraph_
	add	DWORD PTR [esi], -1
	jne	SHORT $LN98@r_dsgraph_
	mov	ecx, esi
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	edx, DWORD PTR $T2[esp+180]
	mov	ecx, DWORD PTR _i$1$[esp+180]
$LN98@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 42   : 			cur_count			= 1;

	mov	eax, DWORD PTR [edx+ecx*8+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 42   : 			cur_count			= 1;

	movss	xmm5, DWORD PTR __real@3f800000
	mov	edi, 1
	mov	DWORD PTR _lodV$1$[esp+180], eax
$LN328@r_dsgraph_:

; 46   : 		float	ssaDiff					= P.ssa - r_ssaLOD_B;

	movss	xmm1, DWORD PTR [edx+ecx*8]

; 48   : 		int		iA						= iFloor	((1-scale)*255.f);	

	movaps	xmm0, xmm5
	subss	xmm1, DWORD PTR ?r_ssaLOD_B@@3MA
	mov	DWORD PTR _cur_count$1$[esp+180], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 46   : 		float	ssaDiff					= P.ssa - r_ssaLOD_B;

	mov	DWORD PTR _cur_count$[esp+180], edi

; 47   : 		float	scale					= ssaDiff/ssaRange	;

	mulss	xmm1, DWORD PTR tv4329[esp+180]

; 48   : 		int		iA						= iFloor	((1-scale)*255.f);	

	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@437f0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$5[esp+180], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, DWORD PTR _a$5[esp+180]
	mov	eax, edi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, edi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, edi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, edi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN108@r_dsgraph_
	mov	DWORD PTR $T4[esp+180], 0
	jmp	SHORT $LN110@r_dsgraph_
$LN108@r_dsgraph_:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ebx, eax
	mov	DWORD PTR $T4[esp+180], ebx
$LN110@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	ecx, DWORD PTR _lodV$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 54   : 		Ldir.sub						(lodV->vis.sphere.P,Device.vCameraPosition).normalize();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+184], 0
	mov	DWORD PTR _e$[esp+184], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [ecx+12]
	subss	xmm4, DWORD PTR [eax+492]
	movss	xmm3, DWORD PTR [ecx+8]
	subss	xmm3, DWORD PTR [eax+488]
	movss	xmm2, DWORD PTR [ecx+16]
	subss	xmm2, DWORD PTR [eax+496]
	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+184], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, xmm4

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	mulss	xmm4, xmm0
	mulss	xmm3, xmm0

; 192  : 		y *= mag;

	mulss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 55   : 		shift.mul						(Ldir,-.5f * lodV->vis.sphere.R);

	movss	xmm0, DWORD PTR [ecx+20]

; 56   : 
; 57   : 		// gen geometry
; 58   : 		FLOD::_face*					facets		= lodV->facets;

	add	ecx, 88					; 00000058H
	mulss	xmm0, DWORD PTR __real@bf000000
	mov	DWORD PTR _facets$1$[esp+180], ecx
	movaps	xmm1, xmm0
	mulss	xmm1, xmm3
	movss	DWORD PTR tv4278[esp+180], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm1, xmm0
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	movss	DWORD PTR _shift$1$sroa$2338$1$[esp+180], xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+112]

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _shift$1$sroa$2341$1$[esp+180], xmm1

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [ecx+116]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+120]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+184], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+180], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+180]
	mov	DWORD PTR _e$[esp+180], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+180]
	movss	DWORD PTR _selector$8[esp+180], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+236]
	mulss	xmm1, DWORD PTR [ecx+240]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+244]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+192], 1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+180], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+180]
	mov	DWORD PTR _e$[esp+180], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+180]
	movss	DWORD PTR _selector$8[esp+188], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm1, DWORD PTR [ecx+364]
	mulss	xmm0, DWORD PTR [ecx+360]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+368]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+200], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+180], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+180]
	mov	DWORD PTR _e$[esp+180], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+180]
	movss	DWORD PTR _selector$8[esp+196], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm1, DWORD PTR [ecx+488]
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+184], 3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [ecx+484]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	edx, DWORD PTR _selector$8[esp+244]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+184], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	push	OFFSET ?pred_dot@@YA_NABU?$pair@MI@std@@0@Z ; pred_dot
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+188], 5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+188], 6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	DWORD PTR _e$[esp+188], 7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [ecx+492]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+212], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	push	8
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+188], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+188]
	mov	DWORD PTR _e$[esp+188], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+188]
	movss	DWORD PTR _selector$8[esp+212], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+608]
	mulss	xmm1, DWORD PTR [ecx+612]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+616]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+224], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+188], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+188]
	mov	DWORD PTR _e$[esp+188], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+188]
	movss	DWORD PTR _selector$8[esp+220], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+732]
	mulss	xmm1, DWORD PTR [ecx+736]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+740]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+232], 5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+188], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+188]
	mov	DWORD PTR _e$[esp+188], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+188]
	movss	DWORD PTR _selector$8[esp+228], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+856]
	mulss	xmm1, DWORD PTR [ecx+860]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+864]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+240], 6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+188], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+188]
	mov	DWORD PTR _e$[esp+188], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+188]
	movss	DWORD PTR _selector$8[esp+236], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm4, DWORD PTR [ecx+984]
	mulss	xmm3, DWORD PTR [ecx+980]
	mulss	xmm2, DWORD PTR [ecx+988]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	lea	ecx, DWORD PTR _selector$8[esp+188]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR _selector$8[esp+252], 8
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm4, xmm3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 278  :         second = _Right.second;

	mov	DWORD PTR _selector$8[esp+248], 7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm4, xmm2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR $T6[esp+188], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 60   : 		for (u32 s=0; s<8; s++)			selector.push_back	(mk_pair(Ldir.dotproduct(facets[s].N),s));

	mov	eax, DWORD PTR $T6[esp+188]
	mov	DWORD PTR _e$[esp+188], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp+188]
	movss	DWORD PTR _selector$8[esp+244], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	call	??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 66   : 		u32								id_best		= selector	[selector.size()-1].second	;

	mov	eax, DWORD PTR _selector$8[esp+252]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 66   : 		u32								id_best		= selector	[selector.size()-1].second	;

	mov	ecx, DWORD PTR _selector$8[esp+eax*8+176]
	mov	DWORD PTR _id_best$1$[esp+180], ecx

; 67   : 		u32								id_next		= selector	[selector.size()-2].second	;

	mov	ecx, DWORD PTR _selector$8[esp+eax*8+168]

; 68   : 
; 69   : 		// Now we have two "best" planes, calculate factor, and approx normal
; 70   : 		float	fA = dot_best, fB = dot_next, fC = dot_next_2;

	movss	xmm1, DWORD PTR _selector$8[esp+eax*8+156]

; 71   : 		float	alpha	=	0.5f + 0.5f*(1-(fB-fC)/(fA-fC))	;

	movss	xmm0, DWORD PTR _selector$8[esp+eax*8+172]
	movss	xmm2, DWORD PTR _selector$8[esp+eax*8+164]
	subss	xmm0, xmm1
	subss	xmm2, xmm1
	movss	xmm5, DWORD PTR __real@3f800000
	mov	DWORD PTR _id_next$1$[esp+180], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 71   : 		float	alpha	=	0.5f + 0.5f*(1-(fB-fC)/(fA-fC))	;

	divss	xmm2, xmm0
	movaps	xmm0, xmm5
	subss	xmm0, xmm2

; 72   : 		int		iF		=	iFloor		(alpha*255.5f)		;

	addss	xmm0, xmm5
	mulss	xmm0, DWORD PTR __real@42ff8000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$7[esp+180], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, DWORD PTR _a$7[esp+180]
	mov	eax, edi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, edi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, edi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, edi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 96   : 	if		( val<_low	)	return _low; 

	jge	SHORT $LN181@r_dsgraph_
	xor	ecx, ecx
	jmp	SHORT $LN183@r_dsgraph_
$LN181@r_dsgraph_:

; 97   : 	else if	( val>_high )	return _high;

	cmp	ebx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	ebx, eax
	mov	ecx, ebx
$LN183@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 77   : 		FLOD::_face&	FB				= facets[id_next]	;

	imul	edi, DWORD PTR _id_next$1$[esp+180], 124
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	xmm3, DWORD PTR tv4278[esp+180]
	movss	xmm2, DWORD PTR _shift$1$sroa$2341$1$[esp+180]
	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR _shift$1$sroa$2338$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 76   : 		FLOD::_face&	FA				= facets[id_best]	;

	imul	ebx, DWORD PTR _id_best$1$[esp+180], 124

; 77   : 		FLOD::_face&	FB				= facets[id_next]	;

	add	edi, DWORD PTR _facets$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	mov	DWORD PTR $T3[esp+180], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, DWORD PTR [edi+84]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 76   : 		FLOD::_face&	FA				= facets[id_best]	;

	add	ebx, DWORD PTR _facets$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [ebp-20], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edi+88]
	movss	DWORD PTR [ebp-16], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+92]
	movss	DWORD PTR [ebp-12], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [ebx+84]
	movss	DWORD PTR [ebp-8], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [ebx+88]
	movss	DWORD PTR [ebp-4], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [ebx+92]
	movss	DWORD PTR [ebp], xmm0
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 83   : 			V->n0		= FB.N					;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR [ebp+8], eax
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [ebp+12], eax

; 84   : 			V->n1		= FA.N					;

	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebp+16], eax
	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR [ebp+20], eax
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [ebp+24], eax

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	ecx, BYTE PTR [edi+108]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, DWORD PTR $T3[esp+180]
	mov	eax, DWORD PTR $T4[esp+180]
	movzx	edx, al
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	eax, BYTE PTR [ebx+108]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	or	ecx, eax
	shl	ecx, 8
	or	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	mov	DWORD PTR [ebp+28], ecx

; 86   : 			V->t0		= FB.v[id].t			;

	mov	eax, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR [ebp+32], eax
	mov	DWORD PTR [ebp+36], ecx

; 87   : 			V->t1		= FA.v[id].t			;

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+100]
	mov	DWORD PTR [ebp+40], eax
	mov	DWORD PTR [ebp+44], ecx

; 88   : 			V->rgbh0	= FB.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [ebp+48], eax

; 89   : 			V->rgbh1	= FA.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR [ebp+52], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [ebp+56], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR [ebp+60], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+8]
	movss	DWORD PTR [ebp+64], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [ebx]
	movss	DWORD PTR [ebp+68], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [ebx+4]
	movss	DWORD PTR [ebp+72], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [ebx+8]
	movss	DWORD PTR [ebp+76], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 83   : 			V->n0		= FB.N					;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [ebp+80], eax
	mov	eax, DWORD PTR [edi+116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 83   : 			V->n0		= FB.N					;

	mov	DWORD PTR [ebp+84], eax
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [ebp+88], eax

; 84   : 			V->n1		= FA.N					;

	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebp+92], eax
	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR [ebp+96], eax
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [ebp+100], eax

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	ecx, BYTE PTR [edi+24]
	movzx	eax, BYTE PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, DWORD PTR $T3[esp+180]
	shl	ecx, 8
	or	ecx, eax
	shl	ecx, 8
	or	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	mov	DWORD PTR [ebp+104], ecx

; 86   : 			V->t0		= FB.v[id].t			;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [ebp+112], ecx
	mov	DWORD PTR [ebp+108], eax

; 87   : 			V->t1		= FA.v[id].t			;

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebp+120], ecx
	mov	DWORD PTR [ebp+116], eax

; 88   : 			V->rgbh0	= FB.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [ebp+124], eax

; 89   : 			V->rgbh1	= FA.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [ebp+128], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, DWORD PTR [edi+56]
	movss	DWORD PTR [ebp+132], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edi+60]
	movss	DWORD PTR [ebp+136], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+64]
	movss	DWORD PTR [ebp+140], xmm0
	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [ebx+56]
	movss	DWORD PTR [ebp+144], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [ebx+60]
	movss	DWORD PTR [ebp+148], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [ebx+64]
	movss	DWORD PTR [ebp+152], xmm0
	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 83   : 			V->n0		= FB.N					;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [ebp+156], eax
	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR [ebp+160], eax
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [ebp+164], eax

; 84   : 			V->n1		= FA.N					;

	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebp+168], eax
	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR [ebp+172], eax
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [ebp+176], eax

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	ecx, BYTE PTR [edi+80]
	movzx	eax, BYTE PTR [ebx+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, DWORD PTR $T3[esp+180]
	shl	ecx, 8
	or	ecx, eax
	shl	ecx, 8
	or	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	mov	DWORD PTR [ebp+180], ecx

; 86   : 			V->t0		= FB.v[id].t			;

	mov	eax, DWORD PTR [edi+68]
	mov	ecx, DWORD PTR [edi+72]
	mov	DWORD PTR [ebp+184], eax
	mov	DWORD PTR [ebp+188], ecx

; 87   : 			V->t1		= FA.v[id].t			;

	mov	eax, DWORD PTR [ebx+68]
	mov	ecx, DWORD PTR [ebx+72]
	mov	DWORD PTR [ebp+192], eax
	mov	DWORD PTR [ebp+196], ecx

; 88   : 			V->rgbh0	= FB.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [ebp+200], eax

; 89   : 			V->rgbh1	= FA.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR [ebp+204], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [ebp+208], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edi+32]
	movss	DWORD PTR [ebp+212], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+36]
	movss	DWORD PTR [ebp+216], xmm0
	addss	xmm3, DWORD PTR [ebx+28]
	movss	DWORD PTR [ebp+220], xmm3
	addss	xmm2, DWORD PTR [ebx+32]
	movss	DWORD PTR [ebp+224], xmm2
	addss	xmm1, DWORD PTR [ebx+36]
	movss	DWORD PTR [ebp+228], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 83   : 			V->n0		= FB.N					;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [ebp+232], eax
	mov	eax, DWORD PTR [edi+116]
	mov	DWORD PTR [ebp+236], eax
	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [ebp+240], eax

; 84   : 			V->n1		= FA.N					;

	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebp+244], eax
	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR [ebp+248], eax
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR [ebp+252], eax

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	ecx, BYTE PTR [edi+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	or	ecx, DWORD PTR $T3[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	movzx	eax, BYTE PTR [ebx+52]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	or	ecx, eax
	shl	ecx, 8
	or	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 85   : 			V->sun_af	= color_rgba			(FB.v[id].c_sun,FA.v[id].c_sun,uA,uF);

	mov	DWORD PTR [ebp+256], ecx

; 86   : 			V->t0		= FB.v[id].t			;

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [ebp+260], eax
	mov	DWORD PTR [ebp+264], ecx

; 87   : 			V->t1		= FA.v[id].t			;

	mov	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebp+268], eax
	mov	DWORD PTR [ebp+272], ecx

; 88   : 			V->rgbh0	= FB.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR _i$1$[esp+180]
	mov	edi, DWORD PTR _cur_count$1$[esp+180]
	inc	ecx
	mov	DWORD PTR [ebp+276], eax

; 89   : 			V->rgbh1	= FA.v[id].c_rgb_hemi	;

	mov	eax, DWORD PTR [ebx+48]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR _this$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 89   : 			V->rgbh1	= FA.v[id].c_rgb_hemi	;

	mov	DWORD PTR [ebp+280], eax
	add	ebp, 304				; 00000130H
	mov	DWORD PTR _i$1$[esp+180], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebx+544]
	mov	eax, DWORD PTR [ebx+548]
	sub	eax, edx
	mov	DWORD PTR $T2[esp+180], edx
	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 34   : 	for (u32 i=0; i<lstLODs.size(); i++)

	cmp	ecx, eax
	jb	$LL4@r_dsgraph_
	mov	DWORD PTR _cur_S$1$[esp+180], esi
$LN327@r_dsgraph_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+560]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 93   : 	lstLODgroups.push_back		(cur_count);

	lea	ebp, DWORD PTR [ebx+556]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ebp+8]
	je	SHORT $LN197@r_dsgraph_

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ebp+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN196@r_dsgraph_
$LN197@r_dsgraph_:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _cur_count$[esp+180]
	push	ecx
	push	eax
	mov	ecx, ebp
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>
$LN196@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 94   : 	RCache.Vertex.Unlock		(lstLODs.size()*4,firstV->geom->vb_stride);

	mov	eax, DWORD PTR _firstV$1$[esp+180]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	eax, DWORD PTR [eax+84]
	push	DWORD PTR [eax+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+548]
	sub	eax, DWORD PTR [ebx+544]
	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 94   : 	RCache.Vertex.Unlock		(lstLODs.size()*4,firstV->geom->vb_stride);

	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 95   : 
; 96   : 	// *** Render
; 97   : 	int current=0;
; 98   : 	RCache.set_xform_world		(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	xor	edi, edi
	mov	DWORD PTR _current$1$[esp+184], edi
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 99   : 	for (u32 g=0; g<lstLODgroups.size(); g++)	{

	xor	ecx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [ebp]
	sub	eax, edx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 99   : 	for (u32 g=0; g<lstLODgroups.size(); g++)	{

	mov	DWORD PTR _g$1$[esp+180], ecx
	test	eax, eax
	je	$LN12@r_dsgraph_
	npad	3
$LL13@r_dsgraph_:

; 100  : 		int p_count				= lstLODgroups[g];

	mov	eax, DWORD PTR [edx+ecx*4]

; 101  : 		RCache.set_Element		(lstLODs[current].pVisual->shader->E[shid]);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	DWORD PTR _p_count$1$[esp+180], eax
	mov	eax, DWORD PTR [ebx+544]
	push	0
	mov	eax, DWORD PTR [eax+edi*8+4]
	mov	eax, DWORD PTR [eax+64]
	add	eax, DWORD PTR tv4366[esp+184]
	push	eax
	call	DWORD PTR __imp_?set_Element@CBackend@@QAEXAAV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR _firstV$1$[esp+180]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 102  : 		RCache.set_Geometry		(firstV->geom);

	mov	edi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	ebp, DWORD PTR [eax+84]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [edi+592], edx
	je	SHORT $LN252@r_dsgraph_

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [edi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN252@r_dsgraph_:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	eax, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR __vb$1$[esp+180], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [edi+596], eax
	jne	SHORT $LN256@r_dsgraph_
	cmp	DWORD PTR [edi+604], edx
	je	SHORT $LN255@r_dsgraph_
$LN256@r_dsgraph_:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [edi+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [edi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	DWORD PTR __vb$1$[esp+188]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN255@r_dsgraph_:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ebp+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [edi+600], edx
	je	SHORT $LN259@r_dsgraph_

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [edi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN259@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 103  : 		RCache.Render			(D3DPT_TRIANGLELIST,vOffset,0,4*p_count,0,2*p_count);

	mov	eax, DWORD PTR _vOffset$[esp+180]
	mov	ebp, DWORD PTR _p_count$1$[esp+180]
	mov	DWORD PTR _baseV$1$[esp+180], eax
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [ebp*2]
	lea	edi, DWORD PTR [ebp*4]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 201  : 	stat.polys += PC;

	add	DWORD PTR [eax+9016], ecx

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], edi
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN265@r_dsgraph_
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN264@r_dsgraph_
$LN265@r_dsgraph_:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN264@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	lea	edx, DWORD PTR [ebp*2]
	push	edx
	push	0
	push	edi
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _baseV$1$[esp+196]
	mov	ecx, DWORD PTR [eax]
	push	4
	push	eax
	call	DWORD PTR [ecx+328]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 104  : 		RCache.stat.r.s_flora_lods.add	(4*p_count);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	ecx, DWORD PTR _g$1$[esp+180]

; 105  : 		current	+=	p_count		;

	add	DWORD PTR _current$1$[esp+180], ebp
	inc	ecx
	mov	DWORD PTR _g$1$[esp+180], ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 27   : 	ICF		void	add(u32 _verts) { verts += _verts; dips++; }

	add	DWORD PTR [eax+9064], edi
	inc	DWORD PTR [eax+9068]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+560]
	mov	edx, DWORD PTR [ebx+556]
	sub	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 106  : 		vOffset	+=	4*p_count	;

	add	DWORD PTR _vOffset$[esp+180], edi
	mov	edi, DWORD PTR _current$1$[esp+180]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 99   : 	for (u32 g=0; g<lstLODgroups.size(); g++)	{

	cmp	ecx, eax
	jb	$LL13@r_dsgraph_
	mov	esi, DWORD PTR _cur_S$1$[esp+180]
	lea	ebp, DWORD PTR [ebx+556]
$LN12@r_dsgraph_:

; 107  : 	}
; 108  : 
; 109  : 	lstLODs.clear		();
; 110  : 	lstLODgroups.clear	();
; 111  : 
; 112  : 	if (_clear)			mapLOD.clear			();

	cmp	BYTE PTR __clear$[esp+176], 0
	mov	eax, DWORD PTR [ebx+544]
	mov	DWORD PTR [ebx+548], eax
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ebp+4], eax
	je	SHORT $LN20@r_dsgraph_
	mov	DWORD PTR [ebx+380], 0
$LN20@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	test	esi, esi
	je	SHORT $LN276@r_dsgraph_
	add	DWORD PTR [esi], -1
	jne	SHORT $LN276@r_dsgraph_
	mov	ecx, esi
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN276@r_dsgraph_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_render_lods.cpp

; 113  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 164				; 000000a4H
	ret	8
?r_dsgraph_render_lods@R_dsgraph_structure@@QAEX_N0@Z ENDP ; R_dsgraph_structure::r_dsgraph_render_lods
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??A?$svector@U?$pair@MI@std@@$07@@QAEAAU?$pair@MI@std@@I@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
??A?$svector@U?$pair@MI@std@@$07@@QAEAAU?$pair@MI@std@@I@Z PROC ; svector<std::pair<float,unsigned int>,8>::operator[], COMDAT
; _this$ = ecx

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, DWORD PTR _id$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*8]
	ret	4
??A?$svector@U?$pair@MI@std@@$07@@QAEAAU?$pair@MI@std@@I@Z ENDP ; svector<std::pair<float,unsigned int>,8>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?push_back@?$svector@U?$pair@MI@std@@$07@@QAEXU?$pair@MI@std@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 8
?push_back@?$svector@U?$pair@MI@std@@$07@@QAEXU?$pair@MI@std@@@Z PROC ; svector<std::pair<float,unsigned int>,8>::push_back, COMDAT
; _this$ = ecx

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	edx, DWORD PTR [ecx+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	xmm0, DWORD PTR _e$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+64], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 277  :         first  = _Right.first;

	movss	DWORD PTR [ecx+edx*8], xmm0

; 278  :         second = _Right.second;

	mov	eax, DWORD PTR _e$[esp]
	mov	DWORD PTR [ecx+edx*8+4], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	ret	8
?push_back@?$svector@U?$pair@MI@std@@$07@@QAEXU?$pair@MI@std@@@Z ENDP ; svector<std::pair<float,unsigned int>,8>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?size@?$svector@U?$pair@MI@std@@$07@@QBEIXZ
_TEXT	SEGMENT
?size@?$svector@U?$pair@MI@std@@$07@@QBEIXZ PROC	; svector<std::pair<float,unsigned int>,8>::size, COMDAT
; _this$ = ecx

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [ecx+64]
	ret	0
?size@?$svector@U?$pair@MI@std@@$07@@QBEIXZ ENDP	; svector<std::pair<float,unsigned int>,8>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?end@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ
_TEXT	SEGMENT
?end@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ PROC ; svector<std::pair<float,unsigned int>,8>::end, COMDAT
; _this$ = ecx

; 27   : 	IC iterator	end	 ()						{ return array+count;					}

	mov	eax, DWORD PTR [ecx+64]
	lea	eax, DWORD PTR [ecx+eax*8]
	ret	0
?end@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ ENDP ; svector<std::pair<float,unsigned int>,8>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ?begin@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ
_TEXT	SEGMENT
?begin@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ PROC ; svector<std::pair<float,unsigned int>,8>::begin, COMDAT
; _this$ = ecx

; 26   : 	IC iterator	begin()						{ return array;							}

	mov	eax, ecx
	ret	0
?begin@?$svector@U?$pair@MI@std@@$07@@QAEPAU?$pair@MI@std@@XZ ENDP ; svector<std::pair<float,unsigned int>,8>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
;	COMDAT ??0?$svector@U?$pair@MI@std@@$07@@QAE@XZ
_TEXT	SEGMENT
??0?$svector@U?$pair@MI@std@@$07@@QAE@XZ PROC		; svector<std::pair<float,unsigned int>,8>::svector<std::pair<float,unsigned int>,8>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 134  :         : first(), second() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 22   : 	{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 134  :         : first(), second() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [ecx+64], 0

; 22   : 	{}

	ret	0
??0?$svector@U?$pair@MI@std@@$07@@QAE@XZ ENDP		; svector<std::pair<float,unsigned int>,8>::svector<std::pair<float,unsigned int>,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEAAHI@Z PROC	; xr_vector<int,doug_lea_alloc<int> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEAAHI@Z ENDP	; xr_vector<int,doug_lea_alloc<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@HV?$doug_lea_alloc@H@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@HV?$doug_lea_alloc@H@@@@QBEIXZ PROC	; xr_vector<int,doug_lea_alloc<int> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@HV?$doug_lea_alloc@H@@@@QBEIXZ ENDP	; xr_vector<int,doug_lea_alloc<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXABH@Z PROC ; std::vector<int,doug_lea_alloc<int> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXABH@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?A_TABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?A_TABH@Z PROC ; std::vector<int,doug_lea_alloc<int> >::emplace_back<int const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?A_TABH@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@AAE?A_TABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@AAE?A_TABH@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@AAE?A_TABH@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEAAU_LodItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEAAU_LodItem@R_dsgraph@@I@Z PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEAAU_LodItem@R_dsgraph@@I@Z ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QBEIXZ PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QBEIXZ ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBE_NXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBE_NXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z
_TEXT	SEGMENT
_D$ = 8							; size = 4
?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL, COMDAT
; _this$ = ecx

; 221  : 	{ if (pool)	getRL(nodes,D); }

	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN2@getRL
	push	DWORD PTR _D$[esp-4]
	push	DWORD PTR [ecx]
	call	?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
$LN2@getRL:
	ret	4
?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z
_TEXT	SEGMENT
_D$ = 8							; size = 4
?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR, COMDAT
; _this$ = ecx

; 217  : 	{ if (pool)	getLR(nodes,D); }

	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN2@getLR
	push	DWORD PTR _D$[esp-4]
	push	DWORD PTR [ecx]
	call	?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
$LN2@getLR:
	ret	4
?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXAAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?clear@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::clear, COMDAT
; _this$ = ecx

; 199  : 	IC void		clear()		{ pool=0;				}

	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@QAEXXZ ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??4?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAEAAV0@ABV0@@Z PROC ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator=, COMDAT
; _this$ = ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	push	esi
	push	edi
	mov	esi, ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	edi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN6@operator
	inc	DWORD PTR [edi]
$LN6@operator:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN21@operator
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN21@operator
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN21@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	mov	DWORD PTR [esi], edi
	mov	eax, esi
	pop	edi
	pop	esi
	ret	4
??4?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAEAAV0@ABV0@@Z ENDP ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??1?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@XZ PROC ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::~resptr_core<ShaderElement,resptr_base<ShaderElement> >, COMDAT
; _this$ = ecx

; 64   : 						~resptr_core	()												{	_dec();						}

	push	esi
	mov	esi, ecx

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@resptr_cor
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN8@resptr_cor
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN8@resptr_cor:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	ret	0
??1?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@XZ ENDP ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::~resptr_core<ShaderElement,resptr_base<ShaderElement> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@ABV0@@Z PROC ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::resptr_core<ShaderElement,resptr_base<ShaderElement> >, COMDAT
; _this$ = ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN6@resptr_cor
	inc	DWORD PTR [eax]
$LN6@resptr_cor:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, ecx
	ret	4
??0?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@QAE@ABV0@@Z ENDP ; resptr_core<ShaderElement,resptr_base<ShaderElement> >::resptr_core<ShaderElement,resptr_base<ShaderElement> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEAAU_LodItem@R_dsgraph@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEAAU_LodItem@R_dsgraph@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEAAU_LodItem@R_dsgraph@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEXPAH0@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ PROC	; std::vector<int,doug_lea_alloc<int> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ENDP	; std::vector<int,doug_lea_alloc<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,doug_lea_alloc<int> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@HV?$doug_lea_alloc@H@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,doug_lea_alloc<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1537 :     }

	ret	0
?size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@2@XZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@2@XZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z
_TEXT	SEGMENT
_N$ = 8							; size = 4
_D$ = 12						; size = 4
?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL, COMDAT
; _this$ = ecx

; 94   : 	{

	push	ebx
	push	esi
	mov	esi, DWORD PTR _N$[esp+4]
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR _D$[esp+8]
	npad	3
$LL177@getRL:

; 95   : 		if (N->right)	getRL(N->right,D);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN2@getRL
	push	edi
	push	eax
	mov	ecx, ebx
	call	?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
$LN2@getRL:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 96   : 		D.push_back		(N->val);

	lea	ecx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN63@getRL

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 8

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN62@getRL
$LN63@getRL:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ecx
	push	edx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
$LN62@getRL:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 97   : 		if (N->left)	getRL(N->left,D);

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	SHORT $LL177@getRL

; 98   : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	8
?getRL@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getRL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h
;	COMDAT ?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z
_TEXT	SEGMENT
_N$ = 8							; size = 4
_D$ = 12						; size = 4
?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z PROC ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR, COMDAT
; _this$ = ecx

; 88   : 	{

	push	ebx
	push	esi
	mov	esi, DWORD PTR _N$[esp+4]
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR _D$[esp+8]
	npad	3
$LL177@getLR:

; 89   : 		if (N->left)	getLR(N->left,D);

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN2@getLR
	push	edi
	push	eax
	mov	ecx, ebx
	call	?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
$LN2@getLR:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 90   : 		D.push_back		(N->val);

	lea	ecx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [edi+8]
	je	SHORT $LN63@getLR

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 8

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN62@getLR
$LN63@getLR:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	ecx
	push	edx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
$LN62@getLR:
; File I:\Vitalya\mine\NSProjectX\xrCore\fixedmap.h

; 91   : 		if (N->right)	getLR(N->right,D);

	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL177@getLR

; 92   : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	8
?getLR@?$FixedMAP@MU_LodItem@R_dsgraph@@Udoug_lea_allocator@@@@AAEXPAUTNode@1@AAV?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@@Z ENDP ; FixedMAP<float,R_dsgraph::_LodItem,doug_lea_allocator>::getLR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_set@?$resptr_base@UShaderElement@@@@QAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$resptr_base@UShaderElement@@@@QAEXABV1@@Z PROC	; resptr_base<ShaderElement>::_set, COMDAT
; _this$ = ecx

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	eax, DWORD PTR _rhs$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN4@set
	inc	DWORD PTR [esi]
$LN4@set:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN19@set
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN19@set
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN19@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 47   : 	ICF		void		_set	(resptr_base<T> const & rhs)		{	T* prhs = rhs._get(); _set(prhs);															}

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
	ret	4
?_set@?$resptr_base@UShaderElement@@@@QAEXABV1@@Z ENDP	; resptr_base<ShaderElement>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_dec@?$resptr_base@UShaderElement@@@@IAEXXZ
_TEXT	SEGMENT
?_dec@?$resptr_base@UShaderElement@@@@IAEXXZ PROC	; resptr_base<ShaderElement>::_dec, COMDAT
; _this$ = ecx

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@dec
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN6@dec
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN6@dec:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	ret	0
?_dec@?$resptr_base@UShaderElement@@@@IAEXXZ ENDP	; resptr_base<ShaderElement>::_dec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_inc@?$resptr_base@UShaderElement@@@@IAEXXZ
_TEXT	SEGMENT
?_inc@?$resptr_base@UShaderElement@@@@IAEXXZ PROC	; resptr_base<ShaderElement>::_inc, COMDAT
; _this$ = ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@inc
	inc	DWORD PTR [eax]
$LN1@inc:
	ret	0
?_inc@?$resptr_base@UShaderElement@@@@IAEXXZ ENDP	; resptr_base<ShaderElement>::_inc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEABU_LodItem@R_dsgraph@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEABU_LodItem@R_dsgraph@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEABU_LodItem@R_dsgraph@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAE@PAU_LodItem@R_dsgraph@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXABU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXABU_LodItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXABU_LodItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?A_TABU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?A_TABU_LodItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::emplace_back<R_dsgraph::_LodItem const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE?A_TABU_LodItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::emplace_back<R_dsgraph::_LodItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAE?A_TABU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAE?A_TABU_LodItem@R_dsgraph@@@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_LodItem const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAE?A_TABU_LodItem@R_dsgraph@@@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back_with_unused_capacity<R_dsgraph::_LodItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_set@?$resptr_base@UShaderElement@@@@QAEXPAUShaderElement@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?_set@?$resptr_base@UShaderElement@@@@QAEXPAUShaderElement@@@Z PROC ; resptr_base<ShaderElement>::_set, COMDAT
; _this$ = ecx

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	push	esi
	mov	esi, DWORD PTR _rhs$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN2@set
	inc	DWORD PTR [esi]
$LN2@set:

; 44   : 	void				_dec	()									{	if (0==p_) return;	p_->dwReference--; if (0==p_->dwReference) xr_delete(p_);				}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN17@set
	dec	DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN17@set
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN17@set:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
	ret	4
?_set@?$resptr_base@UShaderElement@@@@QAEXPAUShaderElement@@@Z ENDP ; resptr_base<ShaderElement>::_set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 3
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEXPAU_LodItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEXPAU_LodItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEXPAU_LodItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??$?8UShaderElement@@U0@V?$resptr_base@UShaderElement@@@@@@YA_NABV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@0@Z
_TEXT	SEGMENT
??$?8UShaderElement@@U0@V?$resptr_base@UShaderElement@@@@@@YA_NABV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@0@Z PROC ; operator==<ShaderElement,ShaderElement,resptr_base<ShaderElement> >, COMDAT
; _a$ = ecx
; _b$ = edx

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al
	ret	0
??$?8UShaderElement@@U0@V?$resptr_base@UShaderElement@@@@@@YA_NABV?$resptr_core@UShaderElement@@V?$resptr_base@UShaderElement@@@@@@0@Z ENDP ; operator==<ShaderElement,ShaderElement,resptr_base<ShaderElement> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@ABU01@@Z PROC ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>, COMDAT
; _this$ = ecx

; 277  :         first  = _Right.first;

	mov	eax, DWORD PTR __Right$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]

; 278  :         second = _Right.second;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 279  :         return *this;

	mov	eax, ecx

; 280  :     }

	ret	4
??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@ABU01@@Z ENDP ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??$mk_pair@MI@@YA?AU?$pair@MI@std@@MI@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
??$mk_pair@MI@@YA?AU?$pair@MI@std@@MI@Z PROC		; mk_pair<float,unsigned int>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val2$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	xmm0, DWORD PTR __Val1$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 207  : template	<class _Ty1, class _Ty2> inline	std::pair<_Ty1, _Ty2>		mk_pair		(_Ty1 _Val1, _Ty2 _Val2)	{	return (std::pair<_Ty1, _Ty2>(_Val1, _Val2));	}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	movss	DWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+4], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 207  : template	<class _Ty1, class _Ty2> inline	std::pair<_Ty1, _Ty2>		mk_pair		(_Ty1 _Val1, _Ty2 _Val2)	{	return (std::pair<_Ty1, _Ty2>(_Val1, _Val2));	}

	ret	0
??$mk_pair@MI@@YA?AU?$pair@MI@std@@MI@Z ENDP		; mk_pair<float,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXQAU?$pair@MI@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Pred$dead$ = 8					; size = 4
??$sort@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXQAU?$pair@MI@0@0P6A_NABU10@1@Z@Z PROC ; std::sort<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	sub	eax, ecx
	sar	eax, 3
	push	OFFSET ?pred_dot@@YA_NABU?$pair@MI@std@@0@Z ; pred_dot
	push	eax
	call	??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 8

; 7081 : }

	ret	0
??$sort@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXQAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ENDP ; std::sort<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU?$pair@MI@std@@@std@@YA?A_TABQAU?$pair@MI@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU?$pair@MI@std@@@std@@YA?A_TABQAU?$pair@MI@0@@Z PROC ; std::_Get_unwrapped<std::pair<float,unsigned int> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU?$pair@MI@std@@@std@@YA?A_TABQAU?$pair@MI@0@@Z ENDP ; std::_Get_unwrapped<std::pair<float,unsigned int> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0MI$0A@@?$pair@MI@std@@QAE@XZ
_TEXT	SEGMENT
??$?0MI$0A@@?$pair@MI@std@@QAE@XZ PROC			; std::pair<float,unsigned int>::pair<float,unsigned int><float,unsigned int,0>, COMDAT
; _this$ = ecx

; 134  :         : first(), second() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??$?0MI$0A@@?$pair@MI@std@@QAE@XZ ENDP			; std::pair<float,unsigned int>::pair<float,unsigned int><float,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAHABH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@HABH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAHABH@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@HABH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAHABH@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv550 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN78@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN76@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN76@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	lea	ecx, DWORD PTR [eax*4]
	call	_dlmalloc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv550[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	5
$LL26@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN25@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL26@Emplace_re
$LN25@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv550[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL39@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN38@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL39@Emplace_re
$LN38@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv550[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL52@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN51@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL52@Emplace_re
$LN51@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN61@Emplace_re
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN61@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$doug_lea_alloc@H@@QBEXPAHI@Z ; doug_lea_alloc<int>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN78@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@HV?$doug_lea_alloc@H@@@std@@CAXXZ ; std::vector<int,doug_lea_alloc<int> >::_Xlength
$LN75@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABH@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Emplace_reallocate<int const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@UShaderElement@@@@YAXAAPAUShaderElement@@@Z
_TEXT	SEGMENT
??$xr_delete@UShaderElement@@@@YAXAAPAUShaderElement@@@Z PROC ; xr_delete<ShaderElement>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@xr_delete
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@UShaderElement@@@@YAXAAPAUShaderElement@@@Z ENDP ; xr_delete<ShaderElement>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABU_LodItem@R_dsgraph@@@std@@YAABU_LodItem@R_dsgraph@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABU_LodItem@R_dsgraph@@@std@@YAABU_LodItem@R_dsgraph@@ABU12@@Z PROC ; std::forward<R_dsgraph::_LodItem const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABU_LodItem@R_dsgraph@@@std@@YAABU_LodItem@R_dsgraph@@ABU12@@Z ENDP ; std::forward<R_dsgraph::_LodItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_LodItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_LodItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@ABU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@U_LodItem@R_dsgraph@@ABU12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
tv542 = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newvec$ = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	edi, esi
	sub	edi, edx
	sar	edi, 3

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, edx
	sar	eax, 3

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 536870911				; 1fffffffH
	je	$LN78@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, edx
	sar	ecx, 3

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 536870911				; 1fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	jmp	SHORT $LN76@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN76@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	lea	ecx, DWORD PTR [eax*8]
	call	_dlmalloc
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$[ebp], eax

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR tv542[ebp], edx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	edi, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR __Newvec$[ebp]
	cmp	esi, edi
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], eax
	mov	esi, eax
	mov	DWORD PTR __Backout$4[ebp+4], esi
	mov	DWORD PTR __Backout$4[ebp+8], ebx
$LL26@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, edi
	je	SHORT $LN25@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx

; 1621 :         ++_Last;

	add	esi, 8
	mov	DWORD PTR __Backout$4[ebp+4], esi

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edx, 8
	mov	DWORD PTR __UFirst$7[ebp], edx
	jmp	SHORT $LL26@Emplace_re
$LN25@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], eax
	mov	edi, eax
	mov	DWORD PTR __Backout$3[ebp+4], edi
	mov	DWORD PTR __Backout$3[ebp+8], ebx
$LL39@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	je	SHORT $LN38@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 1621 :         ++_Last;

	add	edi, 8
	mov	DWORD PTR __Backout$3[ebp+4], edi

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	edx, 8
	mov	DWORD PTR __UFirst$6[ebp], edx
	jmp	SHORT $LL39@Emplace_re
$LN38@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	edx, DWORD PTR tv542[ebp]
	add	edx, 8

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edi, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], edx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LL52@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edi
	je	SHORT $LN51@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 1621 :         ++_Last;

	add	edx, 8
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 8
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL52@Emplace_re
$LN51@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN61@Emplace_re
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN61@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv542[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEXPAU_LodItem@R_dsgraph@@I@Z ; doug_lea_alloc<R_dsgraph::_LodItem>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN78@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@CAXXZ ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Xlength
$LN75@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABU_LodItem@R_dsgraph@@@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@QAU23@ABU23@@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_reallocate<R_dsgraph::_LodItem const &>
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@UShaderElement@@@@QAEXAAPAUShaderElement@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@UShaderElement@@@@QAEXAAPAUShaderElement@@@Z PROC ; xr_special_free<0,ShaderElement>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR _ptr$[esp]
	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@UShaderElement@@@@QAEXAAPAUShaderElement@@@Z ENDP ; xr_special_free<0,ShaderElement>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$doug_lea_alloc@H@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$doug_lea_alloc@H@@@std@@CAXXZ PROC ; std::vector<int,doug_lea_alloc<int> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@HV?$doug_lea_alloc@H@@@std@@CAXXZ ENDP ; std::vector<int,doug_lea_alloc<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXQAHII@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN2@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEII@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEII@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ PROC ; std::vector<int,doug_lea_alloc<int> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ENDP ; std::vector<int,doug_lea_alloc<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?construct@?$doug_lea_alloc@H@@QAEXPAHABH@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$doug_lea_alloc@H@@QAEXPAHABH@Z PROC	; doug_lea_alloc<int>::construct, COMDAT
; _this$dead$ = ecx

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$doug_lea_alloc@H@@QAEXPAHABH@Z ENDP	; doug_lea_alloc<int>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?allocate@?$doug_lea_alloc@H@@QBEPAHIPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$doug_lea_alloc@H@@QBEPAHIPBX@Z PROC		; doug_lea_alloc<int>::allocate, COMDAT
; _this$dead$ = ecx

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	eax, DWORD PTR _n$[esp-4]
	lea	ecx, DWORD PTR [eax*4]
	call	_dlmalloc
	ret	8
?allocate@?$doug_lea_alloc@H@@QBEPAHIPBX@Z ENDP		; doug_lea_alloc<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@CAXXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@CAXXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXQAU_LodItem@R_dsgraph@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXQAU_LodItem@R_dsgraph@@II@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	call	_dlfree
$LN2@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXQAU_LodItem@R_dsgraph@@II@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEII@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 536870911				; 1fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 536870911				; 1fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEII@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEPAU_LodItem@R_dsgraph@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEPAU_LodItem@R_dsgraph@@PAU34@00@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	ecx, edi
	je	SHORT $LN5@Umove
	push	esi
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	esi
$LN5@Umove:
	pop	edi

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEPAU_LodItem@R_dsgraph@@PAU34@00@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 536870911				; 1fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?construct@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@ABU23@@Z PROC ; doug_lea_alloc<R_dsgraph::_LodItem>::construct, COMDAT
; _this$dead$ = ecx

; 37   : 								void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
?construct@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@ABU23@@Z ENDP ; doug_lea_alloc<R_dsgraph::_LodItem>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?allocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEPAU_LodItem@R_dsgraph@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEPAU_LodItem@R_dsgraph@@IPBX@Z PROC ; doug_lea_alloc<R_dsgraph::_LodItem>::allocate, COMDAT
; _this$dead$ = ecx

; 33   : 								pointer					allocate		(size_type n, const void* p=0) const	{	return (T*)dlmalloc(sizeof(T)*(u32)n);	}

	mov	eax, DWORD PTR _n$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	call	_dlmalloc
	ret	8
?allocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEPAU_LodItem@R_dsgraph@@IPBX@Z ENDP ; doug_lea_alloc<R_dsgraph::_LodItem>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GShaderElement@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GShaderElement@@QAEPAXI@Z PROC			; ShaderElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1ShaderElement@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	4
??_GShaderElement@@QAEPAXI@Z ENDP			; ShaderElement::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEABV?$doug_lea_alloc@H@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEABV?$doug_lea_alloc@H@@XZ PROC ; std::vector<int,doug_lea_alloc<int> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@ABEABV?$doug_lea_alloc@H@@XZ ENDP ; std::vector<int,doug_lea_alloc<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ PROC ; std::vector<int,doug_lea_alloc<int> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@HV?$doug_lea_alloc@H@@@std@@QBEIXZ ENDP ; std::vector<int,doug_lea_alloc<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAIABV?$doug_lea_alloc@H@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAIABV?$doug_lea_alloc@H@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAIABV?$doug_lea_alloc@H@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@ABEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp]
	cmp	eax, edi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp+4]
	sub	esi, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+eax], ecx
	mov	DWORD PTR [esi+eax+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 8
	cmp	eax, edi
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 1547 :     }

	ret	0
?capacity@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QBEIXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 536870911				; 1fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAIABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@H@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@H@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@H@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?max_size@?$doug_lea_alloc@H@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$doug_lea_alloc@H@@QBEIXZ PROC		; doug_lea_alloc<int>::max_size, COMDAT
; _this$dead$ = ecx

; 39   : 								size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$doug_lea_alloc@H@@QBEIXZ ENDP		; doug_lea_alloc<int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QBEABV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?max_size@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEIXZ PROC ; doug_lea_alloc<R_dsgraph::_LodItem>::max_size, COMDAT
; _this$dead$ = ecx

; 39   : 								size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 536870911				; 1fffffffH
	ret	0
?max_size@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEIXZ ENDP ; doug_lea_alloc<R_dsgraph::_LodItem>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAMAAI$0A@@?$pair@MI@std@@QAE@AAMAAI@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAMAAI$0A@@?$pair@MI@std@@QAE@AAMAAI@Z PROC	; std::pair<float,unsigned int>::pair<float,unsigned int><float &,unsigned int &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	fld	DWORD PTR [eax]
	mov	eax, DWORD PTR __Val2$[esp-4]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAMAAI$0A@@?$pair@MI@std@@QAE@AAMAAI@Z ENDP	; std::pair<float,unsigned int>::pair<float,unsigned int><float &,unsigned int &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@PAU?$pair@MI@std@@PAU12@@std@@YAXABQAU?$pair@MI@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAU?$pair@MI@std@@PAU12@@std@@YAXABQAU?$pair@MI@0@0@Z PROC ; std::_Adl_verify_range<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@PAU?$pair@MI@std@@PAU12@@std@@YAXABQAU?$pair@MI@0@0@Z ENDP ; std::_Adl_verify_range<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NABU?$pair@MI@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@MI@0@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NABU?$pair@MI@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@MI@0@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?pred_dot@@YA_NABU?$pair@MI@std@@0@Z ; pred_dot

; 254  : }

	ret	0
??$_Pass_fn@P6A_NABU?$pair@MI@std@@0@Z$0A@@std@@YAP6A_NABU?$pair@MI@0@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Last$1$ = -40						; size = 4
tv1020 = -36						; size = 4
__Hole$1$ = -36						; size = 4
__Max_sequence_non_leaf$1$ = -32			; size = 4
tv1018 = -28						; size = 4
__Bottom$1$ = -28					; size = 4
__Mid$1$ = -28						; size = 4
tv1027 = -24						; size = 4
tv1026 = -20						; size = 4
__Val$1 = -20						; size = 8
__Val$2 = -12						; size = 8
__Val$3 = -12						; size = 8
__Mid$4 = -12						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z PROC ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ebp, DWORD PTR __Pred$[esp+48]
	mov	ebx, edx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Last$1$[esp+60], ebx
	mov	eax, ebx
	sub	eax, edi
	and	eax, -8					; fffffff8H
	cmp	eax, 256				; 00000100H
	jle	SHORT $LN214@Sort_unche
	mov	esi, DWORD PTR __Ideal$[esp+56]
$LL2@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	test	esi, esi
	jle	$LN215@Sort_unche

; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebp
	push	ebx
	mov	edx, edi
	lea	ecx, DWORD PTR __Mid$4[esp+68]
	call	??$_Partition_by_median_guess_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@MI@std@@PAU12@@0@PAU?$pair@MI@0@0P6A_NABU20@1@Z@Z ; std::_Partition_by_median_guess_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$4[esp+68]
	mov	eax, esi
	sar	eax, 2
	add	esp, 8
	sar	esi, 1
	mov	ecx, ebx
	mov	ebx, DWORD PTR __Mid$4[esp+64]
	add	esi, eax
	mov	eax, edx
	sub	ecx, ebx
	sub	eax, edi
	and	ecx, -8					; fffffff8H
	and	eax, -8					; fffffff8H
	push	ebp
	push	esi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, edi
	call	??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 7067 :             _First = _Mid.second;

	mov	edi, ebx

; 7068 :         } else { // loop on first half

	mov	ebx, DWORD PTR __Last$1$[esp+68]
	jmp	SHORT $LN244@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	edx, DWORD PTR __Last$1$[esp+68]
	mov	ecx, ebx
	call	??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$4[esp+68]
	mov	DWORD PTR __Last$1$[esp+68], ebx
$LN244@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebx
	add	esp, 8
	sub	eax, edi
	and	eax, -8					; fffffff8H
	cmp	eax, 256				; 00000100H
	jg	SHORT $LL2@Sort_unche
$LN214@Sort_unche:

; 6921 :     if (_First != _Last) {

	cmp	edi, ebx
	je	$LN59@Sort_unche

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	esi, DWORD PTR [edi+8]
	mov	DWORD PTR __Mid$1$[esp+60], esi
	cmp	esi, ebx
	je	$LN59@Sort_unche
	mov	DWORD PTR tv1020[esp+60], edi
$LL11@Sort_unche:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [esi]
	mov	ebx, esi
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __Val$1[esp+60], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$1[esp+60]
	push	edi
	push	eax
	mov	DWORD PTR __Val$1[esp+72], ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	$LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	esi, edi
	je	SHORT $LN23@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	mov	ecx, DWORD PTR tv1020[esp+60]
	add	ecx, 12					; 0000000cH
	npad	3
$LL222@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ecx-12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	ecx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [ecx+4]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, edi
	jne	SHORT $LL222@Sort_unche
$LN23@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$1[esp+60]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$1[esp+64]
	movss	DWORD PTR [edi], xmm0
	mov	DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	$LN19@Sort_unche
$LN215@Sort_unche:

; 5547 :     _Diff _Bottom = _Last - _First;

	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, ecx
	mov	DWORD PTR tv1026[esp+60], ecx
	sar	eax, 3

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+60], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN35@Sort_unche
	dec	eax
	mov	DWORD PTR tv1027[esp+60], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+60], eax
$LL34@Sort_unche:

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [edi+edx*8-8]
	dec	edx
	mov	DWORD PTR __Val$3[esp+60], eax

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+60]
	mov	esi, edx

; 5550 :         --_Hole;

	mov	DWORD PTR __Hole$1$[esp+60], edx

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ecx, DWORD PTR [edi+edx*8+4]
	mov	DWORD PTR __Val$3[esp+64], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN40@Sort_unche
	npad	12
$LL39@Sort_unche:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Sort_unche

; 5389 :             --_Idx;

	dec	esi
$LN41@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi+esi*8]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+esi*8+4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+60]
	cmp	esi, eax
	jl	SHORT $LL39@Sort_unche
	mov	edx, DWORD PTR __Hole$1$[esp+60]
$LN40@Sort_unche:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN42@Sort_unche
	mov	eax, DWORD PTR __Bottom$1$[esp+60]
	test	al, 1
	jne	SHORT $LN42@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi+eax*8-8]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+eax*8-4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv1027[esp+60]
$LN42@Sort_unche:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN242@Sort_unche
	npad	8
$LL51@Sort_unche:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	ecx, DWORD PTR __Val$3[esp+60]
	push	ecx
	lea	eax, DWORD PTR [edi+esi*8]
	push	eax
	call	ebp
	mov	edx, DWORD PTR __Hole$1$[esp+68]
	add	esp, 8
	test	al, al
	je	SHORT $LN242@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi+esi*8]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+esi*8+4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	edx, esi
	jl	SHORT $LL51@Sort_unche
$LN242@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$3[esp+60]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$3[esp+64]
	movss	DWORD PTR [edi+ebx*8], xmm0
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edx, edx
	jg	$LL34@Sort_unche
	mov	ebx, DWORD PTR __Last$1$[esp+60]
	mov	eax, DWORD PTR __Bottom$1$[esp+60]
	mov	ecx, DWORD PTR tv1026[esp+60]
$LN35@Sort_unche:

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	cmp	eax, 2
	jl	$LN59@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);

	lea	edx, DWORD PTR [ecx-8]
	add	ebx, -8					; fffffff8H
	mov	DWORD PTR tv1018[esp+60], edx
	npad	7
$LL60@Sort_unche:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [ebx]

; 5410 :     _Pop_heap_hole_by_index(

	mov	esi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR __Val$2[esp+60], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [ebx]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+edx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$2[esp+60]
	push	ebp
	push	eax

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$2[esp+72], ecx

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx
	sar	esi, 3
	mov	ecx, edi
	push	esi
	call	??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	edx, DWORD PTR tv1018[esp+72]

; 5410 :     _Pop_heap_hole_by_index(

	add	esp, 12					; 0000000cH

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	edx, 8
	sub	ebx, 8
	mov	DWORD PTR tv1018[esp+60], edx
	cmp	esi, 2
	jge	SHORT $LL60@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	0
$LN18@Sort_unche:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	eax, DWORD PTR tv1020[esp+60]
	mov	esi, eax
	push	eax
	lea	eax, DWORD PTR __Val$1[esp+64]
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Sort_unche
$LL16@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [esi]
	fstp	DWORD PTR [ebx]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	ebx, esi
	sub	esi, 8
	lea	eax, DWORD PTR __Val$1[esp+60]
	push	esi
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LL16@Sort_unche
$LN15@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$1[esp+60]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$1[esp+64]
	mov	esi, DWORD PTR __Mid$1$[esp+60]

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	DWORD PTR [ebx], xmm0

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	DWORD PTR [ebx+4], eax
$LN19@Sort_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	add	DWORD PTR tv1020[esp+60], 8
	add	esi, 8
	mov	DWORD PTR __Mid$1$[esp+60], esi
	cmp	esi, DWORD PTR __Last$1$[esp+60]
	jne	$LL11@Sort_unche
$LN59@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	0
??$_Sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0HP6A_NABU10@1@Z@Z ENDP ; std::_Sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$doug_lea_alloc@H@@@std@@YAPAHQAH0PAHAAV?$doug_lea_alloc@H@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAHV?$doug_lea_alloc@H@@@std@@YAPAHQAH0PAHAAV?$doug_lea_alloc@H@@@Z PROC ; std::_Uninitialized_move<int *,doug_lea_alloc<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAHV?$doug_lea_alloc@H@@@std@@YAPAHQAH0PAHAAV?$doug_lea_alloc@H@@@Z ENDP ; std::_Uninitialized_move<int *,doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAPAU_LodItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAU_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAPAU_LodItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_move<R_dsgraph::_LodItem *,doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN3@Uninitiali
	push	esi
	npad	4
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ecx+4]

; 1621 :         ++_Last;

	add	ecx, 8
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	add	eax, 8

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

	pop	esi
$LN3@Uninitiali:
	pop	edi

; 1722 : }

	ret	0
??$_Uninitialized_move@PAU_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAPAU_LodItem@R_dsgraph@@QAU12@0PAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_move<R_dsgraph::_LodItem *,doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAU_LodItem@R_dsgraph@@@std@@YA?A_TABQAU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAU_LodItem@R_dsgraph@@@std@@YA?A_TABQAU_LodItem@R_dsgraph@@@Z PROC ; std::_Get_unwrapped<R_dsgraph::_LodItem * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAU_LodItem@R_dsgraph@@@std@@YA?A_TABQAU_LodItem@R_dsgraph@@@Z ENDP ; std::_Get_unwrapped<R_dsgraph::_LodItem * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEPAU_LodItem@R_dsgraph@@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::~_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@PAU_LodItem@R_dsgraph@@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@PAU_LodItem@R_dsgraph@@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAE@PAU_LodItem@R_dsgraph@@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEPAHXZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::~_Uninitialized_backout_al<doug_lea_alloc<int> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::~_Uninitialized_backout_al<doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@PAHAAV?$doug_lea_alloc@H@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@PAHAAV?$doug_lea_alloc@H@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Uninitialized_backout_al<doug_lea_alloc<int> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAE@PAHAAV?$doug_lea_alloc@H@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Uninitialized_backout_al<doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAM@std@@YAAAMAAM@Z
_TEXT	SEGMENT
??$forward@AAM@std@@YAAAMAAM@Z PROC			; std::forward<float &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAM@std@@YAAAMAAM@Z ENDP			; std::forward<float &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@MI@0@QAU10@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
tv398 = -16						; size = 4
__Last$1$ = -12						; size = 4
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@MI@0@QAU10@0P6A_NABU10@1@Z@Z PROC ; std::_Insertion_sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	eax, edx
	mov	ebx, ecx
	mov	DWORD PTR __Last$1$[esp+24], eax
	push	esi
	push	edi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	ebx, eax
	je	$LN3@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebp, DWORD PTR [ebx+8]
	cmp	ebp, eax
	je	$LN3@Insertion_
	mov	esi, ebx
	mov	DWORD PTR tv398[esp+32], ebx
$LL2@Insertion_:

; 6923 :             _BidIt _Hole               = _Mid;
; 6924 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

	mov	eax, DWORD PTR [ebp]
	mov	edi, ebp
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR __Val$1[esp+32], eax

; 6925 : 
; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	lea	eax, DWORD PTR __Val$1[esp+32]
	push	ebx
	push	eax
	mov	DWORD PTR __Val$1[esp+44], ecx
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	ebp, ebx
	je	SHORT $LN14@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	lea	ecx, DWORD PTR [esi+12]
$LL29@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ecx-12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	ecx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [ecx+4]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, ebx
	jne	SHORT $LL29@Insertion_
$LN14@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$1[esp+32]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$1[esp+36]
	movss	DWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	DWORD PTR tv398[esp+32]
	lea	eax, DWORD PTR __Val$1[esp+36]
	push	eax
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
	npad	4
$LL7@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [esi]
	fstp	DWORD PTR [edi]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	edi, esi
	sub	esi, 8
	lea	eax, DWORD PTR __Val$1[esp+32]
	push	esi
	push	eax
	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	jne	SHORT $LL7@Insertion_
$LN6@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$1[esp+32]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$1[esp+36]
	mov	esi, DWORD PTR tv398[esp+32]

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	DWORD PTR [edi], xmm0

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	DWORD PTR [edi+4], eax
$LN10@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	eax, DWORD PTR __Last$1$[esp+32]
	add	ebp, 8
	add	esi, 8
	mov	DWORD PTR tv398[esp+32], esi
	cmp	ebp, eax
	jne	$LL2@Insertion_
$LN3@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down
; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole
; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;
; 6940 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAPAU?$pair@MI@0@QAU10@0P6A_NABU10@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Hole$1$ = -24						; size = 4
__Max_sequence_non_leaf$1$ = -20			; size = 4
__Bottom$1$ = -16					; size = 4
tv330 = -12						; size = 4
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z PROC ; std::_Make_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	eax, edx
	push	edi
	mov	edi, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	eax, edi
	sar	eax, 3

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	edx, eax
	mov	DWORD PTR __Bottom$1$[esp+40], eax
	sar	edx, 1
	test	edx, edx
	jle	$LN3@Make_heap_

; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	ebp, DWORD PTR __Pred$[esp+36]
	dec	eax
	mov	DWORD PTR tv330[esp+40], eax
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+40], eax
	npad	1
$LL2@Make_heap_:

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	eax, DWORD PTR [edi+edx*8-8]
	dec	edx
	mov	DWORD PTR __Val$1[esp+40], eax

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	mov	esi, edx

; 5549 :         // reheap top half, bottom to top
; 5550 :         --_Hole;

	mov	DWORD PTR __Hole$1$[esp+40], edx

; 5551 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

	mov	ecx, DWORD PTR [edi+edx*8+4]
	mov	DWORD PTR __Val$1[esp+44], ecx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	edx, eax
	jge	SHORT $LN8@Make_heap_
$LL7@Make_heap_:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [edi+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN9@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi+esi*8]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+esi*8+4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+40]
	cmp	esi, eax
	jl	SHORT $LL7@Make_heap_
	mov	edx, DWORD PTR __Hole$1$[esp+40]
$LN8@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN10@Make_heap_
	mov	eax, DWORD PTR __Bottom$1$[esp+40]
	test	al, 1
	jne	SHORT $LN10@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edi+eax*8-8]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [edi+eax*8-4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv330[esp+40]
$LN10@Make_heap_:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	edx, ebx
	jge	SHORT $LN37@Make_heap_
	npad	7
$LL19@Make_heap_:

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [ebx-1]
	sar	esi, 1

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	lea	eax, DWORD PTR __Val$1[esp+40]
	push	eax
	lea	ebp, DWORD PTR [edi+esi*8]
	push	ebp
	call	DWORD PTR __Pred$[esp+44]
	mov	edx, DWORD PTR __Hole$1$[esp+48]
	add	esp, 8
	test	al, al
	je	SHORT $LN38@Make_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebp]
	fstp	DWORD PTR [edi+ebx*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	edx, esi
	jl	SHORT $LL19@Make_heap_
$LN38@Make_heap_:
	mov	ebp, DWORD PTR __Pred$[esp+36]
$LN37@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	movss	xmm0, DWORD PTR __Val$1[esp+40]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR __Val$1[esp+44]
	movss	DWORD PTR [edi+ebx*8], xmm0
	mov	DWORD PTR [edi+ebx*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	test	edx, edx
	jg	$LL2@Make_heap_
$LN3@Make_heap_:

; 5553 :     }
; 5554 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Make_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Make_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z PROC ; std::_Sort_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	ebp, edx
	sub	ebp, ebx
	mov	eax, ebp
	and	eax, -8					; fffffff8H
	push	esi
	push	edi
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN3@Sort_heap_
	lea	edi, DWORD PTR [edx-8]
	add	ebp, -8					; fffffff8H
	npad	3
$LL4@Sort_heap_:

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edi]

; 5410 :     _Pop_heap_hole_by_index(

	mov	esi, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	xor	edx, edx

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	ecx, DWORD PTR [edi+4]

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+20]

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+28], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [edi]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx+ebp+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+28]
	push	eax

; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+36], ecx

; 5410 :     _Pop_heap_hole_by_index(

	mov	ecx, ebx
	sar	esi, 3
	push	esi
	call	??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 12					; 0000000cH

; 5773 :     // order heap by repeatedly popping
; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	edi, 8
	sub	ebp, 8
	cmp	esi, 2
	jge	SHORT $LL4@Sort_heap_
$LN3@Sort_heap_:

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Sort_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Sort_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@MI@std@@PAU12@@0@PAU?$pair@MI@0@0P6A_NABU20@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -20					; size = 4
__Plast$1$ = -16					; size = 4
$T1 = -12						; size = 4
__Glast$1$ = -12					; size = 4
$T2 = -8						; size = 4
tv887 = -8						; size = 4
__Last$1$ = -8						; size = 4
__Gfirst$1$ = -8					; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@MI@std@@PAU12@@0@PAU?$pair@MI@0@0P6A_NABU20@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+24]

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	esi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	esi, DWORD PTR __Last$[esp+28]
	mov	eax, esi
	sub	eax, edx
	mov	DWORD PTR ___$ReturnUdt$1$[esp+32], ecx
	sar	eax, 4
	push	edi

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR __First$1$[esp+36], edx
	mov	DWORD PTR __Last$1$[esp+36], ecx
	lea	ebx, DWORD PTR [edx+eax*8]

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, ecx
	sub	eax, edx
	sar	eax, 3

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@Partition_

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	edi, eax
	shl	edi, 4
	push	ebp
	lea	esi, DWORD PTR [eax*8]
	lea	ecx, DWORD PTR [esi+edx]
	lea	eax, DWORD PTR [edi+edx]
	mov	DWORD PTR $T1[esp+40], ecx
	mov	edx, ecx
	mov	ecx, DWORD PTR __First$1$[esp+40]
	push	eax
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	eax, DWORD PTR [esi+ebx]
	mov	ecx, ebx
	push	ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebx
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$1$[esp+52]
	mov	ecx, eax
	sub	ecx, esi
	push	ebp
	push	eax
	sub	eax, edi
	mov	DWORD PTR $T2[esp+60], ecx
	mov	edx, ecx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	esi, DWORD PTR __Last$[esp+56]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR $T2[esp+36]
	mov	eax, DWORD PTR $T1[esp+36]
	jmp	SHORT $LN36@Partition_
$LN35@Partition_:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	eax, edx
$LN36@Partition_:

; 6980 :     _RanIt _Pfirst = _Mid;

	push	ebp
	push	ecx
	mov	edx, ebx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 8

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR __Plast$1$[esp+36], edi

; 6982 : 
; 6983 :     while (_First < _Pfirst && !_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+36], ebx
	jae	SHORT $LN147@Partition_
	mov	esi, DWORD PTR __First$1$[esp+36]
$LL2@Partition_:
	lea	eax, DWORD PTR [ebx-8]
	push	ebx
	push	eax
	mov	DWORD PTR tv887[esp+44], eax
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN172@Partition_
	push	DWORD PTR tv887[esp+36]
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN172@Partition_

; 6985 :         --_Pfirst;

	mov	ebx, DWORD PTR tv887[esp+36]
	cmp	esi, ebx
	jb	SHORT $LL2@Partition_
$LN172@Partition_:
	mov	esi, DWORD PTR __Last$[esp+32]
$LN147@Partition_:

; 6986 :     }
; 6987 : 
; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	cmp	edi, esi
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	ebx
	push	edi
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN173@Partition_
	push	edi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN173@Partition_

; 6989 :         ++_Plast;

	add	edi, 8
	cmp	edi, esi
	jb	SHORT $LL4@Partition_
$LN173@Partition_:
	mov	DWORD PTR __Plast$1$[esp+36], edi
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;
; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	ebp, ebx
	mov	esi, edi
	mov	DWORD PTR __Glast$1$[esp+36], ebp
$LN177@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Gfirst$1$[esp+36], esi
$LN178@Partition_:
	mov	eax, DWORD PTR __Last$[esp+32]
$LL6@Partition_:
	cmp	esi, eax
	jae	SHORT $LN151@Partition_
	mov	ebp, DWORD PTR __Last$[esp+32]
	npad	1
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	esi
	push	ebx
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6998 :                 continue;
; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	ebx
	push	esi
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN174@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	edi, esi
	je	SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
	movss	xmm0, DWORD PTR [edi]
	fstp	DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [edi+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi+4], ecx
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	edi, 8
$LN9@Partition_:
	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL11@Partition_
$LN174@Partition_:
	mov	ebp, DWORD PTR __Glast$1$[esp+36]
	mov	DWORD PTR __Plast$1$[esp+36], edi
	mov	DWORD PTR __Gfirst$1$[esp+36], esi
$LN151@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+36]
	cmp	ebp, eax
	jbe	SHORT $LN176@Partition_
	mov	esi, DWORD PTR __Glast$1$[esp+36]
	mov	edi, eax
	lea	ebp, DWORD PTR [esi-8]
	npad	3
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	ebx
	push	ebp
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7011 :                 continue;
; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	ebp
	push	ebx
	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	jne	SHORT $LN175@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	ebx, 8
	cmp	ebx, ebp
	je	SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ebp]
	movss	xmm0, DWORD PTR [ebx]
	fstp	DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebp+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebp], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp+4], ecx
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	sub	esi, 8
	sub	ebp, 8
	cmp	edi, esi
	jb	SHORT $LL14@Partition_
$LN175@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+36]
	mov	edi, DWORD PTR __Plast$1$[esp+36]
	mov	DWORD PTR __Glast$1$[esp+36], esi
	mov	ebp, DWORD PTR __Glast$1$[esp+36]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	ebp, eax
	mov	esi, DWORD PTR __Gfirst$1$[esp+36]
$LN176@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	esi, DWORD PTR __Last$[esp+32]
	je	$LN153@Partition_

; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	edi, esi
	je	SHORT $LN75@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, edi
	je	SHORT $LN75@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	movss	xmm0, DWORD PTR [ebx]
	fstp	DWORD PTR [ebx]
	mov	eax, DWORD PTR [edi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+4], ecx
$LN75@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	edi, 8
	mov	DWORD PTR __Plast$1$[esp+36], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, esi
	je	SHORT $LN90@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
	movss	xmm0, DWORD PTR [ebx]
	fstp	DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi+4], ecx
$LN90@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	ebx, 8

; 7031 :             ++_Gfirst;

	add	esi, 8
	jmp	$LN177@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	mov	eax, DWORD PTR __Last$[esp+32]
	add	ebp, -8					; fffffff8H
	mov	DWORD PTR __Glast$1$[esp+36], ebp
	cmp	esi, eax
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	ebx, 8
	cmp	ebp, ebx
	je	SHORT $LN168@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ebx]
	movss	xmm0, DWORD PTR [ebp]
	fstp	DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebx], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebp+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR __Last$[esp+32]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebx+4], ecx
$LN168@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	edi, 8
	mov	DWORD PTR __Plast$1$[esp+36], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, edi
	je	$LL6@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	movss	xmm0, DWORD PTR [ebx]
	fstp	DWORD PTR [ebx]
	mov	eax, DWORD PTR [edi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LN178@Partition_
$LN30@Partition_:

; 7039 :             _STD iter_swap(_Gfirst, --_Glast);

	mov	DWORD PTR __Glast$1$[esp+36], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, ebp
	je	SHORT $LN135@Partition_

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [ebp]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	mov	eax, DWORD PTR [ebp+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [ebp], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __Last$[esp+32]

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [ebp+4], ecx
$LN135@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	esi, 8
	mov	DWORD PTR __Gfirst$1$[esp+36], esi

; 7041 :         }
; 7042 :     }

	jmp	$LL6@Partition_
$LN153@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+36]
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	edi
	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

	pop	ebx

; 7043 : }

	add	esp, 20					; 00000014H
	ret	0
??$_Partition_by_median_guess_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@MI@std@@PAU12@@0@PAU?$pair@MI@0@0P6A_NABU20@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEX$$QAH@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Emplace_back<int>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$doug_lea_alloc@H@@@std@@QAEX$$QAH@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<int> >::_Emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z PROC ; std::move<R_dsgraph::_LodItem &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z ENDP ; std::move<R_dsgraph::_LodItem &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@U_LodItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEX$$QAU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@U_LodItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEX$$QAU_LodItem@R_dsgraph@@@Z PROC ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back<R_dsgraph::_LodItem>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 8
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@U_LodItem@R_dsgraph@@@?$_Uninitialized_backout_al@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEX$$QAU_LodItem@R_dsgraph@@@Z ENDP ; std::_Uninitialized_backout_al<doug_lea_alloc<R_dsgraph::_LodItem> >::_Emplace_back<R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@$$QAU01@@Z PROC ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>, COMDAT
; _this$ = ecx

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR __Right$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 290  :         return *this;

	mov	eax, ecx

; 291  :     }

	ret	4
??$?4U?$pair@MI@std@@$0A@@?$pair@MI@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::pair<float,unsigned int>::operator=<std::pair<float,unsigned int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAU?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z PROC ; std::move<std::pair<float,unsigned int> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAU?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z ENDP ; std::move<std::pair<float,unsigned int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAU?$pair@MI@std@@PAU12@@std@@YAPAU?$pair@MI@0@PAU10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAU?$pair@MI@std@@PAU12@@std@@YAPAU?$pair@MI@0@PAU10@00@Z PROC ; std::_Move_backward_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4362 :     while (_First != _Last) {

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	edx, esi
	je	SHORT $LN3@Move_backw
	npad	5
$LL9@Move_backw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [edx-8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	edx, 8
	sub	eax, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [eax]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	edx, esi
	jne	SHORT $LL9@Move_backw
$LN3@Move_backw:
	pop	esi

; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;
; 4367 : }

	ret	0
??$_Move_backward_unchecked@PAU?$pair@MI@std@@PAU12@@std@@YAPAU?$pair@MI@0@PAU10@00@Z ENDP ; std::_Move_backward_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
tv308 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 8

; 5376 :     // percolate _Hole to _Bottom, then push _Val
; 5377 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 5378 : 
; 5379 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 5380 :     const _Diff _Top = _Hole;
; 5381 :     _Diff _Idx       = _Hole;
; 5382 : 
; 5383 :     // Check whether _Idx can have a child before calculating that child's index, since
; 5384 :     // calculating the child's index can trigger integer overflows
; 5385 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

	mov	eax, DWORD PTR __Bottom$[esp+4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, edx
	mov	ebx, ecx
	lea	edx, DWORD PTR [eax-1]
	mov	ecx, edi
	mov	ebp, edx
	mov	DWORD PTR tv308[esp+24], edx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	esi, edi
	sar	ebp, 1
	mov	DWORD PTR __Top$1$[esp+24], ecx
	cmp	edi, ebp
	jge	SHORT $LN3@Pop_heap_h
	npad	6
$LL2@Pop_heap_h:

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	lea	ecx, DWORD PTR [ebx+esi*8]
	lea	eax, DWORD PTR [ecx-8]
	push	eax
	push	ecx
	call	edx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	esi
$LN4@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebx+esi*8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	edx, DWORD PTR __Pred$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [ebx+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebx+esi*8+4]
	mov	DWORD PTR [ebx+edi*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	esi, ebp
	jl	SHORT $LL2@Pop_heap_h
	mov	eax, DWORD PTR __Bottom$[esp+20]
	mov	ecx, DWORD PTR __Top$1$[esp+24]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, ebp
	jne	SHORT $LN5@Pop_heap_h
	test	al, 1
	jne	SHORT $LN5@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebx+eax*8-8]
	fstp	DWORD PTR [ebx+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebx+eax*8-4]
	mov	DWORD PTR [ebx+edi*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	mov	edi, DWORD PTR tv308[esp+24]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	ecx, edi
	jge	SHORT $LN28@Pop_heap_h
	npad	8
$LL14@Pop_heap_h:
	push	DWORD PTR __Val$[esp+20]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	lea	ebp, DWORD PTR [ebx+esi*8]
	push	ebp
	call	edx
	add	esp, 8
	test	al, al
	je	SHORT $LN28@Pop_heap_h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	edx, DWORD PTR __Pred$[esp+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [ebx+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+edi*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$1$[esp+24], esi
	jl	SHORT $LL14@Pop_heap_h
$LN28@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR __Val$[esp+20]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ebx+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+edi*8+4], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5401 : }

	add	esp, 8
	ret	0
??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z PROC ; std::_Pop_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 12					; 0000000cH

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, edx
	push	esi
	mov	esi, ecx
	sub	eax, esi
	and	eax, -8					; fffffff8H
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN2@Pop_heap_u

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	eax, DWORD PTR [edx-8]
	sub	edx, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+12]

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+20], eax
	mov	ecx, DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fstp	DWORD PTR [edx]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+20]
	sub	edx, esi

; 5418 :         --_Last;
; 5419 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

	mov	DWORD PTR __Val$1[esp+24], ecx

; 5410 :     _Pop_heap_hole_by_index(

	sar	edx, 3
	mov	ecx, esi
	push	eax
	push	edx
	xor	edx, edx
	call	??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 12					; 0000000cH
$LN2@Pop_heap_u:

; 5420 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 5421 :     }
; 5422 : }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
??$_Pop_heap_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Pop_heap_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z PROC ; std::_Prev_iter<std::pair<float,unsigned int> *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-8]

; 1555 : }

	ret	0
??$_Prev_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z ENDP ; std::_Prev_iter<std::pair<float,unsigned int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Mid$1$ = -4						; size = 4
$T1 = 8							; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z PROC ; std::_Guess_median_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+4]
	mov	eax, ebx
	sub	eax, ecx
	push	ebp
	mov	ebp, edx
	sar	eax, 3

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	DWORD PTR __Mid$1$[esp+12], ebp
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3
	push	esi
	push	edi

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	mov	edi, eax
	lea	esi, DWORD PTR [eax*8]
	shl	edi, 4
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR $T1[esp+16], eax
	push	edx
	lea	eax, DWORD PTR [edi+ecx]
	push	eax
	lea	edx, DWORD PTR [esi+ecx]
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	push	DWORD PTR __Pred$[esp+24]
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebp
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	push	DWORD PTR __Pred$[esp+32]
	mov	ebp, ebx
	push	ebx
	sub	ebp, esi
	sub	ebx, edi
	mov	edx, ebp
	mov	ecx, ebx
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	edx, DWORD PTR __Pred$[esp+40]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR $T1[esp+16]

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);
; 6972 :     }
; 6973 : }

	mov	ecx, eax
	pop	edi
	pop	esi
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	push	ebp
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN2@Guess_medi:
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	mov	ebp, ebx
	mov	eax, ecx
	push	ebp
	call	??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Guess_median_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Guess_median_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z
_TEXT	SEGMENT
??$_Next_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z PROC ; std::_Next_iter<std::pair<float,unsigned int> *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+8]

; 1542 : }

	ret	0
??$_Next_iter@PAU?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@PAU10@@Z ENDP ; std::_Next_iter<std::pair<float,unsigned int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAU?$pair@MI@std@@PAU12@@std@@YAXPAU?$pair@MI@0@0@Z
_TEXT	SEGMENT
??$iter_swap@PAU?$pair@MI@std@@PAU12@@std@@YAXPAU?$pair@MI@0@0@Z PROC ; std::iter_swap<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi
	mov	esi, ecx

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edx
	je	SHORT $LN6@iter_swap

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx+4], ecx
$LN6@iter_swap:
	pop	esi

; 78   :     swap(*_Left, *_Right);
; 79   : }

	ret	0
??$iter_swap@PAU?$pair@MI@std@@PAU12@@std@@YAXPAU?$pair@MI@0@0@Z ENDP ; std::iter_swap<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAU?$pair@MI@std@@AAPAU01@$0A@@?$pair@PAU?$pair@MI@std@@PAU12@@std@@QAE@AAPAU?$pair@MI@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$pair@MI@std@@AAPAU01@$0A@@?$pair@PAU?$pair@MI@std@@PAU12@@std@@QAE@AAPAU?$pair@MI@1@0@Z PROC ; std::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *><std::pair<float,unsigned int> * &,std::pair<float,unsigned int> * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAU?$pair@MI@std@@AAPAU01@$0A@@?$pair@PAU?$pair@MI@std@@PAU12@@std@@QAE@AAPAU?$pair@MI@1@0@Z ENDP ; std::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>::pair<std::pair<float,unsigned int> *,std::pair<float,unsigned int> *><std::pair<float,unsigned int> * &,std::pair<float,unsigned int> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH$$QAH@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@HH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH$$QAH@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@HH@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH$$QAH@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z
_TEXT	SEGMENT
??$forward@U_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z PROC ; std::forward<R_dsgraph::_LodItem>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U_LodItem@R_dsgraph@@@std@@YA$$QAU_LodItem@R_dsgraph@@AAU12@@Z ENDP ; std::forward<R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@U_LodItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_LodItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@U_LodItem@R_dsgraph@@U12@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::construct<R_dsgraph::_LodItem,R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@I@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$forward@I@std@@YA$$QAIAAI@Z PROC			; std::forward<unsigned int>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@I@std@@YA$$QAIAAI@Z ENDP			; std::forward<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@U?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z PROC ; std::forward<std::pair<float,unsigned int> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@U?$pair@MI@std@@@std@@YA$$QAU?$pair@MI@0@AAU10@@Z ENDP ; std::forward<std::pair<float,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Push_heap_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebp
	push	edi
	mov	edi, edx
	mov	ebp, ecx

; 5265 :     // percolate _Hole to _Top or where _Val belongs
; 5266 :     using _Diff = _Iter_diff_t<_RanIt>;
; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen
; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+4], edi
	jge	SHORT $LN14@Push_heap_
	push	ebx
	push	esi
	npad	2
$LL4@Push_heap_:
	push	DWORD PTR __Val$[esp+12]
	lea	esi, DWORD PTR [edi-1]
	sar	esi, 1
	lea	ebx, DWORD PTR [esi*8]
	add	ebx, ebp
	push	ebx
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN15@Push_heap_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ebx]
	fstp	DWORD PTR [ebp+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+edi*8+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	cmp	DWORD PTR __Top$[esp+12], esi
	jl	SHORT $LL4@Push_heap_
$LN15@Push_heap_:
	pop	esi
	pop	ebx
$LN14@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	eax, DWORD PTR __Val$[esp+4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ebp+edi*8]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ebp+edi*8+4], eax
	pop	edi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5276 : }

	ret	0
??$_Push_heap_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Push_heap_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00$$QAU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00$$QAU10@P6A_NABU10@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Last$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	fld	DWORD PTR [ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5404 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 288  :         first  = _STD forward<_Ty1>(_Right.first);

	mov	esi, DWORD PTR __Dest$[esp]
	fstp	DWORD PTR [esi]

; 289  :         second = _STD forward<_Ty2>(_Right.second);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	pop	esi
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR __Dest$[esp-4], edx
	xor	edx, edx
	jmp	??$_Pop_heap_hole_by_index@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@HH$$QAU10@P6A_NABU10@2@Z@Z ; std::_Pop_heap_hole_by_index<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
??$_Pop_heap_hole_unchecked@PAU?$pair@MI@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00$$QAU10@P6A_NABU10@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<std::pair<float,unsigned int> *,std::pair<float,unsigned int>,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z PROC ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp

; 6944 :     // sort median of three elements to middle
; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx
	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN11@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN11@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+4], ecx
$LN11@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	esi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	ebx, esi
	je	SHORT $LN52@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
	movss	xmm0, DWORD PTR [ebx]
	fstp	DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [ebx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ebx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi+4], ecx
$LN52@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN41@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN41@Med3_unche

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	mov	eax, DWORD PTR [edi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edi+4], ecx
$LN41@Med3_unche:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAU?$pair@MI@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@MI@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Med3_unchecked<std::pair<float,unsigned int> *,bool (__cdecl*)(std::pair<float,unsigned int> const &,std::pair<float,unsigned int> const &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@MI$0A@@std@@YAXAAU?$pair@MI@0@0@Z
_TEXT	SEGMENT
??$swap@MI$0A@@std@@YAXAAU?$pair@MI@0@0@Z PROC		; std::swap<float,unsigned int,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 334  : _CONSTEXPR20 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {

	push	esi
	mov	esi, ecx

; 318  :         if (this != _STD addressof(_Right)) {

	cmp	esi, edx
	je	SHORT $LN4@swap

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	movss	xmm0, DWORD PTR [esi]
	fstp	DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [esi+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [esi+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx+4], ecx
$LN4@swap:
	pop	esi

; 335  :     _Left.swap(_Right);
; 336  : }

	ret	0
??$swap@MI$0A@@std@@YAXAAU?$pair@MI@0@0@Z ENDP		; std::swap<float,unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAU?$pair@MI@std@@@std@@YAAAPAU?$pair@MI@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$pair@MI@std@@@std@@YAAAPAU?$pair@MI@0@AAPAU10@@Z PROC ; std::forward<std::pair<float,unsigned int> * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAU?$pair@MI@std@@@std@@YAAAPAU?$pair@MI@0@AAPAU10@@Z ENDP ; std::forward<std::pair<float,unsigned int> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ?swap@?$pair@MI@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$pair@MI@std@@QAEXAAU12@@Z PROC			; std::pair<float,unsigned int>::swap, COMDAT
; _this$ = ecx

; 317  :         _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {

	push	esi

; 318  :         if (this != _STD addressof(_Right)) {

	mov	esi, DWORD PTR __Right$[esp]
	mov	edx, ecx
	cmp	edx, esi
	je	SHORT $LN2@swap

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [esi]
	movss	xmm0, DWORD PTR [edx]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+4]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [esi], xmm0

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [edx+4]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [edx+4], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [esi+4], ecx
$LN2@swap:
	pop	esi

; 319  :             _Swap_adl(first, _Right.first);
; 320  :             _Swap_adl(second, _Right.second);
; 321  :         }
; 322  :     }

	ret	4
?swap@?$pair@MI@std@@QAEXAAU12@@Z ENDP			; std::pair<float,unsigned int>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@AAU10@@Z PROC ; std::addressof<std::pair<float,unsigned int> >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@U?$pair@MI@std@@@std@@YAPAU?$pair@MI@0@AAU10@@Z ENDP ; std::addressof<std::pair<float,unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$_Swap_adl@M@std@@YAXAAM0@Z
_TEXT	SEGMENT
??$_Swap_adl@M@std@@YAXAAM0@Z PROC			; std::_Swap_adl<float>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	fld	DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	fstp	DWORD PTR [ecx]

; 102  :     _Right   = _STD move(_Tmp);

	movss	DWORD PTR [edx], xmm0

; 107  :     swap(_Left, _Right);
; 108  : }

	ret	0
??$_Swap_adl@M@std@@YAXAAM0@Z ENDP			; std::_Swap_adl<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$_Swap_adl@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
??$_Swap_adl@I@std@@YAXAAI0@Z PROC			; std::_Swap_adl<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]

; 106  : _CONSTEXPR20 void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {

	push	esi

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	esi, DWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 107  :     swap(_Left, _Right);
; 108  : }

	ret	0
??$_Swap_adl@I@std@@YAXAAI0@Z ENDP			; std::_Swap_adl<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$swap@I$0A@@std@@YAXAAI0@Z
_TEXT	SEGMENT
??$swap@I$0A@@std@@YAXAAI0@Z PROC			; std::swap<unsigned int,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 102  :     _Right   = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 103  : }

	ret	0
??$swap@I$0A@@std@@YAXAAI0@Z ENDP			; std::swap<unsigned int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?deallocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEXPAU_LodItem@R_dsgraph@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEXPAU_LodItem@R_dsgraph@@I@Z PROC ; doug_lea_alloc<R_dsgraph::_LodItem>::deallocate, COMDAT
; _this$dead$ = ecx

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	mov	ecx, DWORD PTR _p$[esp-4]
	call	_dlfree
	ret	8
?deallocate@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QBEXPAU_LodItem@R_dsgraph@@I@Z ENDP ; doug_lea_alloc<R_dsgraph::_LodItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?deallocate@?$doug_lea_alloc@H@@QBEXPAHI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$doug_lea_alloc@H@@QBEXPAHI@Z PROC		; doug_lea_alloc<int>::deallocate, COMDAT
; _this$dead$ = ecx

; 35   : 								void					deallocate		(pointer p, size_type n) const			{	dlfree	(p);				}

	mov	ecx, DWORD PTR _p$[esp-4]
	call	_dlfree
	ret	8
?deallocate@?$doug_lea_alloc@H@@QBEXPAHI@Z ENDP		; doug_lea_alloc<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?destroy@?$doug_lea_alloc@H@@QAEXPAH@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$doug_lea_alloc@H@@QAEXPAH@Z PROC		; doug_lea_alloc<int>::destroy, COMDAT
; _this$dead$ = ecx

; 38   : 								void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$doug_lea_alloc@H@@QAEXPAH@Z ENDP		; doug_lea_alloc<int>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@H@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH@Z
_TEXT	SEGMENT
??$destroy@H@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::destroy<int>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@H@?$_Normal_allocator_traits@V?$doug_lea_alloc@H@@@std@@SAXAAV?$doug_lea_alloc@H@@PAH@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$doug_lea_alloc@H@@@std@@YAXPAHQAHAAV?$doug_lea_alloc@H@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$doug_lea_alloc@H@@@std@@YAXPAHQAHAAV?$doug_lea_alloc@H@@@Z PROC ; std::_Destroy_range<doug_lea_alloc<int> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$doug_lea_alloc@H@@@std@@YAXPAHQAHAAV?$doug_lea_alloc@H@@@Z ENDP ; std::_Destroy_range<doug_lea_alloc<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@H@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@H@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@H@@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@H@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEAAV?$doug_lea_alloc@H@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEAAV?$doug_lea_alloc@H@@XZ PROC ; std::vector<int,doug_lea_alloc<int> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEAAV?$doug_lea_alloc@H@@XZ ENDP ; std::vector<int,doug_lea_alloc<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH0@Z PROC ; std::vector<int,doug_lea_alloc<int> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@HV?$doug_lea_alloc@H@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,doug_lea_alloc<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXXZ PROC	; std::vector<int,doug_lea_alloc<int> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@HV?$doug_lea_alloc@H@@@std@@QAEXXZ ENDP	; std::vector<int,doug_lea_alloc<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ PROC ; xr_vector<int,doug_lea_alloc<int> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ ENDP ; xr_vector<int,doug_lea_alloc<int> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ PROC	; xr_vector<int,doug_lea_alloc<int> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@HV?$doug_lea_alloc@H@@@@QAEXXZ ENDP	; xr_vector<int,doug_lea_alloc<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU_LodItem@R_dsgraph@@@std@@YAXAAPAU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU_LodItem@R_dsgraph@@@std@@YAXAAPAU_LodItem@R_dsgraph@@@Z PROC ; std::_Destroy_in_place<R_dsgraph::_LodItem *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAU_LodItem@R_dsgraph@@@std@@YAXAAPAU_LodItem@R_dsgraph@@@Z ENDP ; std::_Destroy_in_place<R_dsgraph::_LodItem *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\r__dsgraph_types.h
;	COMDAT ?destroy@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@@Z PROC ; doug_lea_alloc<R_dsgraph::_LodItem>::destroy, COMDAT
; _this$dead$ = ecx

; 38   : 								void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@QAEXPAU_LodItem@R_dsgraph@@@Z ENDP ; doug_lea_alloc<R_dsgraph::_LodItem>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@U_LodItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@@Z
_TEXT	SEGMENT
??$destroy@U_LodItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@@Z PROC ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::destroy<R_dsgraph::_LodItem>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@U_LodItem@R_dsgraph@@@?$_Normal_allocator_traits@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@SAXAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@PAU_LodItem@R_dsgraph@@@Z ENDP ; std::_Normal_allocator_traits<doug_lea_alloc<R_dsgraph::_LodItem> >::destroy<R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_LodItem@R_dsgraph@@@std@@YAPAU_LodItem@R_dsgraph@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@U_LodItem@R_dsgraph@@@std@@YAPAU_LodItem@R_dsgraph@@PAU12@@Z PROC ; std::_Unfancy<R_dsgraph::_LodItem>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@U_LodItem@R_dsgraph@@@std@@YAPAU_LodItem@R_dsgraph@@PAU12@@Z ENDP ; std::_Unfancy<R_dsgraph::_LodItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAXPAU_LodItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAXPAU_LodItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z PROC ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_LodItem> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@YAXPAU_LodItem@R_dsgraph@@QAU12@AAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@Z ENDP ; std::_Destroy_range<doug_lea_alloc<R_dsgraph::_LodItem> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ PROC ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@V?$_Vector_val@U?$_Simple_types@U_LodItem@R_dsgraph@@@std@@@std@@$00@std@@QAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ENDP ; std::_Compressed_pair<doug_lea_alloc<R_dsgraph::_LodItem>,std::_Vector_val<std::_Simple_types<R_dsgraph::_LodItem> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEAAV?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@XZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@0@Z PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@AAEXPAU_LodItem@R_dsgraph@@0@Z ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXXZ PROC ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@std@@QAEXXZ ENDP ; std::vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ PROC ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@U_LodItem@R_dsgraph@@V?$doug_lea_alloc@U_LodItem@R_dsgraph@@@@@@QAEXXZ ENDP ; xr_vector<R_dsgraph::_LodItem,doug_lea_alloc<R_dsgraph::_LodItem> >::clear
_TEXT	ENDS
END
