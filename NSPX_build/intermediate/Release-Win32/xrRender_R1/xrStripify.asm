; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\xrstripify.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??0?$xalloc@UPrimitiveGroup@@@@QAE@XZ		; xalloc<PrimitiveGroup>::xalloc<PrimitiveGroup>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PrimitiveGroup> >::_Vector_val<std::_Simple_types<PrimitiveGroup> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1><>
PUBLIC	?clear@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear
PUBLIC	??0?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
PUBLIC	?_Tidy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXXZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Tidy
PUBLIC	?clear_and_free@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear_and_free
PUBLIC	??1?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
PUBLIC	??0?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
PUBLIC	?clear@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear
PUBLIC	??1?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
PUBLIC	?xrSimulate@@YAHAAV?$xr_vector@GV?$xalloc@G@@@@H@Z ; xrSimulate
PUBLIC	?xrStripify@@YAXAAV?$xr_vector@GV?$xalloc@G@@@@0HH@Z ; xrStripify
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
_TEXT	SEGMENT
_numGroups$1$ = -36					; size = 4
_perturb$1$ = -32					; size = 4
_indices$1$ = -28					; size = 4
_xPGROUP$ = -24						; size = 12
_PGROUP$ = -12						; size = 12
$T2 = 8							; size = 1
_iCacheSize$ = 8					; size = 4
_iMinStripLength$dead$ = 12				; size = 4
?xrStripify@@YAXAAV?$xr_vector@GV?$xalloc@G@@@@0HH@Z PROC ; xrStripify
; _indices$ = ecx
; _perturb$ = edx

; 23   : {

	sub	esp, 36					; 00000024H

; 24   : 	SetCacheSize	(iCacheSize);

	mov	eax, DWORD PTR _iCacheSize$[esp+32]
	push	ebx
	mov	ebx, edx
	mov	DWORD PTR ?cacheSize@@3IA, eax
	mov	edx, ecx
	mov	DWORD PTR _perturb$1$[esp+40], ebx
	push	ebp
	mov	DWORD PTR _indices$1$[esp+44], edx

; 30   : 	GenerateStrips	(&*indices.begin(),indices.size(),PGROUP);

	lea	eax, DWORD PTR _PGROUP$[esp+44]
	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	sub	edx, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 25   : 	SetMinStripSize	(iMinStripLength);

	mov	DWORD PTR ?minStripSize@@3IA, 0
	push	edi

; 30   : 	GenerateStrips	(&*indices.begin(),indices.size(),PGROUP);

	push	eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edx, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 26   : 	SetListsOnly	(true);

	mov	BYTE PTR ?bListsOnly@@3_NA, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _PGROUP$[esp+56], 0
	mov	DWORD PTR _PGROUP$[esp+60], 0
	mov	DWORD PTR _PGROUP$[esp+64], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 30   : 	GenerateStrips	(&*indices.begin(),indices.size(),PGROUP);

	call	?GenerateStrips@@YAXPBGHAAV?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@@Z ; GenerateStrips
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 30   : 	GenerateStrips	(&*indices.begin(),indices.size(),PGROUP);

	add	esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, DWORD PTR [ebx]
	sar	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 37   : 	RemapIndices	(PGROUP,u16(perturb.size()),xPGROUP);

	movzx	esi, ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _PGROUP$[esp+56]
	sub	eax, DWORD PTR _PGROUP$[esp+52]
	sar	eax, 2
	imul	ebp, eax, -1431655765

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _xPGROUP$[esp+52], 0
	mov	DWORD PTR _xPGROUP$[esp+56], 0
	mov	DWORD PTR _xPGROUP$[esp+60], 0

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _numGroups$1$[esp+52], ebp

; 1259 :         if (_Newsize > _Oldsize) { // append

	test	ebp, ebp
	je	SHORT $LL83@xrStripify

; 1260 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1261 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1262 :                 _Resize_reallocate(_Newsize, _Val);

	lea	eax, DWORD PTR $T2[esp+48]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR _xPGROUP$[esp+60]
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Resize_reallocate<std::_Value_init_tag>
$LL83@xrStripify:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	esi, 2
	push	esi
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 244  : 	FillMemory	(indexCache, sizeof(int)*numVerts, -1);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	ebx, eax
	push	esi
	push	-1
	push	ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	ecx

; 245  : 	
; 246  : 	//loop over primitive groups
; 247  : 	unsigned int indexCtr = 0;

	xor	edi, edi

; 248  : 	for(int i = 0; i < numGroups; i++)

	test	ebp, ebp
	jle	$LN59@xrStripify

; 243  : 	indexCache	= xr_alloc<int> (numVerts);

	xor	esi, esi
$LL60@xrStripify:

; 249  : 	{
; 250  : 		unsigned int numIndices = in_primGroups[i].numIndices;

	mov	eax, DWORD PTR _PGROUP$[esp+52]

; 251  : 
; 252  : 		//init remapped group
; 253  : 		remappedGroups[i].type       = in_primGroups[i].type;

	mov	ecx, DWORD PTR [esi+eax]
	mov	ebp, DWORD PTR [esi+eax+4]
	mov	eax, DWORD PTR _xPGROUP$[esp+52]
	mov	DWORD PTR [esi+eax], ecx

; 254  : 		remappedGroups[i].numIndices = numIndices;

	mov	eax, DWORD PTR _xPGROUP$[esp+52]
	mov	DWORD PTR [esi+eax+4], ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ebp*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 255  : 		remappedGroups[i].indices    = xr_alloc<u16>	(numIndices);

	mov	ecx, DWORD PTR _xPGROUP$[esp+52]
	mov	DWORD PTR [esi+ecx+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	xor	eax, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\NvTriStrip.cpp

; 257  : 		for(int j = 0; j < numIndices; j++)

	test	ebp, ebp
	je	SHORT $LN58@xrStripify
	npad	2
$LL63@xrStripify:

; 258  : 		{
; 259  : 			int cachedIndex = indexCache[in_primGroups[i].indices[j]];

	mov	ecx, DWORD PTR _PGROUP$[esp+52]
	mov	ecx, DWORD PTR [esi+ecx+8]
	movzx	ecx, WORD PTR [ecx+eax*2]
	mov	edx, DWORD PTR [ebx+ecx*4]

; 260  : 			if(cachedIndex == -1) //we haven't seen this index before

	mov	ecx, DWORD PTR _xPGROUP$[esp+52]
	mov	ecx, DWORD PTR [esi+ecx+8]
	cmp	edx, -1
	jne	SHORT $LN222@xrStripify

; 261  : 			{
; 262  : 				//point to "last" vertex in VB
; 263  : 				remappedGroups[i].indices[j] = u16(indexCtr);

	mov	WORD PTR [ecx+eax*2], di

; 264  : 
; 265  : 				//add to index cache, increment
; 266  : 				indexCache[in_primGroups[i].indices[j]] = indexCtr++;

	mov	ecx, DWORD PTR _PGROUP$[esp+52]
	mov	ecx, DWORD PTR [esi+ecx+8]
	movzx	ecx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR [ebx+ecx*4], edi
	inc	edi

; 267  : 			}

	jmp	SHORT $LN61@xrStripify
$LN222@xrStripify:

; 268  : 			else
; 269  : 			{
; 270  : 				//we've seen this index before
; 271  : 				remappedGroups[i].indices[j] = u16(cachedIndex);

	mov	WORD PTR [ecx+eax*2], dx
$LN61@xrStripify:

; 257  : 		for(int j = 0; j < numIndices; j++)

	inc	eax
	cmp	eax, ebp
	jb	SHORT $LL63@xrStripify
$LN58@xrStripify:

; 248  : 	for(int i = 0; i < numGroups; i++)

	add	esi, 12					; 0000000cH
	sub	DWORD PTR _numGroups$1$[esp+52], 1
	jne	$LL60@xrStripify
$LN59@xrStripify:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ebp, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	ebx, ebx
	je	SHORT $LN13@xrStripify
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	ebx
	call	ebp
$LN13@xrStripify:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 42   : 	for(u32 index = 0; index < PGROUP[0].numIndices; index++)

	mov	eax, DWORD PTR _PGROUP$[esp+52]
	xor	edi, edi
	cmp	DWORD PTR [eax+4], edi
	jbe	SHORT $LN18@xrStripify
	mov	ebx, DWORD PTR _perturb$1$[esp+52]
	npad	5
$LL242@xrStripify:

; 43   : 	{
; 44   : 		u16 oldIndex = PGROUP[0].indices	[index];
; 45   : 		int newIndex = xPGROUP[0].indices	[index];
; 46   : 		VERIFY(oldIndex<(int)perturb.size());
; 47   : 		VERIFY(newIndex<(int)perturb.size());
; 48   : 		perturb[newIndex] = oldIndex;

	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _xPGROUP$[esp+52]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+8]
	movzx	edx, WORD PTR [eax+edi*2]
	mov	ax, WORD PTR [esi+edi*2]
	inc	edi
	mov	WORD PTR [ecx+edx*2], ax
	mov	eax, DWORD PTR _PGROUP$[esp+52]
	cmp	edi, DWORD PTR [eax+4]
	jb	SHORT $LL242@xrStripify
$LN18@xrStripify:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _indices$1$[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 52   : 	CopyMemory	(&*indices.begin(),xPGROUP[0].indices,indices.size()*sizeof(u16));

	and	eax, -2					; fffffffeH
	push	eax
	mov	eax, DWORD PTR _xPGROUP$[esp+56]
	push	DWORD PTR [eax+8]
	push	ecx
	call	_memcpy

; 53   : 
; 54   : 	// Release memory
; 55   : 	xPGROUP.clear	();

	mov	ecx, DWORD PTR _xPGROUP$[esp+64]
	add	esp, 12					; 0000000cH

; 56   : 	PGROUP.clear	();

	mov	eax, DWORD PTR _PGROUP$[esp+52]
	mov	DWORD PTR _xPGROUP$[esp+56], ecx
	mov	DWORD PTR _PGROUP$[esp+56], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN339@xrStripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1756 :             _Myend   = nullptr;

	mov	eax, DWORD PTR _PGROUP$[esp+52]
	mov	DWORD PTR _xPGROUP$[esp+52], 0
	mov	DWORD PTR _xPGROUP$[esp+56], 0
	mov	DWORD PTR _xPGROUP$[esp+60], 0
$LN339@xrStripify:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN356@xrStripify
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebp
$LN356@xrStripify:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 57   : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?xrStripify@@YAXAAV?$xr_vector@GV?$xalloc@G@@@@0HH@Z ENDP ; xrStripify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_indices$1$ = -16					; size = 4
_C$ = -12						; size = 12
?xrSimulate@@YAHAAV?$xr_vector@GV?$xalloc@G@@@@H@Z PROC	; xrSimulate
; _indices$ = ecx
; _iCacheSize$ = edx

; 8    : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	lea	eax, DWORD PTR $T1[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _C$[esp+32], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 8    : {

	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _C$[esp+36], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	push	eax
	push	edx
	lea	ecx, DWORD PTR _C$[esp+40]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 8    : {

	mov	DWORD PTR _indices$1$[esp+40], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR _C$[esp+48], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.cpp

; 12   : 	entries.assign	(size,-1);

	mov	DWORD PTR $T1[esp+40], -1
	call	?assign@?$vector@HV?$xalloc@H@@@std@@QAEXIABH@Z ; std::vector<int,xalloc<int> >::assign
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 11   : 	int count=0;

	xor	ebp, ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 12   : 	for (u32 i=0; i<indices.size(); i++)

	xor	ebx, ebx
	mov	ecx, DWORD PTR _C$[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	eax, edx
	sar	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 12   : 	for (u32 i=0; i<indices.size(); i++)

	je	SHORT $LN3@xrSimulate
	mov	esi, DWORD PTR _C$[esp+36]
	sub	esi, ecx
	sar	esi, 2
	push	edi
$LL4@xrSimulate:

; 13   : 	{
; 14   : 		int id = indices[i];

	movzx	edi, WORD PTR [edx+ebx*2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	xor	eax, eax
	test	esi, esi
	je	SHORT $LN173@xrSimulate
$LL41@xrSimulate:

; 29   : 	{
; 30   : 		if(entries[i] == entry)

	cmp	DWORD PTR [ecx+eax*4], edi
	je	SHORT $LN2@xrSimulate

; 28   : 	for(u32 i = 0; i < entries.size(); i++)

	inc	eax
	cmp	eax, esi
	jb	SHORT $LL41@xrSimulate
$LN173@xrSimulate:

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	lea	edx, DWORD PTR [esi-2]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 16   : 		count			++;

	inc	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\VertexCache.h

; 48   : 	for(int i = (u32)entries.size() - 2; i >= 0; i--)

	test	edx, edx
	js	SHORT $LN132@xrSimulate
$LL68@xrSimulate:

; 49   : 	{
; 50   : 		entries[i + 1] = entries[i];

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edx*4+4], eax
	sub	edx, 1
	jns	SHORT $LL68@xrSimulate
$LN132@xrSimulate:

; 51   : 	}
; 52   : 
; 53   : 	entries[0] = entry;

	mov	DWORD PTR [ecx], edi
$LN2@xrSimulate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR _indices$1$[esp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 12   : 	for (u32 i=0; i<indices.size(); i++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, edx
	sar	eax, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 12   : 	for (u32 i=0; i<indices.size(); i++)

	cmp	ebx, eax
	jb	SHORT $LL4@xrSimulate
	pop	edi
$LN3@xrSimulate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN174@xrSimulate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	ecx
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN174@xrSimulate:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\xrStripify.cpp

; 20   : }

	mov	eax, ebp
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
?xrSimulate@@YAHAAV?$xr_vector@GV?$xalloc@G@@@@H@Z ENDP	; xrSimulate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAE@XZ ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~vector<PrimitiveGroup,xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::~vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ PROC ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@@QAEXXZ ENDP ; xr_vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@AAEXXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAE@XZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ PROC ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@UPrimitiveGroup@@V?$xalloc@UPrimitiveGroup@@@@@std@@QAEXXZ ENDP ; std::vector<PrimitiveGroup,xalloc<PrimitiveGroup> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@UPrimitiveGroup@@@@V?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1>::_Compressed_pair<xalloc<PrimitiveGroup>,std::_Vector_val<std::_Simple_types<PrimitiveGroup> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PrimitiveGroup> >::_Vector_val<std::_Simple_types<PrimitiveGroup> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@UPrimitiveGroup@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PrimitiveGroup> >::_Vector_val<std::_Simple_types<PrimitiveGroup> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@UPrimitiveGroup@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@UPrimitiveGroup@@@@QAE@XZ PROC		; xalloc<PrimitiveGroup>::xalloc<PrimitiveGroup>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@UPrimitiveGroup@@@@QAE@XZ ENDP		; xalloc<PrimitiveGroup>::xalloc<PrimitiveGroup>
_TEXT	ENDS
END
