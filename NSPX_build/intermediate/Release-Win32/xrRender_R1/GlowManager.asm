; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\glowmanager.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@DJLICKGM@effects?2glow@		; `string'
PUBLIC	??_C@_0BD@PNJEJKKP@CGlowManager?3?3Load@	; `string'
PUBLIC	??_C@_0EA@OOHIDCLK@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_04IAGNFIBA@size@				; `string'
PUBLIC	??_C@_0O@FDMEONLL@size?$CFone?5?$DN?$DN?50@	; `string'
PUBLIC	??_R2CGlow@@8					; CGlow::`RTTI Base Class Array'
PUBLIC	??_R2IRender_Glow@@8				; IRender_Glow::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGlow@@8				; CGlow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRender_Glow@@8			; IRender_Glow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IRender_Glow@@8				; IRender_Glow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIRender_Glow@@@8			; IRender_Glow `RTTI Type Descriptor'
PUBLIC	??_R3CGlow@@8					; CGlow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4CGlow@@6BISpatial@@@			; CGlow::`RTTI Complete Object Locator'
PUBLIC	??_R4CGlow@@6BIRender_Glow@@@			; CGlow::`RTTI Complete Object Locator'
PUBLIC	??_7CGlow@@6BISpatial@@@			; CGlow::`vftable'
PUBLIC	??_7CGlow@@6BIRender_Glow@@@			; CGlow::`vftable'
EXTRN	__imp_??0IRender_Glow@@QAE@XZ:PROC
EXTRN	__imp_?_get@?$resptr_base@VIRender_Glow@@@@QBEPAVIRender_Glow@@XZ:PROC
EXTRN	__imp_?_set@?$resptr_base@VIRender_Glow@@@@QAEXABV1@@Z:PROC
EXTRN	?dcast_Light@ISpatial@@UAEPAVIRender_Light@@XZ:PROC ; ISpatial::dcast_Light
EXTRN	__imp_?dcast_Light@ISpatial@@UAEPAVIRender_Light@@XZ:PROC
EXTRN	?spatial_sector_point@ISpatial@@UAE?AU?$_vector3@M@@XZ:PROC ; ISpatial::spatial_sector_point
EXTRN	__imp_?spatial_sector_point@ISpatial@@UAE?AU?$_vector3@M@@XZ:PROC
EXTRN	__imp_?_set@?$resptr_base@VIRender_Glow@@@@QAEXPAVIRender_Glow@@@Z:PROC
EXTRN	__imp_??_7IRender_Glow@@6B@:BYTE
EXTRN	__imp_??1IRender_Glow@@UAE@XZ:PROC
;	COMDAT ?ignore_always@?7??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CGlowManager::Load'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CGlowManager::Load'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_7CGlow@@6BIRender_Glow@@@
CONST	SEGMENT
??_7CGlow@@6BIRender_Glow@@@ DD FLAT:??_R4CGlow@@6BIRender_Glow@@@ ; CGlow::`vftable'
	DD	FLAT:?set_active@CGlow@@UAEX_N@Z
	DD	FLAT:?get_active@CGlow@@UAE_NXZ
	DD	FLAT:?set_position@CGlow@@UAEXABU?$_vector3@M@@@Z
	DD	FLAT:?set_direction@CGlow@@UAEXABU?$_vector3@M@@@Z
	DD	FLAT:?set_radius@CGlow@@UAEXM@Z
	DD	FLAT:?set_texture@CGlow@@UAEXPBD@Z
	DD	FLAT:?set_color@CGlow@@UAEXMMM@Z
	DD	FLAT:?set_color@CGlow@@UAEXABU?$_color@M@@@Z
	DD	FLAT:??_ECGlow@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CGlow@@6BISpatial@@@
CONST	SEGMENT
??_7CGlow@@6BISpatial@@@ DD FLAT:??_R4CGlow@@6BISpatial@@@ ; CGlow::`vftable'
	DD	FLAT:?spatial_register@ISpatial@@UAEXXZ
	DD	FLAT:?spatial_unregister@ISpatial@@UAEXXZ
	DD	FLAT:?spatial_move@CGlow@@UAEXXZ
	DD	FLAT:?spatial_sector_point@ISpatial@@UAE?AU?$_vector3@M@@XZ
	DD	FLAT:?dcast_CObject@ISpatial@@UAEPAVCObject@@XZ
	DD	FLAT:?dcast_FeelSound@ISpatial@@UAEPAVSound@Feel@@XZ
	DD	FLAT:?dcast_Renderable@ISpatial@@UAEPAVIRenderable@@XZ
	DD	FLAT:?dcast_Light@ISpatial@@UAEPAVIRender_Light@@XZ
	DD	FLAT:??_ECGlow@@W7AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CGlow@@6BIRender_Glow@@@
rdata$r	SEGMENT
??_R4CGlow@@6BIRender_Glow@@@ DD 00H			; CGlow::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGlow@@@8
	DD	FLAT:??_R3CGlow@@8
rdata$r	ENDS
;	COMDAT ??_R4CGlow@@6BISpatial@@@
rdata$r	SEGMENT
??_R4CGlow@@6BISpatial@@@ DD 00H			; CGlow::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCGlow@@@8
	DD	FLAT:??_R3CGlow@@8
rdata$r	ENDS
;	COMDAT ??_R3CGlow@@8
rdata$r	SEGMENT
??_R3CGlow@@8 DD 00H					; CGlow::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2CGlow@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_Glow@@@8
data$rs	SEGMENT
??_R0?AVIRender_Glow@@@8 DD FLAT:??_7type_info@@6B@	; IRender_Glow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_Glow@@', 00H
data$rs	ENDS
;	COMDAT ??_R3IRender_Glow@@8
rdata$r	SEGMENT
??_R3IRender_Glow@@8 DD 00H				; IRender_Glow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IRender_Glow@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_Glow@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_Glow@@8 DD FLAT:??_R0?AVIRender_Glow@@@8 ; IRender_Glow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Glow@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGlow@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGlow@@8 DD FLAT:??_R0?AVCGlow@@@8	; CGlow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGlow@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_Glow@@8
rdata$r	SEGMENT
??_R2IRender_Glow@@8 DD FLAT:??_R1A@?0A@EA@IRender_Glow@@8 ; IRender_Glow::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@xr_resource@@8
rdata$r	ENDS
;	COMDAT ??_R2CGlow@@8
rdata$r	SEGMENT
??_R2CGlow@@8 DD FLAT:??_R1A@?0A@EA@CGlow@@8		; CGlow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_Glow@@8
	DD	FLAT:??_R13?0A@EA@xr_resource@@8
	DD	FLAT:??_R17?0A@EA@ISpatial@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@FDMEONLL@size?$CFone?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0O@FDMEONLL@size?$CFone?5?$DN?$DN?50@ DB 'size%one == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size@
CONST	SEGMENT
??_C@_04IAGNFIBA@size@ DB 'size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OOHIDCLK@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0EA@OOHIDCLK@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNJEJKKP@CGlowManager?3?3Load@
CONST	SEGMENT
??_C@_0BD@PNJEJKKP@CGlowManager?3?3Load@ DB 'CGlowManager::Load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJLICKGM@effects?2glow@
CONST	SEGMENT
??_C@_0N@DJLICKGM@effects?2glow@ DB 'effects\glow', 00H	; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??_ECGlow@@W7AEPAXI@Z				; [thunk]:CGlow::`vector deleting destructor'
PUBLIC	?swap@?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEXAAV1@@Z ; resptr_core<IRender_Glow,resptrcode_glow>::swap
PUBLIC	??$forward@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV1@@Z ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> * &>
PUBLIC	??$swap@VIRender_Glow@@Uresptrcode_glow@@@@YAXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; swap<IRender_Glow,resptrcode_glow>
PUBLIC	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Pop_heap_hole_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Push_heap_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Push_heap_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$?0AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV0@$0A@@?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@QAE@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; std::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *><resptr_core<IRender_Glow,resptrcode_glow> * &,resptr_core<IRender_Glow,resptrcode_glow> * &,0>
PUBLIC	??$iter_swap@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; std::iter_swap<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$_Next_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ; std::_Next_iter<resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$_Guess_median_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Guess_median_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Prev_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ; std::_Prev_iter<resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$_Pop_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ; std::_Pop_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Move_backward_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ; std::_Move_backward_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$_Emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV3@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> &>
PUBLIC	??$forward@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> &>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YA?AU?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@0@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV2@1@Z@Z ; std::_Partition_by_median_guess_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Sort_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ; std::_Sort_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Make_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ; std::_Make_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Insertion_sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0P6A_NV1@1@Z@Z ; std::_Insertion_sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Destroy_in_place@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::_Destroy_in_place<resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$_Uninitialized_move@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ; std::_Uninitialized_move<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??$_Emplace_back@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> &>
PUBLIC	??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$_Pass_fn@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z$0A@@std@@YAP6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@ZP6A_N00@Z@Z ; std::_Pass_fn<bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>),0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > >
PUBLIC	??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@ABV0@@Z ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>
PUBLIC	??0?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAE@XZ ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::xalloc<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	?construct@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@ABV2@@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::construct
PUBLIC	?destroy@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::destroy
PUBLIC	?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove
PUBLIC	?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEII@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??4?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEAAV0@ABV0@@Z ; resptr_core<IRender_Glow,resptrcode_glow>::operator=
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Unwrapped
PUBLIC	??R?$less@PAUShader@@@std@@QBE_NABQAUShader@@0@Z ; std::less<Shader *>::operator()
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Release
PUBLIC	??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::_Get_unwrapped<resptr_core<IRender_Glow,resptrcode_glow> * const &>
PUBLIC	??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ; std::_Uninitialized_copy<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??$xr_alloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ; xr_alloc<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$xr_free@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; xr_free<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ; std::_Destroy_range<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1><>
PUBLIC	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$forward@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$move@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ; std::move<resptr_core<IRender_Glow,resptrcode_glow> &>
PUBLIC	??$destroy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::destroy<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$_Unfancy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ; std::_Unfancy<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@1@Z@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
PUBLIC	??$?MUShader@@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ; operator<<Shader,resptrcode_shader>
PUBLIC	?max_size@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEIXZ ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00U?$integral_constant@_N$0A@@2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Verify_offset
PUBLIC	?allocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@IPBX@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::allocate
PUBLIC	?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size
PUBLIC	?clear@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Destroy
PUBLIC	?_Change_array@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@II@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Change_array
PUBLIC	?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEABV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=
PUBLIC	??0?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Reallocate_exactly
PUBLIC	?erase@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@0@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::erase
PUBLIC	?size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size
PUBLIC	?max_size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size
PUBLIC	?capacity@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::capacity
PUBLIC	?_Tidy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_and_free
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
PUBLIC	?normalize_safe@?$_vector3@M@@QAEAAU1@ABU1@@Z	; _vector3<float>::normalize_safe
PUBLIC	?distance@?$_plane@M@@QAEMABU?$_vector3@M@@@Z	; _plane<float>::distance
PUBLIC	??1?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	??$emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >
PUBLIC	?push_back@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::push_back
PUBLIC	?reserve@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXI@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::reserve
PUBLIC	?begin@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::begin
PUBLIC	?end@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::end
PUBLIC	?empty@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBE_NXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::empty
PUBLIC	??0?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	?size@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QBEIXZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size
PUBLIC	?clear_not_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_not_free
PUBLIC	?clear@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear
PUBLIC	??A?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::operator[]
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+
PUBLIC	?render_selected@CGlowManager@@QAEXXZ		; CGlowManager::render_selected
PUBLIC	?render_sw@CGlowManager@@QAEXXZ			; CGlowManager::render_sw
PUBLIC	?FillSprite@@YAXAAPAULIT@FVF@@ABU?$_vector3@M@@MI@Z ; FillSprite
PUBLIC	?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; glow_compare
PUBLIC	??1?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
PUBLIC	?spatial_move@CGlow@@UAEXXZ			; CGlow::spatial_move
PUBLIC	?set_color@CGlow@@UAEXMMM@Z			; CGlow::set_color
PUBLIC	?set_color@CGlow@@UAEXABU?$_color@M@@@Z		; CGlow::set_color
PUBLIC	?set_texture@CGlow@@UAEXPBD@Z			; CGlow::set_texture
PUBLIC	?set_radius@CGlow@@UAEXM@Z			; CGlow::set_radius
PUBLIC	?set_direction@CGlow@@UAEXABU?$_vector3@M@@@Z	; CGlow::set_direction
PUBLIC	?set_position@CGlow@@UAEXABU?$_vector3@M@@@Z	; CGlow::set_position
PUBLIC	?get_active@CGlow@@UAE_NXZ			; CGlow::get_active
PUBLIC	?set_active@CGlow@@UAEX_N@Z			; CGlow::set_active
PUBLIC	??1CGlow@@UAE@XZ				; CGlow::~CGlow
PUBLIC	??_GCGlow@@UAEPAXI@Z				; CGlow::`scalar deleting destructor'
PUBLIC	?Unload@CGlowManager@@QAEXXZ			; CGlowManager::Unload
PUBLIC	?Load@CGlowManager@@QAEXPAVIReader@@@Z		; CGlowManager::Load
PUBLIC	??0CGlowManager@@QAE@XZ				; CGlowManager::CGlowManager
PUBLIC	??1CGlowManager@@QAE@XZ				; CGlowManager::~CGlowManager
PUBLIC	?add@CGlowManager@@QAEXV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ; CGlowManager::add
PUBLIC	?Render@CGlowManager@@QAEXXZ			; CGlowManager::Render
PUBLIC	??0CGlow@@QAE@XZ				; CGlow::CGlow
EXTRN	??_ECGlow@@UAEPAXI@Z:PROC			; CGlow::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z$2
__catchsym$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
??0CGlow@@QAE@XZ PROC					; CGlow::CGlow
; _this$ = ecx

; 21   : {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 11   : 	xr_resource()			: dwReference(0)				{ }

	mov	DWORD PTR [edi+4], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 20   : CGlow::CGlow		()		: ISpatial(g_SpatialSpace)

	lea	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR __imp_??_7IRender_Glow@@6B@
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	DWORD PTR [eax]
	call	DWORD PTR __imp_??0ISpatial@@QAE@PAVISpatial_DB@@@Z

; 21   : {

	mov	DWORD PTR [edi], OFFSET ??_7CGlow@@6BIRender_Glow@@@
	lea	ecx, DWORD PTR [edi+124]
	mov	DWORD PTR [edi+8], OFFSET ??_7CGlow@@6BISpatial@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [edi+68], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 21   : {

	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache

; 22   : 	flags.bActive	= false;

	and	DWORD PTR [edi+60], -2			; fffffffeH

; 31   : }

	mov	eax, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+76], 0
	mov	DWORD PTR [edi+80], 0
	mov	DWORD PTR [edi+84], 0
	mov	DWORD PTR [edi+88], 0
	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 25   : 	radius			= 0.1f;

	mov	DWORD PTR [edi+100], 1036831949		; 3dcccccdH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	mov	DWORD PTR [edi+104], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+108], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+112], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 27   : 	bTestResult		= FALSE;

	mov	DWORD PTR [edi+120], 0

; 28   : 	fade			= 1.f;

	mov	DWORD PTR [edi+64], 1065353216		; 3f800000H

; 29   : 	dwFrame			= 0;

	mov	DWORD PTR [edi+72], 0

; 30   : 	spatial.type	= STYPE_RENDERABLE;

	mov	DWORD PTR [edi+12], 1

; 31   : }

	pop	edi
	pop	esi
	ret	0
??0CGlow@@QAE@XZ ENDP					; CGlow::CGlow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_o_main$1$ = -32					; size = 4
_range$1 = -28						; size = 4
_dir$2 = -24						; size = 12
_start$3 = -12						; size = 12
?Render@CGlowManager@@QAEXXZ PROC			; CGlowManager::Render
; _this$ = ecx

; 197  : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 198  : 	if (Selected.empty())					return		;

	je	$LN59@Render

; 199  : 	RCache.set_xform_world					(Fidentity)	;

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 201  : 	Device.Statistic->RenderDUMP_Glows.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 201  : 	Device.Statistic->RenderDUMP_Glows.Begin	();

	add	esi, 1992				; 000007c8H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN67@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN67@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], eax
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN67@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	ebp, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	xor	ebx, ebx
	mov	ecx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _o_main$1$[esp+52], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 212  : 	Fvector start	= Device.vCameraPosition;

	mov	eax, DWORD PTR [ecx+488]
	mov	DWORD PTR _start$3[esp+52], eax
	mov	eax, DWORD PTR [ecx+492]
	mov	DWORD PTR _start$3[esp+56], eax
	mov	eax, DWORD PTR [ecx+496]
	mov	DWORD PTR _start$3[esp+60], eax

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	cmp	DWORD PTR ?ps_r1_GlowsPerFrame@@3HA, ebx ; ps_r1_GlowsPerFrame
	jle	$LN68@Render
	mov	eax, DWORD PTR [edi+68]
	npad	3
$LL18@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
	sub	ecx, esi
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	div	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [esi+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 217  : 		if (G.dwFrame=='test')	break;

	cmp	DWORD PTR [esi+72], 1952805748		; 74657374H
	je	$LN68@Render

; 218  : 		G.dwFrame	=	'test';

	mov	DWORD PTR [esi+72], 1952805748		; 74657374H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [esi+16]
	subss	xmm2, DWORD PTR _start$3[esp+52]
	movss	DWORD PTR _dir$2[esp+52], xmm2

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [esi+20]
	subss	xmm3, DWORD PTR _start$3[esp+56]

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+56], xmm3
	movaps	xmm1, xmm3
	movss	xmm4, DWORD PTR [esi+24]
	subss	xmm4, DWORD PTR _start$3[esp+60]
	mulss	xmm1, xmm3

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+60], xmm4

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 221  : 		if (range>EPS_S)	{

	comiss	xmm0, DWORD PTR __real@33d6bf95
	movss	DWORD PTR _range$1[esp+52], xmm0
	jbe	SHORT $LN16@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR [esi+124]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	divss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	push	DWORD PTR _o_main$1$[esp+52]
	fld	DWORD PTR _range$1[esp+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	push	eax
	push	3
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+68], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR _dir$2[esp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm0, xmm1
	mulss	xmm1, xmm4
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	fstp	DWORD PTR [esp]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+76], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR _start$3[esp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+80], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	mov	ebp, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	DWORD PTR [esi+120], eax
$LN16@Render:

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	inc	DWORD PTR [edi+68]
	inc	ebx
	mov	eax, DWORD PTR [edi+68]
	cmp	ebx, DWORD PTR ?ps_r1_GlowsPerFrame@@3HA ; ps_r1_GlowsPerFrame
	jl	$LL18@Render
$LN68@Render:

; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	// 2. Render selected
; 228  : 	render_selected			();

	mov	ecx, edi
	call	?render_selected@CGlowManager@@QAEXXZ	; CGlowManager::render_selected

; 202  : 	render_sw								();
; 203  : 	Device.Statistic->RenderDUMP_Glows.End	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@Render
	lea	ecx, DWORD PTR [esi+1992]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2048], eax
	adc	DWORD PTR [esi+2052], edx
$LN59@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 204  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?Render@CGlowManager@@QAEXXZ ENDP			; CGlowManager::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_G_$ = 8						; size = 4
?add@CGlowManager@@QAEXV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; CGlowManager::add
; _this$ = ecx

; 144  : {

	push	ecx

; 146  : 	if (G->dwFrame	==Device.dwFrame)		return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edx, DWORD PTR _G_$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 146  : 	if (G->dwFrame	==Device.dwFrame)		return;

	mov	eax, DWORD PTR [eax+244]
	cmp	DWORD PTR [edx+72], eax
	je	$LN8@add

; 147  : 	G->dwFrame		= Device.dwFrame;

	mov	DWORD PTR [edx+72], eax

; 152  : 	float	dt		= Device.fTimeDelta;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A

; 156  : 	if (range < dlim2) 

	movss	xmm5, DWORD PTR [edx+64]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [eax+492]
	movss	xmm3, DWORD PTR [eax+488]
	movss	xmm1, DWORD PTR [eax+496]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 152  : 	float	dt		= Device.fTimeDelta;

	movss	xmm4, DWORD PTR [eax+468]

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, DWORD PTR [edx+16]
	subss	xmm2, DWORD PTR [edx+20]
	subss	xmm1, DWORD PTR [edx+24]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm3, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax+1116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax+440]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 153  : 	float	dlim2	= MAX_GlowsDist2;

	movss	xmm0, DWORD PTR [eax+64]
	mulss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm3, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 156  : 	if (range < dlim2) 

	comiss	xmm0, xmm3
	jbe	$LN3@add

; 157  : 	{
; 158  : 		// 2. Use result of test
; 159  : 		if (G->bTestResult) {

	cmp	DWORD PTR [edx+120], 0
	je	SHORT $LN4@add

; 160  : 			G->fade -= dt*FADE_SCALE_DOWN;

	mulss	xmm4, DWORD PTR __real@44800000

; 161  : 			if (G->fade<1.)		G->fade = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm5, xmm4
	comiss	xmm0, xmm5
	movss	DWORD PTR [edx+64], xmm5
	jbe	SHORT $LN7@add
	mov	DWORD PTR [edx+64], 1065353216		; 3f800000H

; 162  : 		} else {

	jmp	SHORT $LN7@add
$LN4@add:

; 163  : 			G->fade	+= dt*FADE_SCALE_UP;

	mulss	xmm4, DWORD PTR __real@45800000
	addss	xmm4, xmm5

; 164  : 			if (G->fade>255.f)	G->fade = 255.f;

	comiss	xmm4, DWORD PTR __real@437f0000
	movss	DWORD PTR [edx+64], xmm4
	jbe	SHORT $LN7@add
	mov	DWORD PTR [edx+64], 1132396544		; 437f0000H
$LN7@add:

; 165  : 		}
; 166  : 
; 167  : 		Selected.push_back(G);

	add	ecx, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+4], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	inc	DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN31@add
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR $T1[esp+4]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR $T1[esp+4]
	test	eax, eax
	je	SHORT $LN41@add
	inc	DWORD PTR [eax+4]
$LN41@add:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+4]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	lea	ecx, DWORD PTR _G_$[esp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 175  : }

	pop	ecx
	ret	4
$LN31@add:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[esp+4]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+4]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	lea	ecx, DWORD PTR _G_$[esp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 175  : }

	pop	ecx
	ret	4
$LN3@add:

; 168  : 		return;
; 169  : 	}
; 170  : 	G->fade -= dt*FADE_SCALE_DOWN;

	mulss	xmm4, DWORD PTR __real@44800000

; 171  : 	if (G->fade<1.) G->fade = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm5, xmm4
	comiss	xmm0, xmm5
	movss	DWORD PTR [edx+64], xmm5
	jbe	SHORT $LN8@add
	mov	DWORD PTR [edx+64], 1065353216		; 3f800000H
$LN8@add:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _G_$[esp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 175  : }

	pop	ecx
	ret	4
?add@CGlowManager@@QAEXV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; CGlowManager::add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
??1CGlowManager@@QAE@XZ PROC				; CGlowManager::~CGlowManager
; _this$ = ecx

; 91   : {

	push	esi
	mov	esi, ecx
	push	edi

; 92   : }

	lea	ecx, DWORD PTR [esi+60]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN10@CGlowManag
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+48], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+52], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+56], 0
$LN10@CGlowManag:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN22@CGlowManag
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+36], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+40], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+44], 0
$LN22@CGlowManag:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN34@CGlowManag
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN34@CGlowManag:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN46@CGlowManag
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN46@CGlowManag:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN58@CGlowManag
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN58@CGlowManag:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 92   : }

	pop	esi
	ret	0
??1CGlowManager@@QAE@XZ ENDP				; CGlowManager::~CGlowManager
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
??0CGlowManager@@QAE@XZ PROC				; CGlowManager::CGlowManager
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 88   : }

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ecx+60], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 88   : }

	ret	0
??0CGlowManager@@QAE@XZ ENDP				; CGlowManager::CGlowManager
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_count$1$ = -4						; size = 4
_fs$ = 8						; size = 4
?Load@CGlowManager@@QAEXPAVIReader@@@Z PROC		; CGlowManager::Load
; _this$ = ecx

; 95   : {

	sub	esp, 12					; 0000000cH

; 96   : 	// glows itself
; 97   : 	u32 size	= fs->length();
; 98   : 	R_ASSERT	(size);

	cmp	BYTE PTR ?ignore_always@?3??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA, 0
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _fs$[esp+20]
	mov	ebp, ecx
	push	edi
	mov	edi, DWORD PTR __imp_?fail@xrDebug@@QAEXPBD0H0AA_N@Z
	mov	esi, DWORD PTR [esi+12]
	jne	SHORT $LN2@Load
	test	esi, esi
	jne	SHORT $LN2@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?3??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BD@PNJEJKKP@CGlowManager?3?3Load@
	push	98					; 00000062H
	push	OFFSET ??_C@_0EA@OOHIDCLK@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_04IAGNFIBA@size@
	call	edi
$LN2@Load:

; 99   : 	u32 one		= 4*sizeof(float)+1*sizeof(u16);
; 100  : 	R_ASSERT	(size%one == 0);

	cmp	BYTE PTR ?ignore_always@?7??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN5@Load
	xor	edx, edx
	mov	eax, esi
	mov	ecx, 18					; 00000012H
	div	ecx
	test	edx, edx
	je	SHORT $LN5@Load
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?7??Load@CGlowManager@@QAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BD@PNJEJKKP@CGlowManager?3?3Load@
	push	100					; 00000064H
	push	OFFSET ??_C@_0EA@OOHIDCLK@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0O@FDMEONLL@size?$CFone?5?$DN?$DN?50@
	call	edi
$LN5@Load:

; 101  : 	u32 count	= size/one;

	mov	eax, 954437177				; 38e38e39H
	mul	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+8]
	sub	eax, DWORD PTR [ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 101  : 	u32 count	= size/one;

	mov	ebx, edx
	shr	ebx, 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 101  : 	u32 count	= size/one;

	mov	DWORD PTR _count$1$[esp+28], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	ebx, eax
	jbe	SHORT $LN17@Load

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	ebx, 1073741823				; 3fffffffH
	ja	$LN124@Load

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ebx
	mov	ecx, ebp
	call	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Reallocate_exactly
$LN17@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 104  : 	for (;count;count--)

	test	ebx, ebx
	je	$LN9@Load
$LL10@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	200					; 000000c8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 11   : 	xr_resource()			: dwReference(0)				{ }

	mov	DWORD PTR [ebx+4], 0
	mov	ecx, DWORD PTR __imp_??_7IRender_Glow@@6B@
	mov	DWORD PTR [ebx], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 20   : CGlow::CGlow		()		: ISpatial(g_SpatialSpace)

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ebx+8]
	call	DWORD PTR __imp_??0ISpatial@@QAE@PAVISpatial_DB@@@Z

; 21   : {

	mov	DWORD PTR [ebx], OFFSET ??_7CGlow@@6BIRender_Glow@@@
	lea	ecx, DWORD PTR [ebx+124]
	mov	DWORD PTR [ebx+8], OFFSET ??_7CGlow@@6BISpatial@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebx+68], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 21   : {

	call	??0ray_cache@collide@@QAE@XZ		; collide::ray_cache::ray_cache

; 107  : 		fs->r				(&G->position,	3*sizeof(float));

	mov	ecx, DWORD PTR _fs$[esp+24]

; 23   : 	position.set	(0,0,0);

	lea	edi, DWORD PTR [ebx+76]
	and	DWORD PTR [ebx+60], -2			; fffffffeH

; 25   : 	radius			= 0.1f;

	lea	esi, DWORD PTR [ebx+100]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [ebx+88], 0
	mov	DWORD PTR [ebx+92], 0
	mov	DWORD PTR [ebx+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 25   : 	radius			= 0.1f;

	mov	DWORD PTR [esi], 1036831949		; 3dcccccdH
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	mov	DWORD PTR [ebx+104], 1065353216		; 3f800000H
	mov	DWORD PTR [ebx+108], 1065353216		; 3f800000H
	mov	DWORD PTR [ebx+112], 1065353216		; 3f800000H
	mov	DWORD PTR [ebx+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 107  : 		fs->r				(&G->position,	3*sizeof(float));

	push	12					; 0000000cH
	push	edi

; 27   : 	bTestResult		= FALSE;

	mov	DWORD PTR [ebx+120], 0

; 28   : 	fade			= 1.f;

	mov	DWORD PTR [ebx+64], 1065353216		; 3f800000H

; 29   : 	dwFrame			= 0;

	mov	DWORD PTR [ebx+72], 0

; 30   : 	spatial.type	= STYPE_RENDERABLE;

	mov	DWORD PTR [ebx+12], 1

; 107  : 		fs->r				(&G->position,	3*sizeof(float));

	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z

; 108  : 		fs->r				(&G->radius,	1*sizeof(float));

	mov	ecx, DWORD PTR _fs$[esp+24]
	push	4
	push	esi
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 112  : 		u16 S				= fs->r_u16();

	mov	ecx, DWORD PTR _fs$[esp+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ebx+16]
	fld	DWORD PTR [edi+4]
	fstp	DWORD PTR [ebx+20]
	fld	DWORD PTR [edi+8]
	fstp	DWORD PTR [ebx+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h

; 9    : 	IC void		set(const _vector3<T> &_P, T _R)	{ P.set(_P); R = _R; }

	fld	DWORD PTR [esi]
	fstp	DWORD PTR [ebx+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ebx+88], 0
	mov	DWORD PTR [ebx+92], 0
	mov	DWORD PTR [ebx+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 112  : 		u16 S				= fs->r_u16();

	call	DWORD PTR __imp_?r_u16@?$IReaderBase@VIReader@@@@QAEGXZ
	movzx	ecx, ax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR ?RImplementation@@3VCRender@@A+896
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T2[esp+28], esi
	test	esi, esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN79@Load
	inc	DWORD PTR [esi]
	mov	esi, DWORD PTR $T2[esp+28]

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN79@Load
	inc	DWORD PTR [esi]
$LN79@Load:
	lea	ecx, DWORD PTR [ebx+68]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T2[esp+28]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx+68], esi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 121  : 		G->set_active		(true);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	mov	DWORD PTR [ebx+64], 1132396544		; 437f0000H
	mov	DWORD PTR [ebx+72], 0
	mov	DWORD PTR [ebx+120], 1
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+12], 1
	push	1
	cmp	eax, OFFSET ?set_active@CGlow@@UAEX_N@Z	; CGlow::set_active
	jne	SHORT $LN84@Load
	call	?set_active@CGlow@@UAEX_N@Z		; CGlow::set_active
	jmp	SHORT $LN83@Load
$LN84@Load:
	call	eax
$LN83@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T1[esp+28], ebx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	inc	DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, DWORD PTR [ebp+8]
	je	SHORT $LN100@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR $T1[esp+28]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR $T1[esp+28]
	test	eax, eax
	je	SHORT $LN110@Load
	inc	DWORD PTR [eax+4]
$LN110@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebp+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN99@Load
$LN100@Load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[esp+28]
	push	eax
	push	ecx
	mov	ecx, ebp
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >
$LN99@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+28]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 104  : 	for (;count;count--)

	sub	DWORD PTR _count$1$[esp+28], 1
	jne	$LL10@Load
$LN9@Load:

; 122  : 
; 123  : 		Glows.push_back		(G);
; 124  : 	}
; 125  : 	dwTestID		= 0;

	mov	DWORD PTR [ebp+68], 0

; 126  : 
; 127  : 	hGeom.create	(FVF::F_LIT,RCache.Vertex.Buffer(),RCache.QuadIB);

	lea	ecx, DWORD PTR [ebp+60]
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	DWORD PTR [eax+40]
	push	DWORD PTR [eax]
	push	322					; 00000142H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z
	pop	edi

; 128  : }

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
$LN124@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength
$LN121@Load:
	int	3
?Load@CGlowManager@@QAEXPAVIReader@@@Z ENDP		; CGlowManager::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
?Unload@CGlowManager@@QAEXXZ PROC			; CGlowManager::Unload
; _this$ = ecx

; 132  : 	// glows
; 133  : 	SelectedToTest_2.clear	();

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+28], eax

; 134  : 	SelectedToTest_1.clear	();

	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [ecx+40], eax

; 135  : 	SelectedToTest_0.clear	();

	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [ecx+52], eax

; 136  : 	Selected.clear			();

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+16], eax

; 137  : 	Glows.clear				();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 138  : }

	ret	0
?Unload@CGlowManager@@QAEXXZ ENDP			; CGlowManager::Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
;	COMDAT ??_GCGlow@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGlow@@UAEPAXI@Z PROC				; CGlow::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 33   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 48   : 		if (!flags.bActive)					return;

	mov	eax, DWORD PTR [edi+60]

; 33   : {

	mov	DWORD PTR [edi], OFFSET ??_7CGlow@@6BIRender_Glow@@@
	mov	DWORD PTR [edi+8], OFFSET ??_7CGlow@@6BISpatial@@@

; 48   : 		if (!flags.bActive)					return;

	test	al, 1
	je	SHORT $LN8@scalar

; 49   : 		flags.bActive						= false;

	and	eax, -2					; fffffffeH

; 50   : 		spatial_unregister					();

	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+60], eax
	call	DWORD PTR ??_7CGlow@@6BISpatial@@@+4
$LN8@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [edi+68]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+68], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 36   : }

	lea	ecx, DWORD PTR [edi+8]
	call	DWORD PTR __imp_??1ISpatial@@UAE@XZ
	mov	ecx, edi
	call	DWORD PTR __imp_??1IRender_Glow@@UAE@XZ
	test	BYTE PTR ___flags$[esp+8], 1
	je	SHORT $LN19@scalar
	push	200					; 000000c8H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN19@scalar:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??_GCGlow@@UAEPAXI@Z ENDP				; CGlow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
??1CGlow@@UAE@XZ PROC					; CGlow::~CGlow
; _this$ = ecx

; 33   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 48   : 		if (!flags.bActive)					return;

	mov	eax, DWORD PTR [edi+60]

; 33   : {

	mov	DWORD PTR [edi], OFFSET ??_7CGlow@@6BIRender_Glow@@@
	mov	DWORD PTR [edi+8], OFFSET ??_7CGlow@@6BISpatial@@@

; 48   : 		if (!flags.bActive)					return;

	test	al, 1
	je	SHORT $LN5@CGlow

; 49   : 		flags.bActive						= false;

	and	eax, -2					; fffffffeH

; 50   : 		spatial_unregister					();

	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+60], eax
	call	DWORD PTR ??_7CGlow@@6BISpatial@@@+4
$LN5@CGlow:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [edi+68]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+68], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 36   : }

	lea	ecx, DWORD PTR [edi+8]
	call	DWORD PTR __imp_??1ISpatial@@UAE@XZ
	mov	ecx, edi
	pop	edi
	pop	esi
	pop	ebx
	jmp	DWORD PTR __imp_??1IRender_Glow@@UAE@XZ
??1CGlow@@UAE@XZ ENDP					; CGlow::~CGlow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 1
?set_active@CGlow@@UAEX_N@Z PROC			; CGlow::set_active
; _this$ = ecx

; 40   : 	if (a)

	cmp	BYTE PTR _a$[esp-4], 0
	mov	eax, DWORD PTR [ecx+60]
	je	SHORT $LN2@set_active

; 41   : 	{
; 42   : 		if (flags.bActive)					return;

	test	al, 1
	jne	SHORT $LN3@set_active

; 43   : 		flags.bActive						= true;

	or	eax, 1
	mov	DWORD PTR [ecx+60], eax

; 44   : 		spatial_register					();

	add	ecx, 8
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]

; 51   : 	}
; 52   : }

	ret	4
$LN2@set_active:

; 45   : 	}
; 46   : 	else
; 47   : 	{
; 48   : 		if (!flags.bActive)					return;

	test	al, 1
	je	SHORT $LN3@set_active

; 49   : 		flags.bActive						= false;

	and	eax, -2					; fffffffeH
	mov	DWORD PTR [ecx+60], eax

; 50   : 		spatial_unregister					();

	add	ecx, 8
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN3@set_active:

; 51   : 	}
; 52   : }

	ret	4
?set_active@CGlow@@UAEX_N@Z ENDP			; CGlow::set_active
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
?get_active@CGlow@@UAE_NXZ PROC				; CGlow::get_active
; _this$ = ecx

; 54   : bool	CGlow::get_active		()					{return flags.bActive;}

	mov	al, BYTE PTR [ecx+60]
	and	al, 1
	ret	0
?get_active@CGlow@@UAE_NXZ ENDP				; CGlow::get_active
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_P$ = 8							; size = 4
?set_position@CGlow@@UAEXABU?$_vector3@M@@@Z PROC	; CGlow::set_position
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	mov	eax, DWORD PTR _P$[esp-4]
	movss	xmm0, DWORD PTR [ecx+76]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm2, DWORD PTR __real@3a83126f
	movss	xmm3, DWORD PTR [eax]
	subss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	SHORT $LN6@set_positi
	movss	xmm0, DWORD PTR [ecx+80]
	subss	xmm0, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	SHORT $LN6@set_positi
	movss	xmm0, DWORD PTR [ecx+84]
	subss	xmm0, DWORD PTR [eax+8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	ja	SHORT $LN1@set_positi
$LN6@set_positi:

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [ecx+76], xmm3
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+80]
	fld	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 58   : 	spatial_move				();

	mov	eax, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ecx+84]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 58   : 	spatial_move				();

	add	ecx, 8
	call	DWORD PTR [eax+8]
$LN1@set_positi:

; 59   : };

	ret	4
?set_position@CGlow@@UAEXABU?$_vector3@M@@@Z ENDP	; CGlow::set_position
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_D$ = 8							; size = 4
?set_direction@CGlow@@UAEXABU?$_vector3@M@@@Z PROC	; CGlow::set_direction
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 223  : 		T magnitude=v.x*v.x + v.y*v.y + v.z*v.z;

	mov	eax, DWORD PTR _D$[esp-4]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	movaps	xmm3, xmm2
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm3, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm3, xmm1
	addss	xmm3, xmm0

; 224  : 		if (magnitude>std::numeric_limits<T>::min()) {

	comiss	xmm3, DWORD PTR __real@00800000
	jbe	SHORT $LN4@set_direct

; 225  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 226  : 			x = v.x*magnitude;

	mulss	xmm2, xmm1

; 227  : 			y = v.y*magnitude;

	movaps	xmm0, xmm1
	movss	DWORD PTR [ecx+88], xmm2
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+92], xmm0

; 228  : 			z = v.z*magnitude;

	mulss	xmm1, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+96], xmm1
$LN4@set_direct:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 62   : };

	ret	4
?set_direction@CGlow@@UAEXABU?$_vector3@M@@@Z ENDP	; CGlow::set_direction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_R$ = 8							; size = 4
?set_radius@CGlow@@UAEXM@Z PROC				; CGlow::set_radius
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 73   : IC BOOL  fsimilar		( float		a, float	b, float	cmp=EPS )		{ return _abs(a-b)<cmp;	}

	movss	xmm1, DWORD PTR [ecx+100]
	movss	xmm2, DWORD PTR _R$[esp-4]
	movss	xmm0, DWORD PTR __real@3727c5ac
	subss	xmm1, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 73   : IC BOOL  fsimilar		( float		a, float	b, float	cmp=EPS )		{ return _abs(a-b)<cmp;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN1@set_radius
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 65   : 	radius						= R;

	mov	eax, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+100], xmm2

; 66   : 	spatial_move				();

	add	ecx, 8
	call	DWORD PTR [eax+8]
$LN1@set_radius:

; 67   : };

	ret	4
?set_radius@CGlow@@UAEXM@Z ENDP				; CGlow::set_radius
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
?set_texture@CGlow@@UAEXPBD@Z PROC			; CGlow::set_texture
; _this$ = ecx

; 69   : 	shader.create				("effects\\glow",name);

	push	0
	push	0
	push	DWORD PTR _name$[esp+4]
	add	ecx, 68					; 00000044H
	push	OFFSET ??_C@_0N@DJLICKGM@effects?2glow@
	call	DWORD PTR __imp_?create@resptrcode_shader@@QAEXPBD000@Z

; 70   : }

	ret	4
?set_texture@CGlow@@UAEXPBD@Z ENDP			; CGlow::set_texture
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_C$ = 8							; size = 4
?set_color@CGlow@@UAEXABU?$_color@M@@@Z PROC		; CGlow::set_color
; _this$ = ecx

; 72   : 	color						= C;

	mov	edx, DWORD PTR _C$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+104], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+108], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+112], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+116], eax

; 73   : }

	ret	4
?set_color@CGlow@@UAEXABU?$_color@M@@@Z ENDP		; CGlow::set_color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
?set_color@CGlow@@UAEXMMM@Z PROC			; CGlow::set_color
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	movss	xmm0, DWORD PTR _r$[esp-4]
	movss	DWORD PTR [ecx+104], xmm0
	movss	xmm0, DWORD PTR _g$[esp-4]
	movss	DWORD PTR [ecx+108], xmm0
	movss	xmm0, DWORD PTR _b$[esp-4]
	movss	DWORD PTR [ecx+112], xmm0
	mov	DWORD PTR [ecx+116], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 76   : }

	ret	12					; 0000000cH
?set_color@CGlow@@UAEXMMM@Z ENDP			; CGlow::set_color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
?spatial_move@CGlow@@UAEXXZ PROC			; CGlow::spatial_move
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [ecx+68]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 79   : 	spatial.sphere.set			(position,radius);

	movss	xmm0, DWORD PTR [ecx+92]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+72]
	fstp	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+76]
	fstp	DWORD PTR [ecx+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_sphere.h

; 9    : 	IC void		set(const _vector3<T> &_P, T _R)	{ P.set(_P); R = _R; }

	movss	DWORD PTR [ecx+20], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 80   : 	ISpatial::spatial_move		();

	jmp	DWORD PTR __imp_?spatial_move@ISpatial@@UAEXXZ
?spatial_move@CGlow@@UAEXXZ ENDP			; CGlow::spatial_move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
;	COMDAT ?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
_g1$ = 8						; size = 4
_g2$ = 12						; size = 4
?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; glow_compare, COMDAT
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 96   : template<class T, typename D>			inline bool operator	<	(resptr_core<T,D> const & a, resptr_core<T,D> const & b)		{ return std::less<T *>()(a._get(), b._get());		}

	mov	eax, DWORD PTR _g2$[esp-4]

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _g1$[esp-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 141  : {	return ((CGlow*)g1._get())->shader < ((CGlow*)g2._get())->shader; }

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 96   : template<class T, typename D>			inline bool operator	<	(resptr_core<T,D> const & a, resptr_core<T,D> const & b)		{ return std::less<T *>()(a._get(), b._get());		}

	mov	edi, DWORD PTR [eax+68]
	mov	eax, DWORD PTR _g1$[esp+4]
	mov	esi, DWORD PTR [eax+68]

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	lea	ecx, DWORD PTR _g2$[esp+4]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	cmp	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 141  : {	return ((CGlow*)g1._get())->shader < ((CGlow*)g2._get())->shader; }

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	setb	al
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 141  : {	return ((CGlow*)g1._get())->shader < ((CGlow*)g2._get())->shader; }

	pop	esi
	ret	0
?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; glow_compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
;	COMDAT ?FillSprite@@YAXAAPAULIT@FVF@@ABU?$_vector3@M@@MI@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_clr$ = 12						; size = 4
?FillSprite@@YAXAAPAULIT@FVF@@ABU?$_vector3@M@@MI@Z PROC ; FillSprite, COMDAT
; _pv$ = ecx
; _pos$ = edx

; 179  : 	const Fvector& T 	= Device.vCameraTop;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	xmm4, DWORD PTR _r$[esp-4]
	movaps	xmm7, xmm4
	movaps	xmm0, xmm4
	movaps	xmm1, xmm4
	movaps	xmm2, xmm4
	mulss	xmm0, DWORD PTR [eax+524]
	movaps	xmm6, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 178  : {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm2, DWORD PTR [eax+532]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 178  : {

	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm7, DWORD PTR [eax+512]
	mulss	xmm4, DWORD PTR [eax+520]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm1, DWORD PTR [eax+528]
	movaps	xmm5, xmm7
	mulss	xmm6, DWORD PTR [eax+516]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	addss	xmm7, xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	eax, DWORD PTR _clr$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	subss	xmm5, xmm0
	movss	DWORD PTR _r$[esp], xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	xmm0, DWORD PTR _r$[esp]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm3, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm2, DWORD PTR [edx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, xmm1

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR _r$[esp], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm0, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [ecx+12], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	subss	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	subss	xmm2, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+20], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+4], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm2, xmm3
	addss	xmm0, DWORD PTR [edx]
	addss	xmm2, DWORD PTR [edx+4]
	addss	xmm1, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [ecx+36], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+40], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+24], xmm0
	movss	DWORD PTR [ecx+28], xmm2
	movss	DWORD PTR [ecx+32], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+44], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 192  : 	pv->set		(c.x+pos.x,c.y+pos.y,c.z+pos.z, clr, 1.f,1.f);	pv++;

	movss	xmm0, DWORD PTR [edx]
	movss	xmm2, DWORD PTR [edx+4]
	subss	xmm0, xmm5
	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [ecx+60], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 192  : 	pv->set		(c.x+pos.x,c.y+pos.y,c.z+pos.z, clr, 1.f,1.f);	pv++;

	subss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+64], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+68], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+48], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	movss	xmm0, DWORD PTR _r$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+52], xmm2
	movss	DWORD PTR [ecx+56], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	addss	xmm6, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [edx+8]
	addss	xmm7, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [ecx+84], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	lea	eax, DWORD PTR [ecx+96]
	mov	DWORD PTR [esi], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [ecx+76], xmm6
	movss	DWORD PTR [ecx+80], xmm0
	movss	DWORD PTR [ecx+72], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [ecx+88], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+92], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	pop	esi

; 194  : }

	ret	0
?FillSprite@@YAXAAPAULIT@FVF@@ABU?$_vector3@M@@MI@Z ENDP ; FillSprite
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_o_main$1$ = -32					; size = 4
_range$1 = -28						; size = 4
_dir$2 = -24						; size = 12
_start$ = -12						; size = 12
?render_sw@CGlowManager@@QAEXXZ PROC			; CGlowManager::render_sw
; _this$ = ecx

; 207  : {

	sub	esp, 36					; 00000024H

; 212  : 	Fvector start	= Device.vCameraPosition;

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	ebp, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	xor	ebx, ebx
	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\igame_level.h

; 100  : 	CObject* CurrentViewEntity(void) const { return pCurrentViewEntity; }

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _o_main$1$[esp+52], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 212  : 	Fvector start	= Device.vCameraPosition;

	mov	eax, DWORD PTR [edx+488]
	mov	DWORD PTR _start$[esp+52], eax
	mov	eax, DWORD PTR [edx+492]
	mov	DWORD PTR _start$[esp+56], eax
	mov	eax, DWORD PTR [edx+496]
	mov	DWORD PTR _start$[esp+60], eax

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	cmp	DWORD PTR ?ps_r1_GlowsPerFrame@@3HA, ebx ; ps_r1_GlowsPerFrame
	jle	$LN50@render_sw
	mov	eax, DWORD PTR [edi+68]
	npad	2
$LL4@render_sw:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	xor	edx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+16]
	sub	ecx, esi
	sar	ecx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 215  : 		u32	ID		= dwTestID%Selected.size();

	div	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [esi+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 217  : 		if (G.dwFrame=='test')	break;

	cmp	DWORD PTR [esi+72], 1952805748		; 74657374H
	je	$LN50@render_sw

; 218  : 		G.dwFrame	=	'test';

	mov	DWORD PTR [esi+72], 1952805748		; 74657374H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [esi+16]
	subss	xmm2, DWORD PTR _start$[esp+52]
	movss	DWORD PTR _dir$2[esp+52], xmm2

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [esi+20]
	subss	xmm3, DWORD PTR _start$[esp+56]

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+56], xmm3
	movaps	xmm1, xmm3
	movss	xmm4, DWORD PTR [esi+24]
	subss	xmm4, DWORD PTR _start$[esp+60]
	mulss	xmm1, xmm3

; 167  : 		return x*x + y*y + z*z;

	addss	xmm1, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _dir$2[esp+60], xmm4

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 221  : 		if (range>EPS_S)	{

	comiss	xmm0, DWORD PTR __real@33d6bf95
	movss	DWORD PTR _range$1[esp+52], xmm0
	jbe	SHORT $LN2@render_sw
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR [esi+124]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	divss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	push	DWORD PTR _o_main$1$[esp+52]
	fld	DWORD PTR _range$1[esp+56]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	push	eax
	push	3
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+68], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR _dir$2[esp+68]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm0, xmm1
	mulss	xmm1, xmm4
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	fstp	DWORD PTR [esp]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+76], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	lea	eax, DWORD PTR _start$[esp+72]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movss	DWORD PTR _dir$2[esp+80], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 223  : 			G.bTestResult = g_pGameLevel->ObjectSpace.RayTest(start,dir,range,collide::rqtBoth,&G.RayCache,o_main);

	mov	ecx, DWORD PTR [ebp]
	push	eax
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?RayTest@CObjectSpace@@QAEHABU?$_vector3@M@@0MW4rq_target@collide@@PAUray_cache@4@PAVCObject@@@Z
	mov	ebp, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	DWORD PTR [esi+120], eax
$LN2@render_sw:

; 213  : 	for (int i=0; i<ps_r1_GlowsPerFrame; i++,dwTestID++)

	inc	DWORD PTR [edi+68]
	inc	ebx
	mov	eax, DWORD PTR [edi+68]
	cmp	ebx, DWORD PTR ?ps_r1_GlowsPerFrame@@3HA ; ps_r1_GlowsPerFrame
	jl	$LL4@render_sw
$LN50@render_sw:

; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	// 2. Render selected
; 228  : 	render_selected			();

	mov	ecx, edi
	call	?render_selected@CGlowManager@@QAEXXZ	; CGlowManager::render_selected

; 229  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?render_sw@CGlowManager@@QAEXXZ ENDP			; CGlowManager::render_sw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp
_TEXT	SEGMENT
_T$ = -64						; size = 4
_z$1$ = -60						; size = 4
_a$1 = -60						; size = 4
_pos$1$ = -56						; size = 4
_this$1$ = -52						; size = 4
tv2168 = -48						; size = 4
tv2169 = -44						; size = 4
tv2170 = -40						; size = 4
_vCount$1$ = -36					; size = 4
_pv$1$ = -36						; size = 4
_baseV$1$ = -32						; size = 4
$T2 = -32						; size = 4
_prhs$1$ = -32						; size = 4
_end$1$ = -32						; size = 4
_NP$$sroa$175$1$ = -28					; size = 4
_NP$$sroa$180$1$ = -24					; size = 4
_NP$$sroa$177$1$ = -20					; size = 4
tv2216 = -16						; size = 4
_dlim2$1$ = -12						; size = 4
__vb$1$ = -8						; size = 4
_PC$1$ = -8						; size = 4
_pvs$1$ = -8						; size = 4
_vOffset$3 = -4						; size = 4
?render_selected@CGlowManager@@QAEXXZ PROC		; CGlowManager::render_selected
; _this$ = ecx

; 254  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	push	OFFSET ?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; glow_compare
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 254  : {

	mov	DWORD PTR _this$1$[esp+84], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);

	mov	edx, DWORD PTR [edi+16]

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	eax, edx
	mov	ecx, DWORD PTR [edi+12]
	sub	eax, ecx
	sar	eax, 2
	push	eax
	call	??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 264  : 	NP.build		(Device.vCameraPosition,Device.vCameraDirection);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	xor	ebx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR _T$[esp+88], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	add	esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	movss	xmm3, DWORD PTR [eax+504]
	movss	xmm2, DWORD PTR [eax+500]
	movaps	xmm0, xmm3
	movss	xmm4, DWORD PTR [eax+508]
	movaps	xmm1, xmm2
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 260  : 	u32				pos = 0, count;

	mov	DWORD PTR _pos$1$[esp+80], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 214  : 		T mag=_sqrt(1/(v.x*v.x + v.y*v.y + v.z*v.z));

	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 216  : 		y = v.y*mag;

	mulss	xmm3, xmm0
	mulss	xmm2, xmm0

; 217  : 		z = v.z*mag;

	mulss	xmm4, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [eax+492]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+488]

; 215  : 		x = v.x*mag;

	movss	DWORD PTR _NP$$sroa$180$1$[esp+80], xmm2

; 216  : 		y = v.y*mag;

	movss	DWORD PTR _NP$$sroa$175$1$[esp+80], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0

; 217  : 		z = v.z*mag;

	movss	DWORD PTR _NP$$sroa$177$1$[esp+80], xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+496]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 266  : 	float		dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 266  : 	float		dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+1116]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	DWORD PTR tv2216[esp+80], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 266  : 	float		dlim2	= MAX_GlowsDist2;

	mov	eax, DWORD PTR [eax+440]
	movss	xmm0, DWORD PTR [eax+64]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, esi
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 266  : 	float		dlim2	= MAX_GlowsDist2;

	mulss	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 266  : 	float		dlim2	= MAX_GlowsDist2;

	movss	DWORD PTR _dlim2$1$[esp+80], xmm0

; 267  : 	for (;pos<Selected.size();) 

	test	eax, eax
	je	$LN3@render_sel
$LL2@render_sel:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	esi, DWORD PTR [eax+68]
	mov	DWORD PTR _prhs$1$[esp+80], esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN81@render_sel
	inc	DWORD PTR [esi]
$LN81@render_sel:
	lea	ecx, DWORD PTR _T$[esp+80]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+12]
	mov	edi, DWORD PTR [edi+16]
	sub	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR _T$[esp+80], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	edi, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 270  : 		count	= 0;

	xor	esi, esi

; 271  : 		while	((pos+count<Selected.size()) && (((CGlow*)Selected[pos+count]._get())->shader==T)) count++;

	cmp	ebx, edi
	jae	SHORT $LN6@render_sel
	mov	edx, ebx
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR _prhs$1$[esp+80]
	npad	3
$LL5@render_sel:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+68], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 271  : 		while	((pos+count<Selected.size()) && (((CGlow*)Selected[pos+count]._get())->shader==T)) count++;

	jne	SHORT $LN264@render_sel
	inc	edx
	inc	esi
	add	ecx, 4
	cmp	edx, edi
	jb	SHORT $LL5@render_sel
$LN264@render_sel:
	mov	ebx, DWORD PTR _pos$1$[esp+80]
$LN6@render_sel:

; 272  : 
; 273  : 		u32		vOffset;
; 274  : 		u32		end		= pos+count;
; 275  : 		FVF::LIT* pvs	= pv = (FVF::LIT*) RCache.Vertex.Lock(count*4,hGeom->vb_stride,vOffset);

	mov	edi, DWORD PTR _this$1$[esp+80]
	lea	eax, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	DWORD PTR _end$1$[esp+80], eax
	lea	eax, DWORD PTR _vOffset$3[esp+80]
	push	eax
	mov	eax, DWORD PTR [edi+60]
	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR [esi*4]
	push	eax
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	ecx, eax
	mov	DWORD PTR _pv$1$[esp+80], eax
	mov	DWORD PTR _pvs$1$[esp+80], ecx

; 276  : 		for (; pos<end; pos++)

	cmp	ebx, DWORD PTR _end$1$[esp+80]
	jae	$LN8@render_sel
	movss	xmm5, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LL9@render_sel:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	ecx, DWORD PTR [edi+12]
	mov	edi, DWORD PTR [ecx+ebx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 280  : 			if (G.fade<=1.f)			continue;

	comiss	xmm5, DWORD PTR [edi+64]
	jae	$LN7@render_sel
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [edi+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 283  : 			float	scale	= 1.f, dist_sq;

	movaps	xmm2, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm7, DWORD PTR [edx+488]
	movss	xmm3, DWORD PTR [edx+492]
	subss	xmm7, DWORD PTR [edi+76]
	movss	xmm4, DWORD PTR [edx+496]
	subss	xmm3, xmm0

; 167  : 		return x*x + y*y + z*z;

	movss	xmm1, DWORD PTR [edi+92]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR tv2169[esp+80], xmm0
	movss	xmm0, DWORD PTR [edi+84]
	movss	DWORD PTR tv2170[esp+80], xmm0
	subss	xmm4, xmm0
	movaps	xmm0, xmm7

; 167  : 		return x*x + y*y + z*z;

	mulss	xmm1, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm0, xmm7

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm6, xmm3
	mulss	xmm6, xmm3
	addss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm6, xmm0
	movss	xmm0, DWORD PTR [edi+88]
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+96]
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 287  : 			if (G.direction.square_magnitude()>EPS)	{

	comiss	xmm1, DWORD PTR __real@3727c5ac
	jbe	SHORT $LN11@render_sel
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	movaps	xmm1, xmm5
	movaps	xmm2, xmm7
	divss	xmm1, xmm0
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [edi+88]
	mulss	xmm3, DWORD PTR [edi+92]

; 45   : 	ICF SelfRef	div(T s)								{ x/=s;		y/=s;    z/=s;				return *this;	};

	mulss	xmm4, xmm1

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm3
	mulss	xmm4, DWORD PTR [edi+96]
	addss	xmm2, xmm4
$LN11@render_sel:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 291  : 			if (G.fade*scale<=1.f)		continue;

	movss	xmm3, DWORD PTR [edi+64]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	comiss	xmm5, xmm0
	jae	$LN7@render_sel
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [edi+76]
	mulss	xmm0, DWORD PTR _NP$$sroa$180$1$[esp+80]
	movss	xmm1, DWORD PTR tv2169[esp+80]
	mulss	xmm1, DWORD PTR _NP$$sroa$175$1$[esp+80]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv2170[esp+80]
	mulss	xmm0, DWORD PTR _NP$$sroa$177$1$[esp+80]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	xorps	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	subss	xmm1, DWORD PTR tv2216[esp+80]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 294  : 			float dist_np	= NP.distance(G.position)-VIEWPORT_NEAR;

	subss	xmm1, DWORD PTR __real@3e4ccccd

; 295  : 			float snear		= dist_np/0.15f;	clamp	(snear,0.f,1.f);

	mulss	xmm1, DWORD PTR __real@40d55555
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, xmm1
	jbe	SHORT $LN156@render_sel
	movaps	xmm1, xmm0
	jmp	SHORT $LN158@render_sel
$LN156@render_sel:
	comiss	xmm1, xmm5
	jbe	SHORT $LN158@render_sel
	movaps	xmm1, xmm5
$LN158@render_sel:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 296  : 			scale			*=	snear;

	mulss	xmm1, xmm2

; 297  : 			if (G.fade*scale<=1.f)		continue;

	mulss	xmm1, xmm3
	comiss	xmm5, xmm1
	jae	$LN7@render_sel

; 299  : 			u32 C			= iFloor(G.fade*scale*(1-(dist_sq/dlim2)));

	divss	xmm6, DWORD PTR _dlim2$1$[esp+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 299  : 			u32 C			= iFloor(G.fade*scale*(1-(dist_sq/dlim2)));

	movaps	xmm0, xmm5

; 300  : 			u32 clr			= color_rgba(C,C,C,C);
; 301  : 			Fvector	gp		;
; 302  : 					gp.mad	(G.position,dir,G.radius*scale);
; 303  : 			FillSprite		(pv,G.position,G.radius,clr);

	movss	xmm4, DWORD PTR [edi+100]
	subss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm7, xmm4
	movaps	xmm6, xmm4
	movaps	xmm2, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 299  : 			u32 C			= iFloor(G.fade*scale*(1-(dist_sq/dlim2)));

	mulss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+80], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+80]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	movzx	eax, al
	or	ebx, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebx, 8
	shr	ebx, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	eax, bl
	shl	ebx, 8
	or	ebx, eax
	shl	ebx, 8
	or	ebx, eax
	shl	ebx, 8
	or	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mulss	xmm1, DWORD PTR [eax+528]
	mulss	xmm0, DWORD PTR [eax+524]
	mulss	xmm7, DWORD PTR [eax+512]
	mulss	xmm6, DWORD PTR [eax+516]
	mulss	xmm2, DWORD PTR [eax+532]
	movaps	xmm5, xmm7
	mulss	xmm4, DWORD PTR [eax+520]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	addss	xmm7, xmm0

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	eax, DWORD PTR _pv$1$[esp+80]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm3, xmm6

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	subss	xmm5, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, xmm1

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm1

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movss	DWORD PTR _z$1$[esp+80], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm1, DWORD PTR [edi+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm4, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	xmm0, DWORD PTR _z$1$[esp+80]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	subss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [eax+12], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+16], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+20], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm1, DWORD PTR tv2169[esp+80]
	subss	xmm1, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR _z$1$[esp+80], xmm0

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+4], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 190  : 	pv->set		(d.x+pos.x,d.y+pos.y,d.z+pos.z, clr, 0.f,1.f);	pv++;

	movss	xmm1, DWORD PTR tv2170[esp+80]
	subss	xmm1, xmm0

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+8], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 191  : 	pv->set		(a.x+pos.x,a.y+pos.y,a.z+pos.z, clr, 0.f,0.f);	pv++;

	movaps	xmm1, xmm4
	addss	xmm2, DWORD PTR [edi+80]
	addss	xmm1, DWORD PTR [edi+84]
	addss	xmm0, DWORD PTR [edi+76]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+28], xmm2
	movss	DWORD PTR [eax+32], xmm1
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [eax+36], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+40], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+24], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+44], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 192  : 	pv->set		(c.x+pos.x,c.y+pos.y,c.z+pos.z, clr, 1.f,1.f);	pv++;

	movss	xmm0, DWORD PTR [edi+76]
	movss	xmm2, DWORD PTR [edi+80]
	subss	xmm0, xmm5
	movss	xmm1, DWORD PTR [edi+84]
	subss	xmm2, xmm3
	movss	xmm5, DWORD PTR __real@3f800000
	subss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [eax+60], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+64], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+48], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	movss	xmm0, DWORD PTR _z$1$[esp+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+52], xmm2
	movss	DWORD PTR [eax+56], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+68], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	addss	xmm6, DWORD PTR [edi+80]
	addss	xmm0, DWORD PTR [edi+84]
	addss	xmm7, DWORD PTR [edi+76]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 31   : 		IC void		set(float x, float y, float z, u32 C, float u, float v) { p.set(x, y, z); color = C; t.set(u, v); }

	mov	DWORD PTR [eax+84], ebx
	mov	ebx, DWORD PTR _pos$1$[esp+80]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [eax+76], xmm6
	movss	DWORD PTR [eax+80], xmm0
	movss	DWORD PTR [eax+72], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	mov	DWORD PTR [eax+88], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+92], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 193  : 	pv->set		(b.x+pos.x,b.y+pos.y,b.z+pos.z,	clr, 1.f,0.f);	pv++;

	add	eax, 96					; 00000060H
	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	DWORD PTR _pv$1$[esp+80], eax
$LN7@render_sel:

; 276  : 		for (; pos<end; pos++)

	mov	edi, DWORD PTR _this$1$[esp+80]
	inc	ebx
	mov	DWORD PTR _pos$1$[esp+80], ebx
	cmp	ebx, DWORD PTR _end$1$[esp+80]
	jb	$LL9@render_sel
	mov	ecx, DWORD PTR _pvs$1$[esp+80]
$LN8@render_sel:

; 304  : 		}
; 305  : 		int vCount				= int(pv-pvs);

	sub	eax, ecx

; 306  : 		RCache.Vertex.Unlock	(vCount,hGeom->vb_stride);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	sar	eax, 3
	imul	esi, eax, -1431655765
	mov	eax, DWORD PTR [edi+60]
	push	DWORD PTR [eax+20]
	mov	DWORD PTR _vCount$1$[esp+84], esi
	push	esi
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 307  : 		if (vCount) {

	test	esi, esi
	je	$LN14@render_sel

; 308  : 			RCache.set_Shader		(T);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _T$[esp+80]
	push	0
	push	eax
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	ecx, DWORD PTR [edi+60]
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 309  : 			RCache.set_Geometry		(hGeom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	DWORD PTR $T2[esp+80], ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN215@render_sel

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
	mov	ecx, DWORD PTR $T2[esp+80]
$LN215@render_sel:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __vb$1$[esp+80], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], eax
	jne	SHORT $LN219@render_sel
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN218@render_sel
$LN219@render_sel:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	DWORD PTR __vb$1$[esp+88]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
	mov	ecx, DWORD PTR $T2[esp+80]
$LN218@render_sel:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ecx+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN222@render_sel

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN222@render_sel:
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 310  : 			RCache.Render			(D3DPT_TRIANGLELIST,vOffset,0,vCount,0,vCount/2);

	mov	ecx, DWORD PTR _vOffset$3[esp+80]
	mov	esi, DWORD PTR _vCount$1$[esp+80]
	mov	eax, esi
	cdq
	mov	DWORD PTR _baseV$1$[esp+80], ecx
	sub	eax, edx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	sar	eax, 1
	mov	DWORD PTR _PC$1$[esp+80], eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 199  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]

; 200  : 	stat.verts += countV;

	add	DWORD PTR [ecx+9020], esi

; 201  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], eax

; 202  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN228@render_sel
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN227@render_sel
$LN228@render_sel:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN227@render_sel:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	push	DWORD PTR _PC$1$[esp+80]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	0
	push	esi
	push	0
	mov	eax, DWORD PTR [eax+8]
	push	DWORD PTR _baseV$1$[esp+96]
	push	4
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+328]
$LN14@render_sel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	esi, DWORD PTR [edi+16]
	mov	eax, esi
	mov	ecx, DWORD PTR [edi+12]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 267  : 	for (;pos<Selected.size();) 

	cmp	ebx, eax
	jb	$LL2@render_sel
$LN3@render_sel:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	ecx, esi
	je	SHORT $LN245@render_sel

; 1426 :             _Orphan_range(_Firstptr, _Mylast);
; 1427 : 
; 1428 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

	push	ecx
	mov	edx, esi
	mov	ecx, esi
	call	??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
	add	esp, 4

; 1429 :             _Destroy(_Newlast, _Mylast);
; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+16], eax
$LN245@render_sel:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _T$[esp+80]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\GlowManager.cpp

; 314  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?render_selected@CGlowManager@@QAEXXZ ENDP		; CGlowManager::render_selected
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_not_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_not_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_not_free, COMDAT
; _this$ = ecx

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	push	esi
	mov	esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	eax, DWORD PTR [esi]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	ecx, DWORD PTR [esi+4]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	eax, ecx
	je	SHORT $LN16@clear_not_

; 1426 :             _Orphan_range(_Firstptr, _Mylast);
; 1427 : 
; 1428 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

	push	eax
	mov	edx, ecx
	call	??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
	add	esp, 4

; 1429 :             _Destroy(_Newlast, _Mylast);
; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [esi+4], eax
$LN16@clear_not_:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	ret	0
?clear_not_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_not_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QBEIXZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QBEIXZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBE_NXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBE_NXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXI@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN9@reserve

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Reallocate_exactly
$LN2@reserve:

; 1364 :         }
; 1365 :     }

	ret	4
$LN9@reserve:

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength
$LN7@reserve:
	int	3
?reserve@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXI@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN14@push_back
	inc	DWORD PTR [eax+4]
$LN14@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 722  :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h
;	COMDAT ?distance@?$_plane@M@@QAEMABU?$_vector3@M@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?distance@?$_plane@M@@QAEMABU?$_vector3@M@@@Z PROC	; _plane<float>::distance, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _v$[esp-4]
	fld	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	faddp	ST(1), ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	fadd	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	fabs
; File I:\Vitalya\mine\NSProjectX\xrCore\_plane.h

; 69   : 	}

	ret	4
?distance@?$_plane@M@@QAEMABU?$_vector3@M@@@Z ENDP	; _plane<float>::distance
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
;	COMDAT ?normalize_safe@?$_vector3@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?normalize_safe@?$_vector3@M@@QAEAAU1@ABU1@@Z PROC	; _vector3<float>::normalize_safe, COMDAT
; _this$ = ecx

; 223  : 		T magnitude=v.x*v.x + v.y*v.y + v.z*v.z;

	mov	eax, DWORD PTR _v$[esp-4]
	movss	xmm3, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	movaps	xmm2, xmm3
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm2, xmm3
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0

; 224  : 		if (magnitude>std::numeric_limits<T>::min()) {

	comiss	xmm2, DWORD PTR __real@00800000
	jbe	SHORT $LN10@normalize_

; 225  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 226  : 			x = v.x*magnitude;

	mulss	xmm3, xmm1

; 227  : 			y = v.y*magnitude;

	movaps	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm3
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0

; 228  : 			z = v.z*magnitude;

	mulss	xmm1, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+8], xmm1
$LN10@normalize_:

; 229  : 		}
; 230  : 		return *this;	
; 231  : 	}

	mov	eax, ecx
	ret	4
?normalize_safe@?$_vector3@M@@QAEAAU1@ABU1@@Z ENDP	; _vector3<float>::normalize_safe
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@0@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::erase, COMDAT
; _this$ = ecx

; 1413 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	push	esi

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, ecx

; 1415 :         const pointer _Lastptr  = _Last._Ptr;
; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	mov	ecx, DWORD PTR __Last$[esp+4]
	cmp	esi, ecx
	je	SHORT $LN8@erase

; 1426 :             _Orphan_range(_Firstptr, _Mylast);
; 1427 : 
; 1428 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

	mov	edx, DWORD PTR [edi+4]
	push	esi
	call	??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
	add	esp, 4

; 1429 :             _Destroy(_Newlast, _Mylast);
; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
$LN8@erase:

; 1431 :         }
; 1432 : 
; 1433 :         return iterator(_Firstptr, _STD addressof(_My_data));
; 1434 :     }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	ret	12					; 0000000cH
?erase@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@2@0@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
tv218 = 8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv218[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN18@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR tv218[ebp]
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN21@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXI@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEABV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEABV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEABV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@II@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@II@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN20@Umove_if_n
	inc	DWORD PTR [ecx+4]
$LN20@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXXZ PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXXZ ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@IPBX@Z PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@IPBX@Z ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN18@Umove_if_n
	inc	DWORD PTR [ecx+4]
$LN18@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEIXZ PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEIXZ ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??$?MUShader@@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z
_TEXT	SEGMENT
??$?MUShader@@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z PROC ; operator<<Shader,resptrcode_shader>, COMDAT
; _a$ = ecx
; _b$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	setb	al
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 96   : template<class T, typename D>			inline bool operator	<	(resptr_core<T,D> const & a, resptr_core<T,D> const & b)		{ return std::less<T *>()(a._get(), b._get());		}

	ret	0
??$?MUShader@@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ENDP ; operator<<Shader,resptrcode_shader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@1@Z@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __Pred$dead$ = ecx

; 7076 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

	push	ecx

; 7077 :     _Adl_verify_range(_First, _Last);
; 7078 :     const auto _UFirst = _Get_unwrapped(_First);
; 7079 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7080 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

	mov	edx, DWORD PTR __Last$[esp]
	mov	eax, edx
	mov	ecx, DWORD PTR __First$[esp]
	sub	eax, ecx
	sar	eax, 2
	push	OFFSET ?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; glow_compare
	push	eax
	call	??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 8

; 7081 : }

	pop	ecx
	ret	0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@1@Z@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z PROC ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	ebp
	push	edi
	mov	ebp, edx
	mov	edi, ecx

; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	cmp	edi, ebp
	je	SHORT $LN19@Move_unche
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp+8]
	push	esi
$LL4@Move_unche:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [edi]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN13@Move_unche
	inc	DWORD PTR [esi+4]
$LN13@Move_unche:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	add	edi, 4
	add	ebx, 4
	cmp	edi, ebp
	jne	SHORT $LL4@Move_unche

; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	edi

; 4325 : }

	pop	ebp
	ret	0
$LN19@Move_unche:

; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	edi

; 4325 : }

	pop	ebp
	ret	0
??$_Move_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ENDP ; std::_Move_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z PROC ; std::_Unfancy<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ENDP ; std::_Unfancy<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
??$destroy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::destroy<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::destroy<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z PROC ; std::move<resptr_core<IRender_Glow,resptrcode_glow> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ENDP ; std::move<resptr_core<IRender_Glow,resptrcode_glow> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z PROC ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ENDP ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@construct
	inc	DWORD PTR [eax+4]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z
_TEXT	SEGMENT
__Newvec$ = -32						; size = 4
tv431 = -28						; size = 4
__Newsize$1$ = -24					; size = 4
tv437 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN41@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], edi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	eax, 2
	mov	DWORD PTR tv431[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR tv437[ebp], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN27@Emplace_re
	inc	DWORD PTR [eax+4]
$LN27@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	push	edi
	cmp	ebx, eax
	jne	SHORT $LN4@Emplace_re

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	eax
	push	ecx
	call	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove_if_noexcept

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	ecx
	call	?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv437[ebp]
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [esi+4]
	push	ebx
	call	?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN36@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN36@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR tv431[ebp]
	add	ecx, edi
	mov	DWORD PTR [esi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv437[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QBEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN41@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Xlength
$LN39@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV2@$$QAV2@@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_reallocate<resptr_core<IRender_Glow,resptrcode_glow> >
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Glow,resptrcode_glow> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z PROC ; std::_Destroy_range<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ENDP ; std::_Destroy_range<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; xr_free<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; xr_free<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z PROC ; xr_alloc<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@I@Z ENDP ; xr_alloc<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z PROC ; std::_Uninitialized_copy<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	inc	DWORD PTR [edx+4]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ENDP ; std::_Uninitialized_copy<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::_Get_unwrapped<resptr_core<IRender_Glow,resptrcode_glow> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::_Get_unwrapped<resptr_core<IRender_Glow,resptrcode_glow> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??R?$less@PAUShader@@@std@@QBE_NABQAUShader@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAUShader@@@std@@QBE_NABQAUShader@@0@Z PROC	; std::less<Shader *>::operator(), COMDAT
; _this$dead$ = ecx

; 117  :         return _Left < _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	setb	al

; 118  :     }

	ret	8
??R?$less@PAUShader@@@std@@QBE_NABQAUShader@@0@Z ENDP	; std::less<Shader *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@QBEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??4?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEAAV0@ABV0@@Z PROC ; resptr_core<IRender_Glow,resptrcode_glow>::operator=, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	push	esi
	push	edi
	mov	edi, ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN8@operator
	inc	DWORD PTR [esi+4]
$LN8@operator:
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [edi], esi

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??4?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEAAV0@ABV0@@Z ENDP ; resptr_core<IRender_Glow,resptrcode_glow>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEII@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@ABEII@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z PROC ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN18@Umove
	inc	DWORD PTR [edx+4]
$LN18@Umove:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV3@00@Z ENDP ; std::vector<resptr_core<IRender_Glow,resptrcode_glow>,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@ABV2@@Z PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::construct, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN5@construct
	inc	DWORD PTR [ecx+4]
$LN5@construct:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	ret	8
?construct@?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAEXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@ABV2@@Z ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAE@XZ PROC ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::xalloc<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@QAE@XZ ENDP ; xalloc<resptr_core<IRender_Glow,resptrcode_glow> >::xalloc<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@ABV0@@Z PROC ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>, COMDAT
; _this$ = ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN6@resptr_cor
	inc	DWORD PTR [eax+4]
$LN6@resptr_cor:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, ecx
	ret	4
??0?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAE@ABV0@@Z ENDP ; resptr_core<IRender_Glow,resptrcode_glow>::resptr_core<IRender_Glow,resptrcode_glow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<resptr_core<IRender_Glow,resptrcode_glow> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Pass_fn@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z$0A@@std@@YAP6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@ZP6A_N00@Z@Z
_TEXT	SEGMENT
??$_Pass_fn@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z$0A@@std@@YAP6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@ZP6A_N00@Z@Z PROC ; std::_Pass_fn<bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>),0>, COMDAT
; __Val$dead$ = ecx

; 253  :     return _Val;

	mov	eax, OFFSET ?glow_compare@@YA_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ; glow_compare

; 254  : }

	ret	0
??$_Pass_fn@P6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z$0A@@std@@YAP6A_NV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@ZP6A_N00@Z@Z ENDP ; std::_Pass_fn<bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>),0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -16						; size = 4
tv728 = -12						; size = 4
__Mid$2 = -12						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z PROC ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7046 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	ebp, DWORD PTR __Pred$[esp+24]
	mov	ebx, edx
	push	esi
	mov	esi, ecx
	mov	eax, ebx
	sub	eax, esi
	and	eax, -4					; fffffffcH
	push	edi
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN214@Sort_unche
	mov	edi, DWORD PTR __Ideal$[esp+32]
$LL2@Sort_unche:

; 7051 :             return;
; 7052 :         }
; 7053 : 
; 7054 :         if (_Ideal <= 0) { // heap sort if too many divisions

	push	ebp
	test	edi, edi
	jle	SHORT $LN215@Sort_unche

; 7056 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7057 :             return;
; 7058 :         }
; 7059 : 
; 7060 :         // divide and conquer by quicksort
; 7061 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

	push	ebx
	mov	edx, esi
	lea	ecx, DWORD PTR __Mid$2[esp+44]
	call	??$_Partition_by_median_guess_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YA?AU?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@0@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV2@1@Z@Z ; std::_Partition_by_median_guess_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 7062 : 
; 7063 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7064 : 
; 7065 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

	mov	edx, DWORD PTR __Mid$2[esp+44]
	mov	eax, edi
	sar	eax, 2
	add	esp, 8
	sar	edi, 1
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Mid$2[esp+40]
	add	edi, eax
	mov	eax, edx
	and	ecx, -4					; fffffffcH
	sub	eax, esi
	and	eax, -4					; fffffffcH
	push	ebp
	push	edi
	cmp	eax, ecx
	jge	SHORT $LN7@Sort_unche

; 7066 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

	mov	ecx, esi
	call	??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 7067 :             _First = _Mid.second;

	mov	esi, DWORD PTR __Mid$2[esp+48]

; 7068 :         } else { // loop on first half

	jmp	SHORT $LN222@Sort_unche
$LN7@Sort_unche:

; 7069 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

	mov	ecx, DWORD PTR __Mid$2[esp+48]
	mov	edx, ebx
	call	??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 7070 :             _Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$2[esp+44]
$LN222@Sort_unche:

; 7047 :     // order [_First, _Last)
; 7048 :     for (;;) {
; 7049 :         if (_Last - _First <= _ISORT_MAX) { // small

	mov	eax, ebx
	add	esp, 8
	sub	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 128				; 00000080H
	jg	SHORT $LL2@Sort_unche
$LN214@Sort_unche:

; 7050 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

	push	ebp
	mov	edx, ebx
	mov	ecx, esi
	call	??$_Insertion_sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0P6A_NV1@1@Z@Z ; std::_Insertion_sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 4
$LN12@Sort_unche:

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN215@Sort_unche:

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	mov	edx, ebx
	mov	ecx, esi
	call	??$_Make_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ; std::_Make_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, ebx

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	add	esp, 4

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	eax, esi
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN12@Sort_unche

; 7055 :             _Make_heap_unchecked(_First, _Last, _Pred);

	mov	eax, 4
	add	ebx, -4					; fffffffcH
	sub	eax, esi
	mov	DWORD PTR tv728[esp+36], eax
$LL13@Sort_unche:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR __Val$1[esp+36], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN20@Sort_unche
	inc	DWORD PTR [eax+4]
$LN20@Sort_unche:

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [esi]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN32@Sort_unche
	inc	DWORD PTR [edi+4]
$LN32@Sort_unche:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+36]
	mov	edi, DWORD PTR tv728[esp+36]
	xor	edx, edx
	push	ebp
	push	eax
	mov	ecx, esi
	lea	eax, DWORD PTR [edi-4]
	add	eax, ebx
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR __Val$1[esp+36]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	ebx, 4
	lea	eax, DWORD PTR [edi+ebx]
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL13@Sort_unche

; 7071 :         }
; 7072 :     }
; 7073 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0HP6A_NV1@1@Z@Z ENDP ; std::_Sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z PROC ; std::_Uninitialized_move<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	inc	DWORD PTR [edx+4]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@Z ENDP ; std::_Uninitialized_move<resptr_core<IRender_Glow,resptrcode_glow> *,xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::_Destroy_in_place<resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::_Destroy_in_place<resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -12						; size = 4
__First$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Insertion_sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0P6A_NV1@1@Z@Z PROC ; std::_Insertion_sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6919 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Last$1$[esp+28], edx
	mov	DWORD PTR __First$1$[esp+28], edi

; 6920 :     // insertion sort [_First, _Last)
; 6921 :     if (_First != _Last) {

	cmp	edi, edx
	je	$LN92@Insertion_

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	lea	ebp, DWORD PTR [edi+4]
	cmp	ebp, edx
	je	$LN92@Insertion_
	mov	esi, DWORD PTR __Pred$[esp+24]
	npad	8
$LL2@Insertion_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6923 :             _BidIt _Hole               = _Mid;

	mov	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR __Val$1[esp+28], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN14@Insertion_
	inc	DWORD PTR [eax+4]
$LN14@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN19@Insertion_
	inc	DWORD PTR [ecx+4]
$LN19@Insertion_:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$1[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	push	ecx
	mov	ecx, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR __Val$1[esp+36]
	test	eax, eax
	je	SHORT $LN24@Insertion_
	inc	DWORD PTR [eax+4]
$LN24@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6926 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN9@Insertion_

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	lea	ebx, DWORD PTR [ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	ebp, edi
	je	SHORT $LN29@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6927 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

	mov	edi, ebp
$LL84@Insertion_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [edi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	edi, 4
	sub	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN38@Insertion_
	inc	DWORD PTR [esi+4]
$LN38@Insertion_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	edi, DWORD PTR __First$1$[esp+28]
	jne	SHORT $LL84@Insertion_
	mov	edi, DWORD PTR __First$1$[esp+28]
$LN29@Insertion_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR __Val$1[esp+28]
	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN47@Insertion_
	inc	DWORD PTR [esi+4]
$LN47@Insertion_:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6929 :             } else { // look for insertion point after first

	jmp	SHORT $LN10@Insertion_
$LN9@Insertion_:

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	edi, ebp
$LL7@Insertion_:
	sub	edi, 4
	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN51@Insertion_
	inc	DWORD PTR [ecx+4]
$LN51@Insertion_:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$1[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	push	ecx
	mov	ecx, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR __Val$1[esp+36]
	test	eax, eax
	je	SHORT $LN56@Insertion_
	inc	DWORD PTR [eax+4]
$LN56@Insertion_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	call	esi
	add	esp, 8
	test	al, al
	je	SHORT $LN6@Insertion_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [edi]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN66@Insertion_
	inc	DWORD PTR [esi+4]
$LN66@Insertion_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6930 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

	mov	ebx, edi
	mov	esi, DWORD PTR __Pred$[esp+24]
	jmp	SHORT $LL7@Insertion_
$LN6@Insertion_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR __Val$1[esp+28]
	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN75@Insertion_
	inc	DWORD PTR [esi+4]
$LN75@Insertion_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	edi, DWORD PTR __First$1$[esp+28]
	mov	DWORD PTR [ebx], esi
$LN10@Insertion_:

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR __Val$1[esp+28]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6922 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

	mov	edx, DWORD PTR __Last$1$[esp+28]
	add	ebp, 4
	mov	esi, DWORD PTR __Pred$[esp+24]
	cmp	ebp, edx
	jne	$LL2@Insertion_
$LN92@Insertion_:

; 6931 :                     *_Hole = _STD move(*_Prev); // move hole down
; 6932 :                 }
; 6933 : 
; 6934 :                 *_Hole = _STD move(_Val); // insert element in hole
; 6935 :             }
; 6936 :         }
; 6937 :     }
; 6938 : 
; 6939 :     return _Last;
; 6940 : }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, edx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
??$_Insertion_sort_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAV1@0P6A_NV1@1@Z@Z ENDP ; std::_Insertion_sort_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -20						; size = 4
__Hole$1$ = -16						; size = 4
__Max_sequence_non_leaf$1$ = -12			; size = 4
__Bottom$1$ = -8					; size = 4
tv795 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Make_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z PROC ; std::_Make_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5544 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 5545 :     // make [_First, _Last) into a heap
; 5546 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 5547 :     _Diff _Bottom = _Last - _First;

	sub	edx, ebp
	sar	edx, 2

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, edx
	mov	DWORD PTR __Bottom$1$[esp+28], edx
	sar	eax, 1
	push	esi
	push	edi
	test	eax, eax
	jle	$LN3@Make_heap_
	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR tv795[esp+36], ecx
	sar	ecx, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+36], ecx
	npad	5
$LL2@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	esi, DWORD PTR [ebp+eax*4-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5550 :         --_Hole;

	dec	eax
	mov	DWORD PTR __Hole$1$[esp+36], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR __Val$1[esp+36], esi
	test	esi, esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN8@Make_heap_
	inc	DWORD PTR [esi+4]
$LN8@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5552 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

	mov	ebx, eax

; 5381 :     _Diff _Idx       = _Hole;

	mov	esi, eax

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	cmp	eax, ecx
	jge	SHORT $LN13@Make_heap_
	npad	4
$LL12@Make_heap_:

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+esi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN19@Make_heap_
	inc	DWORD PTR [ecx+4]
$LN19@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN24@Make_heap_
	inc	DWORD PTR [ecx+4]
$LN24@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	je	SHORT $LN14@Make_heap_

; 5389 :             --_Idx;

	dec	esi
$LN14@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ebx, DWORD PTR [ebx*4]
	add	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN34@Make_heap_
	inc	DWORD PTR [edi+4]
$LN34@Make_heap_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	ebx, esi
	cmp	esi, ecx
	jl	SHORT $LL12@Make_heap_
	mov	edx, DWORD PTR __Bottom$1$[esp+36]
$LN13@Make_heap_:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, ecx
	jne	SHORT $LN15@Make_heap_
	test	dl, 1
	jne	SHORT $LN15@Make_heap_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebp+edx*4-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	lea	edi, DWORD PTR [ebx*4]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN43@Make_heap_
	inc	DWORD PTR [esi+4]
$LN43@Make_heap_:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	mov	ebx, DWORD PTR tv795[esp+36]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], esi
$LN15@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Hole$1$[esp+36], ebx
	jge	SHORT $LN93@Make_heap_
$LL48@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$1[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	edi, DWORD PTR [ebx-1]

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	ecx
	mov	ecx, esp
	sar	edi, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR __Val$1[esp+40]
	test	eax, eax
	je	SHORT $LN52@Make_heap_
	inc	DWORD PTR [eax+4]
$LN52@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN57@Make_heap_
	inc	DWORD PTR [ecx+4]
$LN57@Make_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	call	DWORD PTR __Pred$[esp+40]
	add	esp, 8
	test	al, al
	je	SHORT $LN93@Make_heap_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebp+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ebx, DWORD PTR [ebx*4]
	add	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN67@Make_heap_
	inc	DWORD PTR [esi+4]
$LN67@Make_heap_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	ebx, edi
	cmp	DWORD PTR __Hole$1$[esp+36], edi
	jl	SHORT $LL48@Make_heap_
$LN93@Make_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR __Val$1[esp+36]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	edi, DWORD PTR [ebx*4]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN76@Make_heap_
	inc	DWORD PTR [esi+4]
$LN76@Make_heap_:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR __Val$1[esp+36]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], esi

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5548 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

	mov	eax, DWORD PTR __Hole$1$[esp+36]
	mov	ecx, DWORD PTR __Max_sequence_non_leaf$1$[esp+36]
	mov	edx, DWORD PTR __Bottom$1$[esp+36]
	test	eax, eax
	jg	$LL2@Make_heap_
$LN3@Make_heap_:

; 5553 :     }
; 5554 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Make_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ENDP ; std::_Make_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Sort_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z PROC ; std::_Sort_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5772 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	mov	eax, edx
	sub	eax, ebx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN3@Sort_heap_
	push	ebp
	push	esi
	mov	ebp, 4
	push	edi
	lea	edi, DWORD PTR [edx-4]
	sub	ebp, ebx
	npad	3
$LL4@Sort_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Val$1[esp+20], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN11@Sort_heap_
	inc	DWORD PTR [eax+4]
$LN11@Sort_heap_:

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebx]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN23@Sort_heap_
	inc	DWORD PTR [esi+4]
$LN23@Sort_heap_:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+16]
	lea	eax, DWORD PTR __Val$1[esp+24]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	eax
	lea	eax, DWORD PTR [ebp-4]
	xor	edx, edx
	add	eax, edi
	mov	ecx, ebx
	sar	eax, 2
	push	eax
	call	??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR __Val$1[esp+20]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5774 :     for (; _Last - _First >= 2; --_Last) {

	sub	edi, 4
	lea	eax, DWORD PTR [edi+ebp]
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jge	SHORT $LL4@Sort_heap_
	pop	edi
	pop	esi
	pop	ebp
$LN3@Sort_heap_:
	pop	ebx

; 5775 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 5776 :     }
; 5777 : }

	pop	ecx
	ret	0
??$_Sort_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ENDP ; std::_Sort_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YA?AU?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@0@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV2@1@Z@Z
_TEXT	SEGMENT
__First$1$ = -16					; size = 4
$T1 = -12						; size = 4
__Glast$1$ = -12					; size = 4
$T2 = -8						; size = 4
__Last$1$ = -8						; size = 4
__Gfirst$1$ = -8					; size = 4
__Plast$1$ = -8						; size = 4
___$ReturnUdt$1$ = -4					; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Partition_by_median_guess_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YA?AU?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@0@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV2@1@Z@Z PROC ; std::_Partition_by_median_guess_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	sub	esp, 16					; 00000010H
	mov	DWORD PTR ___$ReturnUdt$1$[esp+16], ecx

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	mov	ecx, DWORD PTR __Last$[esp+12]
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR __First$1$[esp+16], edx
	sar	eax, 3

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	add	ecx, -4					; fffffffcH
	push	ebx
	push	ebp

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	ebp, DWORD PTR __Pred$[esp+20]

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	esi

; 6977 :     // partition [_First, _Last)
; 6978 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

	lea	esi, DWORD PTR [edx+eax*4]

; 6979 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

	mov	DWORD PTR __Last$1$[esp+28], ecx

; 6962 :     const _Diff _Count = _Last - _First;

	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2

; 6976 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	edi

; 6963 :     if (40 < _Count) { // Tukey's ninther

	cmp	eax, 40					; 00000028H
	jle	SHORT $LN35@Partition_

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	push	ebp
	lea	edi, DWORD PTR [eax*4]
	lea	ecx, DWORD PTR [edi+edx]
	lea	ebx, DWORD PTR [eax*8]
	mov	DWORD PTR $T1[esp+36], ecx
	lea	eax, DWORD PTR [ebx+edx]
	mov	edx, ecx
	mov	ecx, DWORD PTR __First$1$[esp+36]
	push	eax
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	lea	eax, DWORD PTR [edi+esi]
	mov	ecx, esi
	push	ebp
	push	eax
	sub	ecx, edi
	mov	edx, esi
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	mov	eax, DWORD PTR __Last$1$[esp+48]
	mov	ecx, eax
	sub	ecx, edi
	push	ebp
	push	eax
	sub	eax, ebx
	mov	DWORD PTR $T2[esp+56], ecx
	mov	edx, ecx
	mov	ecx, eax
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	ecx, DWORD PTR $T2[esp+56]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR $T1[esp+32]
	jmp	SHORT $LN36@Partition_
$LN35@Partition_:

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

	mov	eax, edx
$LN36@Partition_:

; 6980 :     _RanIt _Pfirst = _Mid;

	push	ebp
	push	ecx
	mov	edx, esi
	mov	ecx, eax
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 8

; 6981 :     _RanIt _Plast  = _Next_iter(_Pfirst);

	lea	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Plast$1$[esp+32], ebx

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	cmp	DWORD PTR __First$1$[esp+32], esi
	jae	SHORT $LN164@Partition_
	mov	ebx, DWORD PTR __First$1$[esp+32]
$LL2@Partition_:
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN40@Partition_
	inc	DWORD PTR [ecx+4]
$LN40@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN45@Partition_
	inc	DWORD PTR [ecx+4]
$LN45@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN189@Partition_
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN50@Partition_
	inc	DWORD PTR [ecx+4]
$LN50@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN55@Partition_
	inc	DWORD PTR [ecx+4]
$LN55@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6984 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN189@Partition_

; 6985 :         --_Pfirst;

	add	esi, -4					; fffffffcH
	cmp	ebx, esi
	jb	SHORT $LL2@Partition_
$LN189@Partition_:
	mov	ebx, DWORD PTR __Plast$1$[esp+32]
$LN164@Partition_:

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	eax, DWORD PTR __Last$[esp+28]
	cmp	ebx, eax
	jae	SHORT $LN5@Partition_
$LL4@Partition_:
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN60@Partition_
	inc	DWORD PTR [ecx+4]
$LN60@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN65@Partition_
	inc	DWORD PTR [ecx+4]
$LN65@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN195@Partition_
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN70@Partition_
	inc	DWORD PTR [ecx+4]
$LN70@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN75@Partition_
	inc	DWORD PTR [ecx+4]
$LN75@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	call	ebp
	add	esp, 8
	test	al, al
	mov	eax, DWORD PTR __Last$[esp+28]
	jne	SHORT $LN5@Partition_

; 6989 :         ++_Plast;

	add	ebx, 4
	cmp	ebx, eax
	jb	SHORT $LL4@Partition_

; 6988 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

	jmp	SHORT $LN5@Partition_
$LN195@Partition_:
	mov	eax, DWORD PTR __Last$[esp+28]
$LN5@Partition_:

; 6990 :     }
; 6991 : 
; 6992 :     _RanIt _Gfirst = _Plast;

	mov	edi, ebx

; 6993 :     _RanIt _Glast  = _Pfirst;

	mov	edx, esi
$LN198@Partition_:

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	mov	DWORD PTR __Glast$1$[esp+32], edx
$LN197@Partition_:
	mov	DWORD PTR __Gfirst$1$[esp+32], edi
	npad	7
$LL6@Partition_:
	cmp	edi, eax
	jae	SHORT $LN168@Partition_
$LL11@Partition_:

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN80@Partition_
	inc	DWORD PTR [ecx+4]
$LN80@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN85@Partition_
	inc	DWORD PTR [ecx+4]
$LN85@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6997 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN9@Partition_

; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN90@Partition_
	inc	DWORD PTR [ecx+4]
$LN90@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN95@Partition_
	inc	DWORD PTR [ecx+4]
$LN95@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6999 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

	call	ebp
	add	esp, 8
	test	al, al
	jne	SHORT $LN191@Partition_

; 7000 :                 break;
; 7001 :             } else if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN19@Partition_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [edi], ecx
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6996 :         for (; _Gfirst < _Last; ++_Gfirst) {

	add	ebx, 4
$LN9@Partition_:
	add	edi, 4
	cmp	edi, DWORD PTR __Last$[esp+28]
	jb	SHORT $LL11@Partition_
$LN191@Partition_:
	mov	edx, DWORD PTR __Glast$1$[esp+32]
	mov	DWORD PTR __Gfirst$1$[esp+32], edi
$LN168@Partition_:

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	eax, DWORD PTR __First$1$[esp+32]
	cmp	edx, eax
	jbe	$LN196@Partition_
	lea	ebp, DWORD PTR [edx-4]
	mov	edi, eax
	npad	1
$LL14@Partition_:

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN106@Partition_
	inc	DWORD PTR [ecx+4]
$LN106@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN111@Partition_
	inc	DWORD PTR [ecx+4]
$LN111@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7010 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	jne	SHORT $LN12@Partition_

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN116@Partition_
	inc	DWORD PTR [ecx+4]
$LN116@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN121@Partition_
	inc	DWORD PTR [ecx+4]
$LN121@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	call	DWORD PTR __Pred$[esp+36]
	add	esp, 8
	test	al, al
	jne	SHORT $LN193@Partition_

; 7013 :                 break;
; 7014 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

	sub	esi, 4
	cmp	esi, ebp
	je	SHORT $LN12@Partition_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [ebp], ecx
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7009 :         for (; _First < _Glast; --_Glast) {

	mov	edx, DWORD PTR __Glast$1$[esp+32]
	sub	ebp, 4
	sub	edx, 4
	mov	DWORD PTR __Glast$1$[esp+32], edx
	cmp	edi, edx
	jb	SHORT $LL14@Partition_

; 7012 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

	jmp	SHORT $LN192@Partition_
$LN193@Partition_:
	mov	edx, DWORD PTR __Glast$1$[esp+32]
$LN192@Partition_:
	mov	eax, DWORD PTR __First$1$[esp+32]

; 7015 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7016 :             }
; 7017 :         }
; 7018 : 
; 7019 :         if (_Glast == _First && _Gfirst == _Last) {

	cmp	edx, eax
	mov	edi, DWORD PTR __Gfirst$1$[esp+32]
	mov	ebp, DWORD PTR __Pred$[esp+28]
$LN196@Partition_:
	jne	SHORT $LN27@Partition_
	cmp	edi, DWORD PTR __Last$[esp+28]
	je	SHORT $LN170@Partition_

; 7020 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
; 7021 :         }
; 7022 : 
; 7023 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7024 :             if (_Plast != _Gfirst) {

	cmp	ebx, edi
	je	SHORT $LN29@Partition_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [ebx], ecx
$LN29@Partition_:
	mov	eax, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7028 :             ++_Plast;

	add	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7030 :             ++_Pfirst;

	add	esi, 4

; 7031 :             ++_Gfirst;

	mov	eax, DWORD PTR __Last$[esp+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	DWORD PTR [edi], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7031 :             ++_Gfirst;

	add	edi, 4
	jmp	$LN197@Partition_
$LN27@Partition_:

; 7032 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

	add	edx, -4					; fffffffcH
	mov	DWORD PTR __Glast$1$[esp+32], edx
	cmp	edi, DWORD PTR __Last$[esp+28]
	jne	SHORT $LN30@Partition_

; 7033 :             if (--_Glast != --_Pfirst) {

	sub	esi, 4
	cmp	edx, esi
	je	SHORT $LN180@Partition_
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	mov	eax, DWORD PTR __Last$[esp+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN180@Partition_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	eax, DWORD PTR [ebx-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7037 :             _STD iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	mov	eax, DWORD PTR __Last$[esp+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	DWORD PTR [ebx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7038 :         } else {

	jmp	$LL6@Partition_
$LN30@Partition_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7040 :             ++_Gfirst;

	add	edi, 4

; 7042 :     }

	mov	eax, DWORD PTR __Last$[esp+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	DWORD PTR [edx], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7042 :     }

	jmp	$LN198@Partition_
$LN170@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$1$[esp+32]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	esi
	pop	ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax+4], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 7043 : }

	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Partition_by_median_guess_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YA?AU?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@0@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV2@1@Z@Z ENDP ; std::_Partition_by_median_guess_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z PROC ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@Z ENDP ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@construct
	inc	DWORD PTR [eax+4]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::construct<resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Glow,resptrcode_glow> > >::_Emplace_back<resptr_core<IRender_Glow,resptrcode_glow> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z PROC ; std::_Move_backward_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4350 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

	push	ebp
	push	edi
	mov	edi, edx
	mov	ebp, ecx

; 4362 :     while (_First != _Last) {

	cmp	edi, ebp
	je	SHORT $LN19@Move_backw
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp+8]
	push	esi
$LL16@Move_backw:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [edi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4363 :         *--_Dest = _STD move(*--_Last);

	sub	edi, 4
	sub	ebx, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN12@Move_backw
	inc	DWORD PTR [esi+4]
$LN12@Move_backw:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4362 :     while (_First != _Last) {

	cmp	edi, ebp
	jne	SHORT $LL16@Move_backw

; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;

	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	edi

; 4367 : }

	pop	ebp
	ret	0
$LN19@Move_backw:

; 4364 :     }
; 4365 : 
; 4366 :     return _Dest;

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	edi

; 4367 : }

	pop	ebp
	ret	0
??$_Move_backward_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@00@Z ENDP ; std::_Move_backward_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Top$1$ = -12						; size = 4
__Max_sequence_non_leaf$1$ = -8				; size = 4
tv681 = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z PROC ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5375 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	ebx, DWORD PTR __Pred$[esp+12]
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR __Bottom$[esp+16]
	push	esi
	push	edi
	mov	edi, edx
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR __Top$1$[esp+28], edi
	mov	DWORD PTR tv681[esp+28], eax
	mov	esi, edi
	sar	eax, 1
	mov	DWORD PTR __Max_sequence_non_leaf$1$[esp+28], eax
	cmp	edi, eax
	jge	SHORT $LN3@Pop_heap_h
	npad	6
$LL2@Pop_heap_h:

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+esi*8+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5387 :         _Idx = 2 * _Idx + 2;

	lea	esi, DWORD PTR [esi*2+2]

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN9@Pop_heap_h
	inc	DWORD PTR [ecx+4]
$LN9@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN14@Pop_heap_h
	inc	DWORD PTR [ecx+4]
$LN14@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5388 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Pop_heap_h

; 5389 :             --_Idx;

	dec	esi
$LN4@Pop_heap_h:

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ebx, DWORD PTR [edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5391 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN24@Pop_heap_h
	inc	DWORD PTR [edi+4]
$LN24@Pop_heap_h:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5386 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

	mov	eax, DWORD PTR __Max_sequence_non_leaf$1$[esp+28]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5392 :         _Hole             = _Idx;

	mov	edi, esi
	mov	ebx, DWORD PTR __Pred$[esp+24]
	cmp	esi, eax
	jl	SHORT $LL2@Pop_heap_h
	mov	ecx, DWORD PTR __Bottom$[esp+24]
$LN3@Pop_heap_h:

; 5393 :     }
; 5394 : 
; 5395 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

	cmp	esi, eax
	jne	SHORT $LN5@Pop_heap_h
	test	cl, 1
	jne	SHORT $LN5@Pop_heap_h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebp+ecx*4-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5396 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

	lea	edi, DWORD PTR [edi*4]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN33@Pop_heap_h
	inc	DWORD PTR [esi+4]
$LN33@Pop_heap_h:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5397 :         _Hole             = _Bottom - 1;

	mov	edi, DWORD PTR tv681[esp+28]
$LN5@Pop_heap_h:

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$1$[esp+28], edi
	jge	SHORT $LN37@Pop_heap_h
$LL38@Pop_heap_h:
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR __Val$[esp+28]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	esi, DWORD PTR [edi-1]

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	eax, esp
	sar	esi, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN42@Pop_heap_h
	inc	DWORD PTR [ecx+4]
$LN42@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN47@Pop_heap_h
	inc	DWORD PTR [ecx+4]
$LN47@Pop_heap_h:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN37@Pop_heap_h

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ebx, DWORD PTR [edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [ebp+esi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN57@Pop_heap_h
	inc	DWORD PTR [edi+4]
$LN57@Pop_heap_h:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	edi, esi
	mov	ebx, DWORD PTR __Pred$[esp+24]
	cmp	DWORD PTR __Top$1$[esp+28], esi
	jl	SHORT $LL38@Pop_heap_h
$LN37@Pop_heap_h:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR __Val$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	edi, DWORD PTR [edi*4]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN66@Pop_heap_h
	inc	DWORD PTR [esi+4]
$LN66@Pop_heap_h:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5401 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ENDP ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Val$1 = -4						; size = 4
__Pred$ = 8						; size = 4
??$_Pop_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z PROC ; std::_Pop_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5415 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx
	push	esi
	mov	esi, edx
	mov	ebx, ecx

; 5416 :     // pop *_First to *(_Last - 1) and reheap
; 5417 :     if (2 <= _Last - _First) {

	mov	eax, esi
	sub	eax, ebx
	and	eax, -4					; fffffffcH
	cmp	eax, 8
	jl	SHORT $LN2@Pop_heap_u
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [esi-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5418 :         --_Last;

	sub	esi, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR __Val$1[esp+12], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN6@Pop_heap_u
	inc	DWORD PTR [eax+4]
$LN6@Pop_heap_u:
	push	edi

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [ebx]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN18@Pop_heap_u
	inc	DWORD PTR [edi+4]
$LN18@Pop_heap_u:
	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	lea	eax, DWORD PTR __Val$1[esp+20]
	sub	esi, ebx
	xor	edx, edx
	push	eax
	sar	esi, 2
	mov	ecx, ebx
	push	esi
	call	??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 12					; 0000000cH
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR __Val$1[esp+16]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	pop	edi
$LN2@Pop_heap_u:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5422 : }

	pop	ebx
	pop	ecx
	ret	0
??$_Pop_heap_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0P6A_NV1@1@Z@Z ENDP ; std::_Pop_heap_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Prev_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z PROC ; std::_Prev_iter<resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __First$ = ecx

; 1554 :     return --_First;

	lea	eax, DWORD PTR [ecx-4]

; 1555 : }

	ret	0
??$_Prev_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ENDP ; std::_Prev_iter<resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Mid$1$ = -4						; size = 4
$T1 = 8							; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Guess_median_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z PROC ; std::_Guess_median_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6959 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ecx
	push	ebx

; 6960 :     // sort median element to middle
; 6961 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 6962 :     const _Diff _Count = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp+4]
	mov	eax, ebx
	sub	eax, ecx
	push	ebp
	mov	ebp, edx
	sar	eax, 2

; 6963 :     if (40 < _Count) { // Tukey's ninther

	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	DWORD PTR __Mid$1$[esp+12], ebp
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Guess_medi

; 6964 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

	inc	eax
	sar	eax, 3
	push	esi
	push	edi

; 6965 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 6966 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

	push	edx
	lea	esi, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [eax*8]
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR $T1[esp+20], eax
	lea	edx, DWORD PTR [esi+ecx]
	lea	eax, DWORD PTR [edi+ecx]
	push	eax
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6967 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	push	DWORD PTR __Pred$[esp+24]
	lea	eax, DWORD PTR [esi+ebp]
	mov	ecx, ebp
	push	eax
	sub	ecx, esi
	mov	edx, ebp
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6968 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

	push	DWORD PTR __Pred$[esp+32]
	mov	ebp, ebx
	push	ebx
	sub	ebp, esi
	sub	ebx, edi
	mov	edx, ebp
	mov	ecx, ebx
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>

; 6969 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
; 6970 :     } else {

	mov	edx, DWORD PTR __Pred$[esp+40]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR $T1[esp+16]

; 6971 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);
; 6972 :     }
; 6973 : }

	mov	ecx, eax
	pop	edi
	pop	esi
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	push	ebp
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
$LN2@Guess_medi:
	push	edx
	mov	edx, DWORD PTR __Mid$1$[esp+16]
	mov	ebp, ebx
	mov	eax, ecx
	push	ebp
	call	??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 8
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Guess_median_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ENDP ; std::_Guess_median_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Next_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Next_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z PROC ; std::_Next_iter<resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __First$ = ecx

; 1541 :     return ++_First;

	lea	eax, DWORD PTR [ecx+4]

; 1542 : }

	ret	0
??$_Next_iter@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@Z ENDP ; std::_Next_iter<resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$iter_swap@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
??$iter_swap@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; std::iter_swap<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>, COMDAT
; __Left$ = ecx
; __Right$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	eax, DWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edx], esi
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 79   : }

	ret	0
??$iter_swap@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; std::iter_swap<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$?0AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV0@$0A@@?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@QAE@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV0@$0A@@?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@QAE@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; std::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *><resptr_core<IRender_Glow,resptrcode_glow> * &,resptr_core<IRender_Glow,resptrcode_glow> * &,0>, COMDAT
; _this$ = ecx

; 186  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??$?0AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV0@$0A@@?$pair@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@PAV1@@std@@QAE@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; std::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *>::pair<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow> *><resptr_core<IRender_Glow,resptrcode_glow> * &,resptr_core<IRender_Glow,resptrcode_glow> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Push_heap_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z PROC ; std::_Push_heap_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5264 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	push	ebp
	push	esi
	mov	esi, edx
	mov	ebp, ecx
	push	edi

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	cmp	DWORD PTR __Top$[esp+12], esi
	jge	SHORT $LN3@Push_heap_
	npad	2
$LL4@Push_heap_:
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR __Val$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5267 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

	lea	edi, DWORD PTR [esi-1]

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	eax, esp
	sar	edi, 1
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN8@Push_heap_
	inc	DWORD PTR [ecx+4]
$LN8@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN13@Push_heap_
	inc	DWORD PTR [ecx+4]
$LN13@Push_heap_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5268 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN3@Push_heap_

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	lea	ebx, DWORD PTR [esi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [ebp+edi*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5271 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

	add	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN23@Push_heap_
	inc	DWORD PTR [esi+4]
$LN23@Push_heap_:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5272 :         _Hole             = _Idx;

	mov	esi, edi
	cmp	DWORD PTR __Top$[esp+12], edi
	jl	SHORT $LL4@Push_heap_
$LN3@Push_heap_:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR __Val$[esp+12]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5275 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

	lea	edi, DWORD PTR [esi*4]
	add	edi, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN32@Push_heap_
	inc	DWORD PTR [esi+4]
$LN32@Push_heap_:
	mov	ecx, edi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
	mov	DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5276 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Push_heap_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ENDP ; std::_Push_heap_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00$$QAV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Pop_heap_hole_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00$$QAV1@P6A_NV1@2@Z@Z PROC ; std::_Pop_heap_hole_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5404 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ebx, edx
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edi, DWORD PTR [ebp]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	edi, edi
	je	SHORT $LN10@Pop_heap_h
	inc	DWORD PTR [edi+4]
$LN10@Pop_heap_h:
	mov	esi, DWORD PTR __Dest$[esp+12]
	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Glow@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Pred$[esp+12]
	sub	ebx, ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 5410 :     _Pop_heap_hole_by_index(

	push	DWORD PTR __Val$[esp+16]
	sar	ebx, 2
	xor	edx, edx
	push	ebx
	mov	ecx, ebp
	call	??$_Pop_heap_hole_by_index@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@HH$$QAV1@P6A_NV1@2@Z@Z ; std::_Pop_heap_hole_by_index<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5411 :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 5412 : }

	ret	0
??$_Pop_heap_hole_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@V1@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00$$QAV1@P6A_NV1@2@Z@Z ENDP ; std::_Pop_heap_hole_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,resptr_core<IRender_Glow,resptrcode_glow>,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 4
??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z PROC ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 6943 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	ecx
	mov	edi, ecx
	mov	eax, esp
	mov	esi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN8@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN8@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN13@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN13@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6945 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	ebx, DWORD PTR __Pred$[esp+20]
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN55@Med3_unche
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [edi], ecx
$LN55@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN24@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN24@Med3_unche:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ebp, DWORD PTR __Last$[esp+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN29@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN29@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6949 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	DWORD PTR [esi], ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN40@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN40@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN45@Med3_unche
	inc	DWORD PTR [ecx+4]
$LN45@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6952 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN4@Med3_unche
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [edi], ecx
$LN4@Med3_unche:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\algorithm

; 6956 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Med3_unchecked@PAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@P6A_NV1@0@Z@std@@YAXPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@00P6A_NV1@1@Z@Z ENDP ; std::_Med3_unchecked<resptr_core<IRender_Glow,resptrcode_glow> *,bool (__cdecl*)(resptr_core<IRender_Glow,resptrcode_glow>,resptr_core<IRender_Glow,resptrcode_glow>)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??$swap@VIRender_Glow@@Uresptrcode_glow@@@@YAXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z
_TEXT	SEGMENT
??$swap@VIRender_Glow@@Uresptrcode_glow@@@@YAXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z PROC ; swap<IRender_Glow,resptrcode_glow>, COMDAT
; _lhs$ = ecx
; _rhs$ = edx

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	eax, DWORD PTR [edx]

; 100  : template<class T, typename D> void swap	(resptr_core<T,D> & lhs, resptr_core<T,D> & rhs)									{ lhs.swap(rhs);	}

	push	esi

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edx], esi
	pop	esi

; 100  : template<class T, typename D> void swap	(resptr_core<T,D> & lhs, resptr_core<T,D> & rhs)									{ lhs.swap(rhs);	}

	ret	0
??$swap@VIRender_Glow@@Uresptrcode_glow@@@@YAXAAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@0@Z ENDP ; swap<IRender_Glow,resptrcode_glow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV1@@Z PROC ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> * &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@@std@@YAAAPAV?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@AAPAV1@@Z ENDP ; std::forward<resptr_core<IRender_Glow,resptrcode_glow> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?swap@?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEXAAV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?swap@?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEXAAV1@@Z PROC ; resptr_core<IRender_Glow,resptrcode_glow>::swap, COMDAT
; _this$ = ecx

; 79   : 	void				swap			(self & rhs)									{	T * tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}

	mov	edx, DWORD PTR _rhs$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edx], esi
	pop	esi
	ret	4
?swap@?$resptr_core@VIRender_Glow@@Uresptrcode_glow@@@@QAEXAAV1@@Z ENDP ; resptr_core<IRender_Glow,resptrcode_glow>::swap
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECGlow@@W7AEPAXI@Z
_TEXT	SEGMENT
??_ECGlow@@W7AEPAXI@Z PROC				; [thunk]:CGlow::`vector deleting destructor', COMDAT
	sub	ecx, 8
	jmp	??_ECGlow@@UAEPAXI@Z
??_ECGlow@@W7AEPAXI@Z ENDP				; [thunk]:CGlow::`vector deleting destructor'
_TEXT	ENDS
END
