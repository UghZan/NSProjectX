; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\fprogressive.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2FProgressive@@8				; FProgressive::`RTTI Base Class Array'
PUBLIC	??_R2Fvisual@@8					; Fvisual::`RTTI Base Class Array'
PUBLIC	??_R2IRender_Mesh@@8				; IRender_Mesh::`RTTI Base Class Array'
PUBLIC	??_R2IRender_Visual@@8				; IRender_Visual::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FProgressive@@8			; FProgressive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1EE@?0A@EA@IRender_Mesh@@8			; IRender_Mesh::`RTTI Base Class Descriptor at (68,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Fvisual@@8			; Fvisual::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRender_Mesh@@8			; IRender_Mesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@IRender_Visual@@8			; IRender_Visual::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3Fvisual@@8					; Fvisual::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVFvisual@@@8				; Fvisual `RTTI Type Descriptor'
PUBLIC	??_R3IRender_Mesh@@8				; IRender_Mesh::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUIRender_Mesh@@@8			; IRender_Mesh `RTTI Type Descriptor'
PUBLIC	??_R3IRender_Visual@@8				; IRender_Visual::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVIRender_Visual@@@8			; IRender_Visual `RTTI Type Descriptor'
PUBLIC	??_R3FProgressive@@8				; FProgressive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVFProgressive@@@8			; FProgressive `RTTI Type Descriptor'
PUBLIC	??_R4FProgressive@@6BIRender_Mesh@@@		; FProgressive::`RTTI Complete Object Locator'
PUBLIC	??_R4FProgressive@@6BIRender_Visual@@@		; FProgressive::`RTTI Complete Object Locator'
PUBLIC	??_7FProgressive@@6BIRender_Mesh@@@		; FProgressive::`vftable'
PUBLIC	??_7FProgressive@@6BIRender_Visual@@@		; FProgressive::`vftable'
EXTRN	?dcast_ParticleCustom@IRender_Visual@@UAEPAVIParticleCustom@@XZ:PROC ; IRender_Visual::dcast_ParticleCustom
EXTRN	__imp_?dcast_ParticleCustom@IRender_Visual@@UAEPAVIParticleCustom@@XZ:PROC
EXTRN	?dcast_PKinematicsAnimated@IRender_Visual@@UAEPAVCKinematicsAnimated@@XZ:PROC ; IRender_Visual::dcast_PKinematicsAnimated
EXTRN	__imp_?dcast_PKinematicsAnimated@IRender_Visual@@UAEPAVCKinematicsAnimated@@XZ:PROC
EXTRN	?dcast_PKinematics@IRender_Visual@@UAEPAVCKinematics@@XZ:PROC ; IRender_Visual::dcast_PKinematics
EXTRN	__imp_?dcast_PKinematics@IRender_Visual@@UAEPAVCKinematics@@XZ:PROC
EXTRN	?Depart@IRender_Visual@@UAEXXZ:PROC		; IRender_Visual::Depart
EXTRN	__imp_?Depart@IRender_Visual@@UAEXXZ:PROC
EXTRN	?Spawn@IRender_Visual@@UAEXXZ:PROC		; IRender_Visual::Spawn
EXTRN	__imp_?Spawn@IRender_Visual@@UAEXXZ:PROC
EXTRN	__imp_??0FSlideWindowItem@@QAE@XZ:PROC
;	COMDAT ??_7FProgressive@@6BIRender_Visual@@@
CONST	SEGMENT
??_7FProgressive@@6BIRender_Visual@@@ DD FLAT:??_R4FProgressive@@6BIRender_Visual@@@ ; FProgressive::`vftable'
	DD	FLAT:?Render@FProgressive@@UAEXM@Z
	DD	FLAT:?Load@FProgressive@@UAEXPBDPAVIReader@@I@Z
	DD	FLAT:?Release@FProgressive@@UAEXXZ
	DD	FLAT:?Copy@FProgressive@@UAEXPAVIRender_Visual@@@Z
	DD	FLAT:?Spawn@IRender_Visual@@UAEXXZ
	DD	FLAT:?Depart@IRender_Visual@@UAEXXZ
	DD	FLAT:?dcast_PKinematics@IRender_Visual@@UAEPAVCKinematics@@XZ
	DD	FLAT:?dcast_PKinematicsAnimated@IRender_Visual@@UAEPAVCKinematicsAnimated@@XZ
	DD	FLAT:?dcast_ParticleCustom@IRender_Visual@@UAEPAVIParticleCustom@@XZ
	DD	FLAT:??_EFProgressive@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7FProgressive@@6BIRender_Mesh@@@
CONST	SEGMENT
??_7FProgressive@@6BIRender_Mesh@@@ DD FLAT:??_R4FProgressive@@6BIRender_Mesh@@@ ; FProgressive::`vftable'
	DD	FLAT:??_EFProgressive@@WEE@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4FProgressive@@6BIRender_Visual@@@
rdata$r	SEGMENT
??_R4FProgressive@@6BIRender_Visual@@@ DD 00H		; FProgressive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFProgressive@@@8
	DD	FLAT:??_R3FProgressive@@8
rdata$r	ENDS
;	COMDAT ??_R4FProgressive@@6BIRender_Mesh@@@
rdata$r	SEGMENT
??_R4FProgressive@@6BIRender_Mesh@@@ DD 00H		; FProgressive::`RTTI Complete Object Locator'
	DD	044H
	DD	00H
	DD	FLAT:??_R0?AVFProgressive@@@8
	DD	FLAT:??_R3FProgressive@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFProgressive@@@8
data$rs	SEGMENT
??_R0?AVFProgressive@@@8 DD FLAT:??_7type_info@@6B@	; FProgressive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFProgressive@@', 00H
data$rs	ENDS
;	COMDAT ??_R3FProgressive@@8
rdata$r	SEGMENT
??_R3FProgressive@@8 DD 00H				; FProgressive::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2FProgressive@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIRender_Visual@@@8
data$rs	SEGMENT
??_R0?AVIRender_Visual@@@8 DD FLAT:??_7type_info@@6B@	; IRender_Visual `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIRender_Visual@@', 00H
data$rs	ENDS
;	COMDAT ??_R3IRender_Visual@@8
rdata$r	SEGMENT
??_R3IRender_Visual@@8 DD 00H				; IRender_Visual::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_Visual@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIRender_Mesh@@@8
data$rs	SEGMENT
??_R0?AUIRender_Mesh@@@8 DD FLAT:??_7type_info@@6B@	; IRender_Mesh `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIRender_Mesh@@', 00H
data$rs	ENDS
;	COMDAT ??_R3IRender_Mesh@@8
rdata$r	SEGMENT
??_R3IRender_Mesh@@8 DD 00H				; IRender_Mesh::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IRender_Mesh@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFvisual@@@8
data$rs	SEGMENT
??_R0?AVFvisual@@@8 DD FLAT:??_7type_info@@6B@		; Fvisual `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFvisual@@', 00H
data$rs	ENDS
;	COMDAT ??_R3Fvisual@@8
rdata$r	SEGMENT
??_R3Fvisual@@8 DD 00H					; Fvisual::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2Fvisual@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_Visual@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_Visual@@8 DD FLAT:??_R0?AVIRender_Visual@@@8 ; IRender_Visual::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Visual@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IRender_Mesh@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IRender_Mesh@@8 DD FLAT:??_R0?AUIRender_Mesh@@@8 ; IRender_Mesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Mesh@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Fvisual@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Fvisual@@8 DD FLAT:??_R0?AVFvisual@@@8	; Fvisual::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Fvisual@@8
rdata$r	ENDS
;	COMDAT ??_R1EE@?0A@EA@IRender_Mesh@@8
rdata$r	SEGMENT
??_R1EE@?0A@EA@IRender_Mesh@@8 DD FLAT:??_R0?AUIRender_Mesh@@@8 ; IRender_Mesh::`RTTI Base Class Descriptor at (68,-1,0,64)'
	DD	00H
	DD	044H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IRender_Mesh@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FProgressive@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FProgressive@@8 DD FLAT:??_R0?AVFProgressive@@@8 ; FProgressive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FProgressive@@8
rdata$r	ENDS
;	COMDAT ??_R2IRender_Visual@@8
rdata$r	SEGMENT
??_R2IRender_Visual@@8 DD FLAT:??_R1A@?0A@EA@IRender_Visual@@8 ; IRender_Visual::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2IRender_Mesh@@8
rdata$r	SEGMENT
??_R2IRender_Mesh@@8 DD FLAT:??_R1A@?0A@EA@IRender_Mesh@@8 ; IRender_Mesh::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2Fvisual@@8
rdata$r	SEGMENT
??_R2Fvisual@@8 DD FLAT:??_R1A@?0A@EA@Fvisual@@8	; Fvisual::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IRender_Visual@@8
	DD	FLAT:??_R1EE@?0A@EA@IRender_Mesh@@8
rdata$r	ENDS
;	COMDAT ??_R2FProgressive@@8
rdata$r	SEGMENT
??_R2FProgressive@@8 DD FLAT:??_R1A@?0A@EA@FProgressive@@8 ; FProgressive::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Fvisual@@8
	DD	FLAT:??_R1A@?0A@EA@IRender_Visual@@8
	DD	FLAT:??_R1EE@?0A@EA@IRender_Mesh@@8
PUBLIC	??_EFProgressive@@WEE@AEPAXI@Z			; [thunk]:FProgressive::`vector deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@UFSlideWindowItem@@@@QAEXAAPAUFSlideWindowItem@@@Z ; xr_special_free<0,FSlideWindowItem>::operator()
PUBLIC	??R?$xr_special_free@$00VIReader@@@@QAEXAAPAVIReader@@@Z ; xr_special_free<1,IReader>::operator()
PUBLIC	??$xr_delete@VIReader@@@@YAXAAPAVIReader@@@Z	; xr_delete<IReader>
PUBLIC	??$clamp@M@@YAXAAMABM1@Z			; clamp<float>
PUBLIC	??$xr_alloc@UFSlideWindow@@@@YAPAUFSlideWindow@@I@Z ; xr_alloc<FSlideWindow>
PUBLIC	??$xr_delete@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z ; xr_delete<FSlideWindowItem>
PUBLIC	??$xr_free@UFSlideWindow@@@@YAXAAPAUFSlideWindow@@@Z ; xr_free<FSlideWindow>
PUBLIC	??0?$destructor@VIReader@@@@QAE@PAVIReader@@@Z	; destructor<IReader>::destructor<IReader>
PUBLIC	??1?$destructor@VIReader@@@@QAE@XZ		; destructor<IReader>::~destructor<IReader>
PUBLIC	??R?$destructor@VIReader@@@@QAEAAVIReader@@XZ	; destructor<IReader>::operator()
PUBLIC	?Copy@FProgressive@@UAEXPAVIRender_Visual@@@Z	; FProgressive::Copy
PUBLIC	?Render@FProgressive@@UAEXM@Z			; FProgressive::Render
PUBLIC	?Load@FProgressive@@UAEXPBDPAVIReader@@I@Z	; FProgressive::Load
PUBLIC	?Release@FProgressive@@UAEXXZ			; FProgressive::Release
PUBLIC	??1FProgressive@@UAE@XZ				; FProgressive::~FProgressive
PUBLIC	??_GFProgressive@@UAEPAXI@Z			; FProgressive::`scalar deleting destructor'
PUBLIC	??0FProgressive@@QAE@XZ				; FProgressive::FProgressive
EXTRN	??_EFProgressive@@UAEPAXI@Z:PROC		; FProgressive::`vector deleting destructor'
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
??0FProgressive@@QAE@XZ PROC				; FProgressive::FProgressive
; _this$ = ecx

; 16   : {

	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 19   : Fvisual::Fvisual()  : IRender_Visual()

	call	DWORD PTR __imp_??0IRender_Visual@@QAE@XZ

; 20   : {

	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_??0IRender_Mesh@@QAE@XZ

; 21   : 	m_fast	=	0;

	mov	DWORD PTR [edi+104], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 19   : }

	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7FProgressive@@6BIRender_Visual@@@
	mov	DWORD PTR [edi+68], OFFSET ??_7FProgressive@@6BIRender_Mesh@@@
; File I:\Vitalya\mine\NSProjectX\xrEngine\Fmesh.h

; 105  : 	FSlideWindowItem() : sw(0), count(0) {};

	mov	DWORD PTR [edi+108], 0
	mov	DWORD PTR [edi+112], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 17   : 	xSWI			= 0;

	mov	DWORD PTR [edi+132], 0

; 18   : 	last_lod		= 0;

	mov	DWORD PTR [edi+136], 0

; 19   : }

	pop	edi
	pop	esi
	ret	0
??0FProgressive@@QAE@XZ ENDP				; FProgressive::FProgressive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
;	COMDAT ??_GFProgressive@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GFProgressive@@UAEPAXI@Z PROC			; FProgressive::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 22   : {

	push	ebx
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 25   : {

	mov	DWORD PTR [edi], OFFSET ??_7Fvisual@@6BIRender_Visual@@@
	mov	DWORD PTR [edi+68], OFFSET ??_7Fvisual@@6BIRender_Mesh@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	je	SHORT $LN9@scalar

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi+104]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi+104], 0
	pop	esi
$LN9@scalar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 27   : }

	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_??1IRender_Mesh@@UAE@XZ
	mov	ecx, edi
	call	DWORD PTR __imp_??1IRender_Visual@@UAE@XZ
	test	BYTE PTR ___flags$[esp+4], 1
	je	SHORT $LN13@scalar
	push	140					; 0000008cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, edi
	pop	edi
	pop	ebx
	ret	4
??_GFProgressive@@UAEPAXI@Z ENDP			; FProgressive::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
??1FProgressive@@UAE@XZ PROC				; FProgressive::~FProgressive
; _this$ = ecx

; 22   : {

	push	ebx
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 25   : {

	mov	DWORD PTR [edi], OFFSET ??_7Fvisual@@6BIRender_Visual@@@
	mov	DWORD PTR [edi+68], OFFSET ??_7Fvisual@@6BIRender_Mesh@@@
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	je	SHORT $LN6@FProgressi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi+104]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi+104], 0
	pop	esi
$LN6@FProgressi:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 27   : }

	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_??1IRender_Mesh@@UAE@XZ
	mov	ecx, edi
	pop	edi
	pop	ebx
	jmp	DWORD PTR __imp_??1IRender_Visual@@UAE@XZ
??1FProgressive@@UAE@XZ ENDP				; FProgressive::~FProgressive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
?Release@FProgressive@@UAEXXZ PROC			; FProgressive::Release
; _this$ = ecx

; 27   : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FVisual.cpp

; 31   : 	IRender_Visual::Release	();

	call	DWORD PTR __imp_?Release@IRender_Visual@@UAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [esi+108]
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN7@Release
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	DWORD PTR [esi+108], 0
$LN7@Release:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 30   : 	if (xSWI)		{

	mov	edi, DWORD PTR [esi+132]
	test	edi, edi
	je	SHORT $LN13@Release
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN10@Release
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
	mov	DWORD PTR [edi], 0
$LN10@Release:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi+132]
	test	eax, eax
	je	SHORT $LN13@Release

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi+132], 0
$LN13@Release:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 34   : }

	pop	esi
	pop	ebx
	ret	0
?Release@FProgressive@@UAEXXZ ENDP			; FProgressive::Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
_N$ = 8							; size = 4
_data$ = 12						; size = 4
_dwFlags$ = 16						; size = 4
?Load@FProgressive@@UAEXPBDPAVIReader@@I@Z PROC		; FProgressive::Load
; _this$ = ecx

; 37   : {

	push	esi

; 38   : 	Fvisual::Load	(N,data,dwFlags);

	mov	esi, DWORD PTR _data$[esp]
	push	edi
	push	DWORD PTR _dwFlags$[esp+4]
	mov	edi, ecx
	push	esi
	push	DWORD PTR _N$[esp+12]
	call	?Load@Fvisual@@UAEXPBDPAVIReader@@I@Z	; Fvisual::Load

; 39   : 
; 40   : 	// normal SWI
; 41   : 	destructor<IReader> lods (data->open_chunk	(OGF_SWIDATA));

	push	6
	mov	ecx, esi
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h

; 257  : 	destructor(T* p)	{ ptr=p;			}

	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 42   :     nSWI.reserved[0]	= lods().r_u32();	// reserved 16 bytes

	mov	ecx, esi
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 43   :     nSWI.reserved[1]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [edi+116], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 44   :     nSWI.reserved[2]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [edi+120], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 45   :     nSWI.reserved[3]	= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [edi+124], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ

; 46   :     nSWI.count			= lods().r_u32();

	mov	ecx, esi
	mov	DWORD PTR [edi+128], eax
	call	DWORD PTR __imp_?r_u32@?$IReaderBase@VIReader@@@@QAEIXZ
	mov	DWORD PTR [edi+112], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 49   : 	lods().r			(nSWI.sw,nSWI.count*sizeof(FSlideWindow));

	mov	ecx, DWORD PTR [edi+112]
	shl	ecx, 3
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+108], eax
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	esi, esi
	je	SHORT $LN13@Load

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	mov	edi, eax
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN13@Load:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 68   : }

	pop	esi
	ret	12					; 0000000cH
?Load@FProgressive@@UAEXPBDPAVIReader@@I@Z ENDP		; FProgressive::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
_PC$1$ = -4						; size = 4
tv546 = -4						; size = 4
tv487 = -4						; size = 4
__vb$1$ = 8						; size = 4
_countV$1$ = 8						; size = 4
_a$1 = 8						; size = 4
_LOD$ = 8						; size = 4
?Render@FProgressive@@UAEXM@Z PROC			; FProgressive::Render
; _this$ = ecx

; 71   : {

	push	ecx

; 72   : #if RENDER==R_R2
; 73   : 	if (m_fast && RImplementation.phase==CRender::PHASE_SMAP)
; 74   : 	{
; 75   : 		int lod_id			= iFloor((1.f-clampr(LOD,0.f,1.f))*float(xSWI->count-1)+0.5f);
; 76   : 		VERIFY				(lod_id>=0 && lod_id<int(xSWI->count));
; 77   : 		FSlideWindow& SW	= xSWI->sw[lod_id];
; 78   : 		RCache.set_Geometry	(m_fast->rm_geom);
; 79   : 		RCache.Render		(D3DPT_TRIANGLELIST,m_fast->vBase,0,SW.num_verts,m_fast->iBase+SW.offset,SW.num_tris);
; 80   : 		RCache.stat.r.s_static.add	(SW.num_verts);
; 81   : 	} else {
; 82   : 		int lod_id		= last_lod;
; 83   : 		if (LOD>=0.f){
; 84   : 			clamp			(LOD,0.f,1.f);
; 85   : 			lod_id			= iFloor((1.f-LOD)*float(nSWI.count-1)+0.5f);
; 86   : 			last_lod		= lod_id;
; 87   : 		}
; 88   : 		VERIFY				(lod_id>=0 && lod_id<int(nSWI.count));
; 89   : 		FSlideWindow& SW	= nSWI.sw[lod_id];
; 90   : 		RCache.set_Geometry	(rm_geom);
; 91   : 		RCache.Render		(D3DPT_TRIANGLELIST,vBase,0,SW.num_verts,iBase+SW.offset,SW.num_tris);
; 92   : 		RCache.stat.r.s_static.add	(SW.num_verts);
; 93   : 	}
; 94   : #else
; 95   : 	int lod_id		= last_lod;
; 96   : 	if (LOD>=0.f){

	movss	xmm0, DWORD PTR _LOD$[esp]
	comiss	xmm0, DWORD PTR __real@00000000
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+136]
	jb	$LN4@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN10@Render
	mov	DWORD PTR _LOD$[esp+16], 1065353216	; 3f800000H
$LN10@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 98   : 		lod_id		= iFloor((1.f-LOD)*float(nSWI.count-1)+0.5f);

	mov	eax, DWORD PTR [ebx+112]
	sub	eax, 1
	mov	DWORD PTR tv546[esp+20], eax
	fild	DWORD PTR tv546[esp+20]
	jns	SHORT $LN40@Render
	fadd	DWORD PTR __real@4f800000
$LN40@Render:
	fld1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 98   : 		lod_id		= iFloor((1.f-LOD)*float(nSWI.count-1)+0.5f);

	fsub	DWORD PTR _LOD$[esp+16]
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	fstp	DWORD PTR _a$1[esp+16]

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+16]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 99   : 		last_lod	= lod_id;

	mov	DWORD PTR [ebx+136], edi
$LN4@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	ebp, DWORD PTR [ebx+72]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 102  : 	FSlideWindow& SW			= nSWI.sw[lod_id];

	mov	eax, DWORD PTR [ebx+108]

; 103  : 	RCache.set_Geometry			(rm_geom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	DWORD PTR tv487[esp+20], eax
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN23@Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN23@Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	eax, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR __vb$1$[esp+16], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], eax
	jne	SHORT $LN27@Render
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN26@Render
$LN27@Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	DWORD PTR __vb$1$[esp+24]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN26@Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ebp+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN30@Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN30@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 104  : 	RCache.Render				(D3DPT_TRIANGLELIST,vBase,0,SW.num_verts,iBase+SW.offset,SW.num_tris);

	mov	ebp, DWORD PTR tv487[esp+20]
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	esi, DWORD PTR [ebx+92]
	mov	ebx, DWORD PTR [ebx+80]
	movzx	ecx, WORD PTR [ebp+edi*8+4]
	add	esi, DWORD PTR [ebp+edi*8]
	movzx	edx, WORD PTR [ebp+edi*8+6]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 201  : 	stat.polys += PC;

	add	DWORD PTR [eax+9016], ecx
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9020], edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [eax+4720], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 104  : 	RCache.Render				(D3DPT_TRIANGLELIST,vBase,0,SW.num_verts,iBase+SW.offset,SW.num_tris);

	mov	DWORD PTR _PC$1$[esp+20], ecx
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 104  : 	RCache.Render				(D3DPT_TRIANGLELIST,vBase,0,SW.num_verts,iBase+SW.offset,SW.num_tris);

	mov	DWORD PTR _countV$1$[esp+16], edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	jne	SHORT $LN36@Render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN35@Render
$LN36@Render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
	mov	edx, DWORD PTR _countV$1$[esp+16]
$LN35@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	push	DWORD PTR _PC$1$[esp+20]
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	esi
	push	edx
	push	0
	mov	eax, DWORD PTR [eax+8]
	push	ebx
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+328]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 105  : 	RCache.stat.r.s_static.add	(SW.num_verts);

	movzx	eax, WORD PTR [ebp+edi*8+6]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 27   : 	ICF		void	add(u32 _verts) { verts += _verts; dips++; }

	pop	edi
	pop	esi
	pop	ebp
	add	DWORD PTR [ecx+9048], eax
	inc	DWORD PTR [ecx+9052]
	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp

; 107  : }

	pop	ecx
	ret	4
?Render@FProgressive@@UAEXM@Z ENDP			; FProgressive::Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\FProgressive.cpp
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
?Copy@FProgressive@@UAEXPAVIRender_Visual@@@Z PROC	; FProgressive::Copy
; _this$ = ecx

; 111  : {

	push	esi

; 112  : 	Fvisual::Copy	(pSrc);

	mov	esi, DWORD PTR _pSrc$[esp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?Copy@Fvisual@@UAEXPAVIRender_Visual@@@Z ; Fvisual::Copy

; 113  : 	FProgressive	*pFrom = (FProgressive *)pSrc;
; 114  : 	PCOPY			(nSWI);

	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [edi+108], eax
	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [edi+112], eax
	mov	eax, DWORD PTR [esi+116]
	mov	DWORD PTR [edi+116], eax
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [edi+120], eax
	mov	eax, DWORD PTR [esi+124]
	mov	DWORD PTR [edi+124], eax
	mov	eax, DWORD PTR [esi+128]
	mov	DWORD PTR [edi+128], eax

; 115  : 	PCOPY			(xSWI);

	mov	eax, DWORD PTR [esi+132]
	mov	DWORD PTR [edi+132], eax
	pop	edi
	pop	esi

; 116  : }

	ret	4
?Copy@FProgressive@@UAEXPAVIRender_Visual@@@Z ENDP	; FProgressive::Copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
;	COMDAT ??R?$destructor@VIReader@@@@QAEAAVIReader@@XZ
_TEXT	SEGMENT
??R?$destructor@VIReader@@@@QAEAAVIReader@@XZ PROC	; destructor<IReader>::operator(), COMDAT
; _this$ = ecx

; 260  : 	{	return *ptr; }

	mov	eax, DWORD PTR [ecx]
	ret	0
??R?$destructor@VIReader@@@@QAEAAVIReader@@XZ ENDP	; destructor<IReader>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
;	COMDAT ??1?$destructor@VIReader@@@@QAE@XZ
_TEXT	SEGMENT
??1?$destructor@VIReader@@@@QAE@XZ PROC			; destructor<IReader>::~destructor<IReader>, COMDAT
; _this$ = ecx

; 258  : 	~destructor()		{ xr_delete(ptr);	}

	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@destructor

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN4@destructor:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h

; 258  : 	~destructor()		{ xr_delete(ptr);	}

	ret	0
??1?$destructor@VIReader@@@@QAE@XZ ENDP			; destructor<IReader>::~destructor<IReader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrCore.h
;	COMDAT ??0?$destructor@VIReader@@@@QAE@PAVIReader@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0?$destructor@VIReader@@@@QAE@PAVIReader@@@Z PROC	; destructor<IReader>::destructor<IReader>, COMDAT
; _this$ = ecx

; 257  : 	destructor(T* p)	{ ptr=p;			}

	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0?$destructor@VIReader@@@@QAE@PAVIReader@@@Z ENDP	; destructor<IReader>::destructor<IReader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@UFSlideWindow@@@@YAXAAPAUFSlideWindow@@@Z
_TEXT	SEGMENT
??$xr_free@UFSlideWindow@@@@YAXAAPAUFSlideWindow@@@Z PROC ; xr_free<FSlideWindow>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@UFSlideWindow@@@@YAXAAPAUFSlideWindow@@@Z ENDP ; xr_free<FSlideWindow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
??$xr_delete@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z PROC ; xr_delete<FSlideWindowItem>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@UFSlideWindowItem@@@@YAXAAPAUFSlideWindowItem@@@Z ENDP ; xr_delete<FSlideWindowItem>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@UFSlideWindow@@@@YAPAUFSlideWindow@@I@Z
_TEXT	SEGMENT
??$xr_alloc@UFSlideWindow@@@@YAPAUFSlideWindow@@I@Z PROC ; xr_alloc<FSlideWindow>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@UFSlideWindow@@@@YAPAUFSlideWindow@@I@Z ENDP ; xr_alloc<FSlideWindow>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
;	COMDAT ??$clamp@M@@YAXAAMABM1@Z
_TEXT	SEGMENT
__high$ = 8						; size = 4
??$clamp@M@@YAXAAMABM1@Z PROC				; clamp<float>, COMDAT
; _val$ = ecx
; __low$ = edx

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	movss	xmm1, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, xmm1
	ja	SHORT $LN6@clamp
	mov	eax, DWORD PTR __high$[esp-4]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@clamp
$LN6@clamp:

; 93   : };

	movss	DWORD PTR [ecx], xmm0
$LN4@clamp:
	ret	0
??$clamp@M@@YAXAAMABM1@Z ENDP				; clamp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VIReader@@@@YAXAAPAVIReader@@@Z
_TEXT	SEGMENT
??$xr_delete@VIReader@@@@YAXAAPAVIReader@@@Z PROC	; xr_delete<IReader>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN2@xr_delete

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	push	esi
	push	eax
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	ret	0
??$xr_delete@VIReader@@@@YAXAAPAVIReader@@@Z ENDP	; xr_delete<IReader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VIReader@@@@QAEXAAPAVIReader@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$00VIReader@@@@QAEXAAPAVIReader@@@Z PROC ; xr_special_free<1,IReader>::operator(), COMDAT
; _this$dead$ = ecx

; 131  : 	{

	push	esi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	esi, DWORD PTR _ptr$[esp]
	push	edi
	push	DWORD PTR [esi]
	call	___RTCastToVoid

; 133  : 		ptr->~T			();

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	mov	edi, eax
	mov	edx, DWORD PTR [ecx]
	push	0
	call	DWORD PTR [edx]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	edi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	edi
	pop	esi

; 135  : 	}

	ret	4
??R?$xr_special_free@$00VIReader@@@@QAEXAAPAVIReader@@@Z ENDP ; xr_special_free<1,IReader>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@UFSlideWindowItem@@@@QAEXAAPAUFSlideWindowItem@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@UFSlideWindowItem@@@@QAEXAAPAUFSlideWindowItem@@@Z PROC ; xr_special_free<0,FSlideWindowItem>::operator(), COMDAT
; _this$dead$ = ecx

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	mov	eax, DWORD PTR _ptr$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	DWORD PTR [eax]
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@UFSlideWindowItem@@@@QAEXAAPAUFSlideWindowItem@@@Z ENDP ; xr_special_free<0,FSlideWindowItem>::operator()
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_EFProgressive@@WEE@AEPAXI@Z
_TEXT	SEGMENT
??_EFProgressive@@WEE@AEPAXI@Z PROC			; [thunk]:FProgressive::`vector deleting destructor', COMDAT
	sub	ecx, 68					; 00000044H
	jmp	??_EFProgressive@@UAEPAXI@Z
??_EFProgressive@@WEE@AEPAXI@Z ENDP			; [thunk]:FProgressive::`vector deleting destructor'
_TEXT	ENDS
END
