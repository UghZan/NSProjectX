; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\light_db.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@BFLLHKPD@CLight_DB?3?3Load@		; `string'
PUBLIC	??_C@_0DI@OFNFGKEK@I?3?2Vitalya?2mine?2NSProjectX?2laye@ ; `string'
PUBLIC	??_C@_0O@HGHOCBFM@Where?5is?5sun?$DP@		; `string'
PUBLIC	??_C@_0BM@NFIHHAPA@sun_original?5?$CG?$CG?5sun_adapted@ ; `string'
EXTRN	__imp_?_set@?$resptr_base@VIRender_Light@@@@QAEXABV1@@Z:PROC
EXTRN	__imp_?_inc@?$resptr_base@VIRender_Light@@@@IAEXXZ:PROC
EXTRN	__imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ:PROC
EXTRN	__imp_?_set@?$resptr_base@VIRender_Light@@@@QAEXPAVIRender_Light@@@Z:PROC
EXTRN	__imp_?destroy@resptrcode_light@@QAEXXZ:PROC
EXTRN	__imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z:PROC
EXTRN	__imp_?length@IReader@@QBEHXZ:PROC
;	COMDAT ?ignore_always@?O@??Load@CLight_DB@@QAEXPAVIReader@@@Z@4_NA
_BSS	SEGMENT
?ignore_always@?O@??Load@CLight_DB@@QAEXPAVIReader@@@Z@4_NA DB 01H DUP (?) ; `CLight_DB::Load'::`14'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BM@NFIHHAPA@sun_original?5?$CG?$CG?5sun_adapted@
CONST	SEGMENT
??_C@_0BM@NFIHHAPA@sun_original?5?$CG?$CG?5sun_adapted@ DB 'sun_original '
	DB	'&& sun_adapted', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HGHOCBFM@Where?5is?5sun?$DP@
CONST	SEGMENT
??_C@_0O@HGHOCBFM@Where?5is?5sun?$DP@ DB 'Where is sun?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OFNFGKEK@I?3?2Vitalya?2mine?2NSProjectX?2laye@
CONST	SEGMENT
??_C@_0DI@OFNFGKEK@I?3?2Vitalya?2mine?2NSProjectX?2laye@ DB 'I:\Vitalya\m'
	DB	'ine\NSProjectX\layers\xrRender\Light_DB.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BFLLHKPD@CLight_DB?3?3Load@
CONST	SEGMENT
??_C@_0BA@BFLLHKPD@CLight_DB?3?3Load@ DB 'CLight_DB::Load', 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??$_Destroy_in_place@PAPAVlight@@@std@@YAXAAPAPAVlight@@@Z ; std::_Destroy_in_place<light * *>
PUBLIC	??$_Destroy_in_place@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::_Destroy_in_place<resptr_core<IRender_Light,resptrcode_light> *>
PUBLIC	??$_Emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV3@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> &>
PUBLIC	??$forward@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ; std::forward<resptr_core<IRender_Light,resptrcode_light> &>
PUBLIC	?destroy@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@@Z ; xalloc<light *>::destroy
PUBLIC	?destroy@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::destroy
PUBLIC	??$_Uninitialized_move@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ; std::_Uninitialized_move<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??$_Emplace_back@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> &>
PUBLIC	??$destroy@PAVlight@@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@@Z ; std::_Normal_allocator_traits<xalloc<light *> >::destroy<light *>
PUBLIC	??$_Unfancy@PAVlight@@@std@@YAPAPAVlight@@PAPAV1@@Z ; std::_Unfancy<light *>
PUBLIC	??$destroy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::destroy<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@ABV0@@Z ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
PUBLIC	??0?$xalloc@PAVlight@@@@QAE@XZ			; xalloc<light *>::xalloc<light *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<light *> >::_Vector_val<std::_Simple_types<light *> >
PUBLIC	??0?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAE@XZ ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::xalloc<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	?construct@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@ABV2@@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::construct
PUBLIC	?_Umove@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV3@00@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove
PUBLIC	?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEII@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@XZ ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Release
PUBLIC	??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::_Get_unwrapped<resptr_core<IRender_Light,resptrcode_light> * const &>
PUBLIC	??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ; std::_Uninitialized_copy<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??$xr_free@PAVlight@@@@YAXAAPAPAVlight@@@Z	; xr_free<light *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAVlight@@@@@std@@YAXPAPAVlight@@QAPAV1@AAV?$xalloc@PAVlight@@@@@Z ; std::_Destroy_range<xalloc<light *> >
PUBLIC	??$xr_alloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ; xr_alloc<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$xr_free@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; xr_free<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ; std::_Destroy_range<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1><>
PUBLIC	??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$_Unfancy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV1@@Z ; std::_Unfancy<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$forward@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ; std::forward<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$move@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ; std::move<resptr_core<IRender_Light,resptrcode_light> &>
PUBLIC	??$xr_new@Vlight@@@@YAPAVlight@@XZ		; xr_new<light>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVlight@@@@XZ ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEIXZ ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00U?$integral_constant@_N$0A@@2@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first
PUBLIC	?deallocate@?$xalloc@PAVlight@@@@QBEXPAPAVlight@@I@Z ; xalloc<light *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@0@Z ; std::vector<light *,xalloc<light *> >::_Destroy
PUBLIC	?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEAAV?$xalloc@PAVlight@@@@XZ ; std::vector<light *,xalloc<light *> >::_Getal
PUBLIC	?allocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@IPBX@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::allocate
PUBLIC	?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size
PUBLIC	?clear@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Destroy
PUBLIC	?_Change_array@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@II@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Change_array
PUBLIC	?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first
PUBLIC	??0?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ; std::vector<light *,xalloc<light *> >::vector<light *,xalloc<light *> >
PUBLIC	?_Tidy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXXZ ; std::vector<light *,xalloc<light *> >::_Tidy
PUBLIC	??0?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size
PUBLIC	?capacity@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::capacity
PUBLIC	?_Tidy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear_and_free
PUBLIC	?test@?$_flags@I@@QBEHI@Z			; _flags<unsigned int>::test
PUBLIC	??1?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ; std::vector<light *,xalloc<light *> >::~vector<light *,xalloc<light *> >
PUBLIC	??0?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ ; xr_vector<light *,xalloc<light *> >::xr_vector<light *,xalloc<light *> >
PUBLIC	??1?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	??$emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::emplace_back<resptr_core<IRender_Light,resptrcode_light> >
PUBLIC	?push_back@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::push_back
PUBLIC	?reserve@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXI@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::reserve
PUBLIC	??0?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	?clear@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear
PUBLIC	??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
PUBLIC	??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@PAVIRender_Light@@_N@Z ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
PUBLIC	??1?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ ; resptr_core<IRender_Light,resptrcode_light>::~resptr_core<IRender_Light,resptrcode_light>
PUBLIC	??4?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAEAAV0@ABV0@@Z ; resptr_core<IRender_Light,resptrcode_light>::operator=
PUBLIC	??C?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEPAVIRender_Light@@XZ ; resptr_core<IRender_Light,resptrcode_light>::operator->
PUBLIC	??B?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEP80@BEPAVIRender_Light@@XZXZ ; resptr_core<IRender_Light,resptrcode_light>::operator IRender_Light * (__thiscall resptr_core<IRender_Light,resptrcode_light>::*)(void)const 
PUBLIC	?Update@CLight_DB@@QAEXXZ			; CLight_DB::Update
PUBLIC	?add_light@CLight_DB@@QAEXPAVlight@@@Z		; CLight_DB::add_light
PUBLIC	?Create@CLight_DB@@QAEPAVlight@@XZ		; CLight_DB::Create
PUBLIC	?Unload@CLight_DB@@QAEXXZ			; CLight_DB::Unload
PUBLIC	?Load@CLight_DB@@QAEXPAVIReader@@@Z		; CLight_DB::Load
PUBLIC	??1CLight_DB@@QAE@XZ				; CLight_DB::~CLight_DB
PUBLIC	??1?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ ; xr_vector<light *,xalloc<light *> >::~xr_vector<light *,xalloc<light *> >
PUBLIC	??1light_Package@@QAE@XZ			; light_Package::~light_Package
PUBLIC	??0light_Package@@QAE@XZ			; light_Package::light_Package
PUBLIC	??1?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
PUBLIC	??0CLight_DB@@QAE@XZ				; CLight_DB::CLight_DB
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z$2
__catchsym$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
??0CLight_DB@@QAE@XZ PROC				; CLight_DB::CLight_DB
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 10   : }

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 10   : }

	ret	0
??0CLight_DB@@QAE@XZ ENDP				; CLight_DB::CLight_DB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0light_Package@@QAE@XZ
_TEXT	SEGMENT
??0light_Package@@QAE@XZ PROC				; light_Package::light_Package, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	ret	0
??0light_Package@@QAE@XZ ENDP				; light_Package::light_Package
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1light_Package@@QAE@XZ
_TEXT	SEGMENT
??1light_Package@@QAE@XZ PROC				; light_Package::~light_Package, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN8@light_Pack
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+24], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+28], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+32], 0
$LN8@light_Pack:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN20@light_Pack
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN20@light_Pack:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN32@light_Pack
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN32@light_Pack:
	pop	edi
	pop	esi
	ret	0
??1light_Package@@QAE@XZ ENDP				; light_Package::~light_Package
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ PROC ; xr_vector<light *,xalloc<light *> >::~xr_vector<light *,xalloc<light *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ ENDP ; xr_vector<light *,xalloc<light *> >::~xr_vector<light *,xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
??1CLight_DB@@QAE@XZ PROC				; CLight_DB::~CLight_DB
; _this$ = ecx

; 13   : {

	push	esi
	mov	esi, ecx

; 14   : }

	lea	ecx, DWORD PTR [esi+20]
	call	??1light_Package@@QAE@XZ
	lea	ecx, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	lea	ecx, DWORD PTR [esi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN12@CLight_DB
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN12@CLight_DB:
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 14   : }

	ret	0
??1CLight_DB@@QAE@XZ ENDP				; CLight_DB::~CLight_DB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
$T1 = -168						; size = 4
$T2 = -168						; size = 4
_count$1$ = -164					; size = 4
$T3 = -164						; size = 4
$T4 = -164						; size = 4
_F$1$ = -160						; size = 4
$T5 = -156						; size = 4
_controller$6 = -152					; size = 4
_this$1$ = -148						; size = 4
_this$1$ = -144						; size = 4
_tmp_R$7 = -140						; size = 12
_tmp_R$8 = -128						; size = 12
_tmp_D$9 = -116						; size = 12
_Ldata$10 = -104					; size = 104
_fs$ = 8						; size = 4
?Load@CLight_DB@@QAEXPAVIReader@@@Z PROC		; CLight_DB::Load
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T4[esp+184], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 21   : 	sun_original		= NULL;

	lea	ebx, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 21   : 	sun_original		= NULL;

	mov	DWORD PTR _this$1$[esp+184], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T4[esp+184]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [ebx], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 22   : 	sun_adapted			= NULL;

	lea	esi, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	DWORD PTR $T3[esp+184], 0

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 22   : 	sun_adapted			= NULL;

	mov	DWORD PTR _this$1$[esp+184], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T3[esp+184]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi], 0

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 24   : 		F				= fs->open_chunk		(fsL_LIGHT_DYNAMIC);

	mov	ecx, DWORD PTR _fs$[ebp]
	push	6
	call	DWORD PTR __imp_?open_chunk@IReader@@QAEPAV1@I@Z
	mov	DWORD PTR _F$1$[esp+184], eax

; 28   : 		u32 count		= size/element;

	mov	ebx, DWORD PTR [eax+12]
	mov	eax, 795364315				; 2f684bdbH
	mul	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 28   : 		u32 count		= size/element;

	sub	ebx, edx
	shr	ebx, 1
	add	ebx, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 28   : 		u32 count		= size/element;

	shr	ebx, 6
	mov	DWORD PTR _count$1$[esp+184], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	ebx, eax
	jbe	SHORT $LN53@Load

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	ebx, 1073741823				; 3fffffffH
	ja	$LN133@Load

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ebx
	mov	ecx, edi
	call	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Reallocate_exactly
$LN53@Load:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 31   : 		for (u32 i=0; i<count; i++) 

	test	ebx, ebx
	je	$LN6@Load
	npad	3
$LL7@Load:

; 32   : 		{
; 33   : 			Flight		Ldata;
; 34   : 			light*		L				= Create	();

	call	?Create@CLight_DB@@QAEPAVlight@@XZ	; CLight_DB::Create
	mov	esi, eax

; 35   : 			L->flags.bStatic			= true;
; 36   : 			L->set_type					(IRender_Light::POINT);

	push	1
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	or	DWORD PTR [esi+60], 16			; 00000010H
	call	DWORD PTR [edx]

; 37   : 
; 38   : #if RENDER==R_R1
; 39   : 			L->set_shadow				(false);

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [edx+12]

; 40   : #else
; 41   : 			L->set_shadow				(true);
; 42   : #endif
; 43   : 			u32 controller				= 0;
; 44   : 			F->r						(&controller,4);

	mov	ecx, DWORD PTR _F$1$[esp+184]
	lea	eax, DWORD PTR _controller$6[esp+184]
	push	4
	push	eax
	mov	DWORD PTR _controller$6[esp+192], 0
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z

; 45   : 			F->r						(&Ldata,sizeof(Flight));

	mov	ecx, DWORD PTR _F$1$[esp+184]
	lea	eax, DWORD PTR _Ldata$10[esp+184]
	push	104					; 00000068H
	push	eax
	call	DWORD PTR __imp_?r@IReader@@QAEXPAXH@Z

; 46   : 			if (Ldata.type==D3DLIGHT_DIRECTIONAL)	{

	cmp	DWORD PTR _Ldata$10[esp+184], 3
	mov	DWORD PTR $T2[esp+184], esi
	jne	$LN11@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _tmp_R$7[esp+184], 1065353216	; 3f800000H
	mov	DWORD PTR _tmp_R$7[esp+188], 0
	mov	DWORD PTR _tmp_R$7[esp+192], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	inc	DWORD PTR [esi+4]

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	ebx, DWORD PTR $T2[esp+184]
	test	ebx, ebx

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN74@Load
	inc	DWORD PTR [ebx+4]
$LN74@Load:
	lea	ecx, DWORD PTR [edi+12]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T2[esp+184]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+12], ebx

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 51   : 				L->set_type			(IRender_Light::DIRECT);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax]

; 52   : 				L->set_shadow		(true);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	1
	call	DWORD PTR [eax+12]

; 53   : 				L->set_rotation		(Ldata.direction,tmp_R);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _tmp_R$7[esp+184]
	push	ecx
	lea	ecx, DWORD PTR _Ldata$10[esp+252]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+24]

; 54   : 				
; 55   : 				// copy to env-sun
; 56   : 				sun_adapted			=	L		= Create();

	call	?Create@CLight_DB@@QAEPAVlight@@XZ	; CLight_DB::Create
	mov	esi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	ebx, esi
	mov	DWORD PTR $T5[esp+184], ebx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	esi, esi
	je	SHORT $LN81@Load
	inc	DWORD PTR [esi+4]
	mov	ebx, DWORD PTR $T5[esp+184]
$LN81@Load:

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	ebx, ebx

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN91@Load
	inc	DWORD PTR [ebx+4]
$LN91@Load:
	lea	ecx, DWORD PTR [edi+16]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T5[esp+184]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [edi+16], ebx

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 58   : 				L->set_type			(IRender_Light::DIRECT);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	or	DWORD PTR [esi+60], 16			; 00000010H
	push	0
	call	DWORD PTR [eax]

; 59   : 				L->set_shadow		(true);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	1
	call	DWORD PTR [eax+12]

; 60   : 				L->set_rotation		(Ldata.direction,tmp_R);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _tmp_R$7[esp+184]
	push	ecx
	lea	ecx, DWORD PTR _Ldata$10[esp+252]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+24]

; 61   : 			}

	mov	ebx, DWORD PTR _count$1$[esp+184]
	jmp	$LN5@Load
$LN11@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _tmp_D$9[esp+184], 0
	mov	DWORD PTR _tmp_D$9[esp+188], 0
	mov	DWORD PTR _tmp_D$9[esp+192], -1082130432 ; bf800000H
	mov	DWORD PTR _tmp_R$8[esp+184], 1065353216	; 3f800000H
	mov	DWORD PTR _tmp_R$8[esp+188], 0
	mov	DWORD PTR _tmp_R$8[esp+192], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	inc	DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $LN108@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR $T1[esp+184]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR $T1[esp+184]
	test	eax, eax
	je	SHORT $LN118@Load
	inc	DWORD PTR [eax+4]
$LN118@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN107@Load
$LN108@Load:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[esp+184]
	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >
$LN107@Load:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+184]
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 70   : 				L->set_position		(Ldata.position		);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _Ldata$10[esp+236]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+20]

; 71   : 				L->set_rotation		(tmp_D, tmp_R		);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _tmp_R$8[esp+184]
	push	ecx
	lea	ecx, DWORD PTR _tmp_D$9[esp+188]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+24]

; 72   : 				L->set_range		(Ldata.range		);

	mov	eax, DWORD PTR [esi]
	fld	DWORD PTR _Ldata$10[esp+260]
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	DWORD PTR [eax+32]

; 73   : 				L->set_color		(Ldata.diffuse		);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _Ldata$10[esp+188]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+48]

; 74   : 				L->set_active		(true				);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	1
	call	DWORD PTR [eax+4]
$LN5@Load:

; 31   : 		for (u32 i=0; i<count; i++) 

	sub	ebx, 1
	mov	DWORD PTR _count$1$[esp+184], ebx
	jne	$LL7@Load
	mov	esi, DWORD PTR _this$1$[esp+184]
$LN6@Load:

; 75   : //				R_ASSERT			(L->spatial.sector	);
; 76   : 			}
; 77   : 		}
; 78   : 
; 79   : 		F->close			();

	mov	ecx, DWORD PTR _F$1$[esp+184]
	call	DWORD PTR __imp_?close@IReader@@QAEXXZ

; 81   : 	R_ASSERT2(sun_original && sun_adapted,"Where is sun?");

	cmp	BYTE PTR ?ignore_always@?O@??Load@CLight_DB@@QAEXPAVIReader@@@Z@4_NA, 0
	jne	SHORT $LN9@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	mov	ecx, DWORD PTR _this$1$[esp+184]
	xor	edx, edx
	mov	eax, DWORD PTR __imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ
	cmp	DWORD PTR [ecx], edx
	cmove	eax, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 81   : 	R_ASSERT2(sun_original && sun_adapted,"Where is sun?");

	test	eax, eax
	je	SHORT $LN14@Load
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	mov	eax, DWORD PTR __imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ
	xor	ecx, ecx
	cmp	DWORD PTR [esi], ecx
	cmove	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 81   : 	R_ASSERT2(sun_original && sun_adapted,"Where is sun?");

	test	eax, eax
	jne	SHORT $LN9@Load
$LN14@Load:
	mov	ecx, DWORD PTR __imp_?Debug@@3VxrDebug@@A
	push	OFFSET ?ignore_always@?O@??Load@CLight_DB@@QAEXPAVIReader@@@Z@4_NA
	push	OFFSET ??_C@_0BA@BFLLHKPD@CLight_DB?3?3Load@
	push	81					; 00000051H
	push	OFFSET ??_C@_0DI@OFNFGKEK@I?3?2Vitalya?2mine?2NSProjectX?2laye@
	push	OFFSET ??_C@_0O@HGHOCBFM@Where?5is?5sun?$DP@
	push	OFFSET ??_C@_0BM@NFIHHAPA@sun_original?5?$CG?$CG?5sun_adapted@
	call	DWORD PTR __imp_?fail@xrDebug@@QAEXPBD00H0AA_N@Z
$LN9@Load:

; 99   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN133@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength
$LN131@Load:
	int	3
?Load@CLight_DB@@QAEXPAVIReader@@@Z ENDP		; CLight_DB::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
?Unload@CLight_DB@@QAEXXZ PROC				; CLight_DB::Unload
; _this$ = ecx

; 102  : {

	push	esi
	push	edi
	mov	edi, ecx

; 103  : 	v_static.clear			();

	mov	eax, DWORD PTR [edi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [edi+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 103  : 	v_static.clear			();

	mov	DWORD PTR [edi+4], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], 0
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
	mov	DWORD PTR [edi+16], 0
	pop	edi
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 106  : }

	ret	0
?Unload@CLight_DB@@QAEXXZ ENDP				; CLight_DB::Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
?Create@CLight_DB@@QAEPAVlight@@XZ PROC			; CLight_DB::Create
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 109  : {

	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	push	184					; 000000b8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 11   : 	xr_resource()			: dwReference(0)				{ }

	mov	DWORD PTR [edi+4], 0
	mov	ecx, DWORD PTR __imp_??_7IRender_Light@@6B@
	mov	DWORD PTR [edi], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 4    : light::light		(void)	: ISpatial(g_SpatialSpace)

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edi+8]
	call	DWORD PTR __imp_??0ISpatial@@QAE@PAVISpatial_DB@@@Z

; 7    : 	flags.type		= POINT;

	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [edi], OFFSET ??_7light@@6BIRender_Light@@@
	and	eax, -63				; ffffffc1H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 113  : 	L->flags.bShadow	= true;

	or	eax, 65					; 00000041H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 5    : {

	mov	DWORD PTR [edi+8], OFFSET ??_7light@@6BISpatial@@@
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 113  : 	L->flags.bShadow	= true;

	mov	DWORD PTR [edi+60], eax

; 114  : 	return				L;

	mov	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 6    : 	spatial.type	= STYPE_LIGHTSOURCE;

	mov	DWORD PTR [edi+12], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+64], 0
	mov	DWORD PTR [edi+68], -998637568		; c47a0000H
	mov	DWORD PTR [edi+72], 0
	mov	DWORD PTR [edi+76], 0
	mov	DWORD PTR [edi+80], -1082130432		; bf800000H
	mov	DWORD PTR [edi+84], 0
	mov	DWORD PTR [edi+88], 0
	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 14   : 	range			= 8.f;

	mov	DWORD PTR [edi+100], 1090519040		; 41000000H

; 15   : 	cone			= deg2rad(60.f);

	mov	DWORD PTR [edi+104], 1065749138		; 3f860a92H
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	mov	DWORD PTR [edi+108], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+112], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+120], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 18   : 	frame_render	= 0;

	mov	DWORD PTR [edi+180], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 114  : 	return				L;

	pop	edi
	pop	esi

; 115  : }

	ret	0
?Create@CLight_DB@@QAEPAVlight@@XZ ENDP			; CLight_DB::Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
_L$ = 8							; size = 4
_L$ = 8							; size = 4
?add_light@CLight_DB@@QAEXPAVlight@@@Z PROC		; CLight_DB::add_light
; _this$dead$ = ecx

; 120  : 	if (Device.dwFrame==L->frame_render)	return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	ecx, DWORD PTR _L$[esp-4]
	mov	eax, DWORD PTR [eax+244]
	cmp	eax, DWORD PTR [ecx+180]
	je	SHORT $LN10@add_light

; 121  : 	L->frame_render							=	Device.dwFrame;

	mov	DWORD PTR [ecx+180], eax

; 122  : 	if (L->flags.bStatic)					return;	// skip static lighting, 'cause they are in lmaps

	mov	eax, DWORD PTR [ecx+60]
	test	al, 16					; 00000010H
	jne	SHORT $LN10@add_light
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	test	BYTE PTR ?ps_r1_flags@@3U?$_flags@I@@A, 1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 123  : 	if (ps_r1_flags.test(R1FLAG_DLIGHTS))	RImplementation.L_Dynamic->add	(L);

	je	SHORT $LN10@add_light
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 308  : 	if (L->range<0.1f)				return;

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR [ecx+100]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 123  : 	if (ps_r1_flags.test(R1FLAG_DLIGHTS))	RImplementation.L_Dynamic->add	(L);

	mov	edx, DWORD PTR ?RImplementation@@3VCRender@@A+984
	mov	DWORD PTR _L$[esp-4], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRenderPC_R1\LightPPA.cpp

; 308  : 	if (L->range<0.1f)				return;

	ja	SHORT $LN10@add_light

; 309  : 	if (0==L->spatial.sector)		return;

	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN10@add_light

; 310  : 	if (IRender_Light::POINT==L->flags.type)

	and	eax, 15					; 0000000fH
	cmp	al, 1

; 311  : 	{
; 312  : 		// PPA
; 313  : 		selected_point.push_back	(L);

	lea	eax, DWORD PTR [edx+28]
	je	SHORT $LN33@add_light

; 314  : 	} else {
; 315  : 		// spot/flash
; 316  : 		selected_spot.push_back		(L);

	lea	eax, DWORD PTR [edx+40]
$LN33@add_light:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 124  : }

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN27@add_light
	mov	DWORD PTR [edx], ecx
	add	DWORD PTR [eax+4], 4
	ret	4
$LN27@add_light:
	lea	ecx, DWORD PTR _L$[esp-4]
	push	ecx
	push	edx
	mov	ecx, eax
	call	??$_Emplace_reallocate@ABQAVlight@@@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAEPAPAVlight@@QAPAV2@ABQAV2@@Z ; std::vector<light *,xalloc<light *> >::_Emplace_reallocate<light * const &>
$LN10@add_light:
	ret	4
?add_light@CLight_DB@@QAEXPAVlight@@@Z ENDP		; CLight_DB::add_light
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_Package.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp
_TEXT	SEGMENT
tv573 = -60						; size = 4
tv231 = -60						; size = 4
tv563 = -56						; size = 4
tv223 = -56						; size = 4
tv568 = -52						; size = 4
tv213 = -52						; size = 4
_AD$1 = -48						; size = 12
_OD$2 = -36						; size = 12
_OP$3 = -24						; size = 12
_AP$4 = -12						; size = 12
?Update@CLight_DB@@QAEXXZ PROC				; CLight_DB::Update
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	mov	eax, DWORD PTR __imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 139  : {

	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	xor	ecx, ecx
	mov	ebx, DWORD PTR [esi+12]
	test	ebx, ebx
	cmove	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 141  : 	if (sun_original && sun_adapted)

	test	eax, eax
	je	$LN10@Update
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	mov	eax, DWORD PTR __imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ
	push	ebp
	mov	ebp, DWORD PTR [esi+16]
	test	ebp, ebp
	cmove	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 141  : 	if (sun_original && sun_adapted)

	test	eax, eax
	je	$LN67@Update

; 145  : 		CEnvDescriptor*	E			= g_pGamePersistent->Environment().CurrentEnv;

	mov	eax, DWORD PTR __imp_?g_pGamePersistent@@3PAVIGame_Persistent@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	xmm6, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 145  : 		CEnvDescriptor*	E			= g_pGamePersistent->Environment().CurrentEnv;

	push	edi

; 168  : 		OP.mad						(Device.vCameraPosition,OD,-500.f);

	mov	edx, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax]
	movss	xmm5, DWORD PTR __real@43fa0000
	mov	eax, DWORD PTR [eax+1116]
	mov	edi, DWORD PTR [eax+440]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm2, DWORD PTR [edi+160]
	movss	xmm3, DWORD PTR [edi+164]
	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR [edi+168]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm3

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mulss	xmm0, xmm2

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm1, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm0

; 192  : 		y *= mag;

	mulss	xmm4, xmm0
	mulss	xmm1, xmm2
	movaps	xmm2, xmm0
	mulss	xmm2, xmm3
	movss	DWORD PTR _OD$2[esp+76], xmm1

; 193  : 		z *= mag;

	movss	DWORD PTR _OD$2[esp+84], xmm4
	movss	DWORD PTR _OD$2[esp+80], xmm2

; 144  : 		x = p.x + d.x*m;

	movss	xmm0, DWORD PTR [edx+488]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 168  : 		OP.mad						(Device.vCameraPosition,OD,-500.f);

	mulss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 145  : 		y = p.y + d.y*m;

	mulss	xmm2, xmm5
	subss	xmm0, xmm1

; 146  : 		z = p.z + d.z*m;

	mulss	xmm4, xmm5
	movss	DWORD PTR _OP$3[esp+76], xmm0
	movss	xmm0, DWORD PTR [edx+492]
	subss	xmm0, xmm2
	movss	DWORD PTR _OP$3[esp+80], xmm0
	movss	xmm0, DWORD PTR [edx+496]
	subss	xmm0, xmm4

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR _AD$1[esp+76], ecx
	mov	DWORD PTR _AD$1[esp+80], -1086324736	; bf400000H
	mov	DWORD PTR _AD$1[esp+84], ecx

; 146  : 		z = p.z + d.z*m;

	movss	DWORD PTR _OP$3[esp+84], xmm0

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	xmm3, DWORD PTR [edi+160]
	movss	DWORD PTR _AD$1[esp+76], xmm3
	movss	xmm2, DWORD PTR [edi+164]
	subss	xmm2, DWORD PTR __real@3f400000
	movss	DWORD PTR tv231[esp+76], xmm3

; 167  : 		return x*x + y*y + z*z;

	fld	DWORD PTR tv231[esp+76]
	fmul	ST(0), ST(0)

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR tv223[esp+76], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 172  : 		int		counter = 0;

	fld	DWORD PTR tv223[esp+76]
	fmul	ST(0), ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _AD$1[esp+80], xmm2
	movss	xmm4, DWORD PTR [edi+168]
	movss	DWORD PTR tv213[esp+76], xmm4
	movss	DWORD PTR _AD$1[esp+84], xmm4

; 167  : 		return x*x + y*y + z*z;

	faddp	ST(1), ST(0)
	fld	DWORD PTR tv213[esp+76]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 173  : 		while	(AD.magnitude()<0.001 && counter<10)	{

	fld	QWORD PTR __real@3f50624dd2f1a9fc
	fcomi	ST(1)
	fstp	ST(1)
	jbe	SHORT $LN73@Update
$LN8@Update:
	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN73@Update
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm3, DWORD PTR [edi+160]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 174  : 			AD.add(E->sun_dir); counter++;

	inc	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _AD$1[esp+76], xmm3
	addss	xmm2, DWORD PTR [edi+164]
	movss	DWORD PTR tv563[esp+76], xmm3
	movss	DWORD PTR tv568[esp+76], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 174  : 			AD.add(E->sun_dir); counter++;

	fld	DWORD PTR tv568[esp+76]
	fmul	ST(0), ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	fld	DWORD PTR tv563[esp+76]
	fmul	ST(0), ST(0)

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _AD$1[esp+80], xmm2
	addss	xmm4, DWORD PTR [edi+168]

; 167  : 		return x*x + y*y + z*z;

	faddp	ST(1), ST(0)

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR tv573[esp+76], xmm4

; 167  : 		return x*x + y*y + z*z;

	fld	DWORD PTR tv573[esp+76]
	fmul	ST(0), ST(0)

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movss	DWORD PTR _AD$1[esp+84], xmm4

; 167  : 		return x*x + y*y + z*z;

	faddp	ST(1), ST(0)
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	fsqrt
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 173  : 		while	(AD.magnitude()<0.001 && counter<10)	{

	fxch	ST(1)
	fcomi	ST(1)
	fstp	ST(1)
	ja	SHORT $LN8@Update
$LN73@Update:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 178  : 		sun_original->set_rotation	(OD,_sun_original->right	);

	lea	eax, DWORD PTR [ebx+88]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm0, xmm3
	movaps	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 178  : 		sun_original->set_rotation	(OD,_sun_original->right	);

	mov	ecx, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm1, xmm2
	fstp	ST(0)
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 178  : 		sun_original->set_rotation	(OD,_sun_original->right	);

	push	eax
	lea	eax, DWORD PTR _OD$2[esp+80]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	divss	xmm6, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 191  : 		x *= mag;

	mulss	xmm3, xmm0

; 192  : 		y *= mag;

	mulss	xmm2, xmm0

; 193  : 		z *= mag;

	mulss	xmm4, xmm0
	movss	DWORD PTR _AD$1[esp+84], xmm3
	movss	DWORD PTR _AD$1[esp+88], xmm2
	movss	DWORD PTR _AD$1[esp+92], xmm4

; 144  : 		x = p.x + d.x*m;

	movss	xmm0, DWORD PTR [edx+488]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 177  : 		AP.mad						(Device.vCameraPosition,AD,-500.f);

	mulss	xmm3, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 145  : 		y = p.y + d.y*m;

	mulss	xmm2, xmm5
	subss	xmm0, xmm3

; 146  : 		z = p.z + d.z*m;

	mulss	xmm4, xmm5
	movss	DWORD PTR _AP$4[esp+84], xmm0
	movss	xmm0, DWORD PTR [edx+492]
	subss	xmm0, xmm2
	movss	DWORD PTR _AP$4[esp+88], xmm0
	movss	xmm0, DWORD PTR [edx+496]
	subss	xmm0, xmm4
	movss	DWORD PTR _AP$4[esp+92], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 178  : 		sun_original->set_rotation	(OD,_sun_original->right	);

	mov	edx, DWORD PTR [ebx]
	call	DWORD PTR [edx+24]

; 179  : 		sun_original->set_position	(OP);

	mov	ecx, DWORD PTR [esi+12]
	lea	edx, DWORD PTR _OP$3[esp+76]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+20]

; 180  : 		sun_original->set_color		(E->sun_color.x,E->sun_color.y,E->sun_color.z);

	fld	DWORD PTR [edi+156]
	sub	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+12]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR [edi+152]
	mov	eax, DWORD PTR [ecx]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR [edi+148]
	fstp	DWORD PTR [esp]
	call	DWORD PTR [eax+44]

; 181  : 		sun_original->set_range		(600.f);

	mov	ecx, DWORD PTR [esi+12]
	fld	DWORD PTR __real@44160000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+32]

; 182  : 		sun_adapted->set_rotation	(AD, _sun_adapted->right	);

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ebp+88]
	push	eax
	lea	eax, DWORD PTR _AD$1[esp+80]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+24]

; 183  : 		sun_adapted->set_position	(AP		);

	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR _AP$4[esp+76]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+20]

; 184  : 		sun_adapted->set_color		(E->sun_color.x*ps_r2_sun_lumscale,E->sun_color.y*ps_r2_sun_lumscale,E->sun_color.z*ps_r2_sun_lumscale);

	movss	xmm1, DWORD PTR ?ps_r2_sun_lumscale@@3MA
	sub	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+16]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [edi+156]
	mov	eax, DWORD PTR [ecx]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [edi+152]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+148]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR [eax+44]

; 185  : 		sun_adapted->set_range		(600.f	);

	mov	ecx, DWORD PTR [esi+16]
	fld	DWORD PTR __real@44160000
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+32]
	pop	edi
$LN67@Update:
	pop	ebp
$LN10@Update:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_Package.cpp

; 6    : 	v_point.clear		();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax

; 7    : 	v_spot.clear		();

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+36], eax

; 8    : 	v_shadowed.clear	();

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+48], eax
	pop	esi
	pop	ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\Light_DB.cpp

; 190  : }

	add	esp, 60					; 0000003cH
	ret	0
?Update@CLight_DB@@QAEXXZ ENDP				; CLight_DB::Update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??B?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEP80@BEPAVIRender_Light@@XZXZ
_TEXT	SEGMENT
??B?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEP80@BEPAVIRender_Light@@XZXZ PROC ; resptr_core<IRender_Light,resptrcode_light>::operator IRender_Light * (__thiscall resptr_core<IRender_Light,resptrcode_light>::*)(void)const , COMDAT
; _this$ = ecx

; 75   : 						operator unspecified_bool_type () const							{	return p_ == 0? 0: &resptr_core::_get;	}

	mov	eax, DWORD PTR __imp_?_get@?$resptr_base@VIRender_Light@@@@QBEPAVIRender_Light@@XZ
	xor	edx, edx
	cmp	DWORD PTR [ecx], edx
	cmove	eax, edx
	ret	0
??B?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEP80@BEPAVIRender_Light@@XZXZ ENDP ; resptr_core<IRender_Light,resptrcode_light>::operator IRender_Light * (__thiscall resptr_core<IRender_Light,resptrcode_light>::*)(void)const 
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEPAVIRender_Light@@XZ
_TEXT	SEGMENT
??C?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEPAVIRender_Light@@XZ PROC ; resptr_core<IRender_Light,resptrcode_light>::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QBEPAVIRender_Light@@XZ ENDP ; resptr_core<IRender_Light,resptrcode_light>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??4?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAEAAV0@ABV0@@Z PROC ; resptr_core<IRender_Light,resptrcode_light>::operator=, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR _rhs$[esp-4]

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	push	esi
	push	edi
	mov	edi, ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	esi, DWORD PTR [eax]

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	test	esi, esi
	je	SHORT $LN8@operator
	inc	DWORD PTR [esi+4]
$LN8@operator:
	call	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
	mov	DWORD PTR [edi], esi

; 67   : 	self &				operator=		(const self & rhs)								{	_set(rhs);	return (self&)*this;	}

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??4?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAEAAV0@ABV0@@Z ENDP ; resptr_core<IRender_Light,resptrcode_light>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??1?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ
_TEXT	SEGMENT
??1?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ PROC ; resptr_core<IRender_Light,resptrcode_light>::~resptr_core<IRender_Light,resptrcode_light>, COMDAT
; _this$ = ecx

; 64   : 						~resptr_core	()												{	_dec();						}

	jmp	DWORD PTR __imp_?_dec@?$resptr_base@VIRender_Light@@@@IAEXXZ
??1?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ ENDP ; resptr_core<IRender_Light,resptrcode_light>::~resptr_core<IRender_Light,resptrcode_light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@PAVIRender_Light@@_N@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_add_ref$dead$ = 12					; size = 1
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@PAVIRender_Light@@_N@Z PROC ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>, COMDAT
; _this$ = ecx

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@resptr_cor
	inc	DWORD PTR [eax+4]
$LN7@resptr_cor:

; 62   : 						resptr_core		(T * p, bool add_ref = true) 					{	p_ = p;	if(add_ref)	_inc(); }

	mov	eax, ecx
	ret	8
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@PAVIRender_Light@@_N@Z ENDP ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ
_TEXT	SEGMENT
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ PROC ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>, COMDAT
; _this$ = ecx

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@XZ ENDP ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ PROC ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAE@XZ ENDP ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXI@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1359 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN9@reserve

; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Reallocate_exactly
$LN2@reserve:

; 1364 :         }
; 1365 :     }

	ret	4
$LN9@reserve:

; 1360 :                 _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength
$LN7@reserve:
	int	3
?reserve@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXI@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN14@push_back
	inc	DWORD PTR [eax+4]
$LN14@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::emplace_back<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::emplace_back<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 722  :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back_with_unused_capacity@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAE?A_T$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back_with_unused_capacity<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ PROC ; xr_vector<light *,xalloc<light *> >::xr_vector<light *,xalloc<light *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAVlight@@V?$xalloc@PAVlight@@@@@@QAE@XZ ENDP ; xr_vector<light *,xalloc<light *> >::xr_vector<light *,xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ PROC ; std::vector<light *,xalloc<light *> >::~vector<light *,xalloc<light *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ENDP ; std::vector<light *,xalloc<light *> >::~vector<light *,xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_flags.h
;	COMDAT ?test@?$_flags@I@@QBEHI@Z
_TEXT	SEGMENT
_mask$ = 8						; size = 4
?test@?$_flags@I@@QBEHI@Z PROC				; _flags<unsigned int>::test, COMDAT
; _this$ = ecx

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _mask$[esp-4]
	ret	4
?test@?$_flags@I@@QBEHI@Z ENDP				; _flags<unsigned int>::test
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ PROC ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@@QAEXXZ ENDP ; xr_vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXXZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXXZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QBEIXZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
tv218 = 8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv218[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN18@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR tv218[ebp]
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN21@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXI@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXXZ PROC ; std::vector<light *,xalloc<light *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXXZ ENDP ; std::vector<light *,xalloc<light *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ PROC ; std::vector<light *,xalloc<light *> >::vector<light *,xalloc<light *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@QAE@XZ ENDP ; std::vector<light *,xalloc<light *> >::vector<light *,xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@II@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@II@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@0@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN20@Umove_if_n
	inc	DWORD PTR [ecx+4]
$LN20@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXXZ PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXXZ ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAIABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@IPBX@Z PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@IPBX@Z ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEAAV?$xalloc@PAVlight@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEAAV?$xalloc@PAVlight@@@@XZ PROC ; std::vector<light *,xalloc<light *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEAAV?$xalloc@PAVlight@@@@XZ ENDP ; std::vector<light *,xalloc<light *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@0@Z PROC ; std::vector<light *,xalloc<light *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAVlight@@V?$xalloc@PAVlight@@@@@std@@AAEXPAPAVlight@@0@Z ENDP ; std::vector<light *,xalloc<light *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAVlight@@@@QBEXPAPAVlight@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAVlight@@@@QBEXPAPAVlight@@I@Z PROC ; xalloc<light *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAVlight@@@@QBEXPAPAVlight@@I@Z ENDP ; xalloc<light *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN18@Umove_if_n
	inc	DWORD PTR [ecx+4]
$LN18@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEIXZ PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEIXZ ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVlight@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVlight@@@@XZ PROC ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAVlight@@@@XZ ENDP ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@Vlight@@@@YAPAVlight@@XZ
_TEXT	SEGMENT
??$xr_new@Vlight@@@@YAPAVlight@@XZ PROC			; xr_new<light>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	push	edi
	push	184					; 000000b8H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	edi, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 11   : 	xr_resource()			: dwReference(0)				{ }

	mov	DWORD PTR [edi+4], 0
	mov	ecx, DWORD PTR __imp_??_7IRender_Light@@6B@
	mov	DWORD PTR [edi], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 4    : light::light		(void)	: ISpatial(g_SpatialSpace)

	mov	ecx, DWORD PTR __imp_?g_SpatialSpace@@3PAVISpatial_DB@@A
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edi+8]
	call	DWORD PTR __imp_??0ISpatial@@QAE@PAVISpatial_DB@@@Z

; 7    : 	flags.type		= POINT;

	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [edi], OFFSET ??_7light@@6BIRender_Light@@@
	and	eax, -127				; ffffff81H

; 8    : 	flags.bStatic	= false;
; 9    : 	flags.bActive	= false;
; 10   : 	flags.bShadow	= false;

	or	eax, 1
	mov	DWORD PTR [edi+8], OFFSET ??_7light@@6BISpatial@@@
	mov	DWORD PTR [edi+60], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	eax, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 6    : 	spatial.type	= STYPE_LIGHTSOURCE;

	mov	DWORD PTR [edi+12], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [edi+64], 0
	mov	DWORD PTR [edi+68], -998637568		; c47a0000H
	mov	DWORD PTR [edi+72], 0
	mov	DWORD PTR [edi+76], 0
	mov	DWORD PTR [edi+80], -1082130432		; bf800000H
	mov	DWORD PTR [edi+84], 0
	mov	DWORD PTR [edi+88], 0
	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [edi+96], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 14   : 	range			= 8.f;

	mov	DWORD PTR [edi+100], 1090519040		; 41000000H

; 15   : 	cone			= deg2rad(60.f);

	mov	DWORD PTR [edi+104], 1065749138		; 3f860a92H
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 45   : 		r = _r; g = _g; b = _b; a = _a;		

	mov	DWORD PTR [edi+108], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+112], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+116], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+120], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\light.cpp

; 18   : 	frame_render	= 0;

	mov	DWORD PTR [edi+180], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	pop	edi
	pop	esi

; 70   : }

	ret	0
??$xr_new@Vlight@@@@YAPAVlight@@XZ ENDP			; xr_new<light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z PROC ; std::move<resptr_core<IRender_Light,resptrcode_light> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ENDP ; std::move<resptr_core<IRender_Light,resptrcode_light> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z PROC ; std::forward<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ENDP ; std::forward<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV1@@Z PROC ; std::_Unfancy<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV1@@Z ENDP ; std::_Unfancy<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@construct
	inc	DWORD PTR [eax+4]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z
_TEXT	SEGMENT
__Backout$2 = -56					; size = 12
__Backout$3 = -44					; size = 12
__UFirst$4 = -32					; size = 4
__UFirst$5 = -28					; size = 4
__Newvec$ = -24						; size = 4
__Newcapacity$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$1$ = 8					; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	edi, esi
	sub	edi, edx
	sar	edi, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN93@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN90@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN90@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	edi, DWORD PTR [edx+edi*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN27@Emplace_re
	inc	DWORD PTR [eax+4]
$LN27@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	cmp	esi, ecx
	jne	SHORT $LN4@Emplace_re

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edx
	push	ecx
	push	eax
	call	?_Umove_if_noexcept@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@00@Z ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove_if_noexcept

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], eax

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	ecx, edx
	mov	DWORD PTR __Backout$3[ebp+4], ecx
	mov	DWORD PTR __Backout$3[ebp+8], ebx
	npad	1
$LL35@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	eax, esi
	je	SHORT $LN34@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN47@Emplace_re
	inc	DWORD PTR [ecx+4]
$LN47@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Backout$3[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	mov	DWORD PTR __UFirst$5[ebp], eax
	mov	edx, ecx
	jmp	SHORT $LL35@Emplace_re
$LN34@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	eax, DWORD PTR [edi+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$4[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], eax
	mov	DWORD PTR __Backout$2[ebp+4], eax
	mov	DWORD PTR __Backout$2[ebp+8], ebx
$LN91@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, eax
	cmp	esi, edx
	je	SHORT $LN56@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN69@Emplace_re
	inc	DWORD PTR [eax+4]
$LN69@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Backout$2[ebp+4], eax

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$4[ebp], esi
	jmp	SHORT $LN91@Emplace_re
$LN56@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], eax
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN80@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN80@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [ebx], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, edi

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QBEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN93@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@CAXXZ ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Xlength
$LN89@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV2@$$QAV2@@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_reallocate<resptr_core<IRender_Light,resptrcode_light> >
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@V?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1>::_Compressed_pair<xalloc<resptr_core<IRender_Light,resptrcode_light> >,std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAVlight@@@@V?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1>::_Compressed_pair<xalloc<light *>,std::_Vector_val<std::_Simple_types<light *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z PROC ; std::_Destroy_range<xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ENDP ; std::_Destroy_range<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; xr_free<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; xr_free<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z PROC ; xr_alloc<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@I@Z ENDP ; xr_alloc<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAVlight@@@@@std@@YAXPAPAVlight@@QAPAV1@AAV?$xalloc@PAVlight@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAVlight@@@@@std@@YAXPAPAVlight@@QAPAV1@AAV?$xalloc@PAVlight@@@@@Z PROC ; std::_Destroy_range<xalloc<light *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAVlight@@@@@std@@YAXPAPAVlight@@QAPAV1@AAV?$xalloc@PAVlight@@@@@Z ENDP ; std::_Destroy_range<xalloc<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAVlight@@@@YAXAAPAPAVlight@@@Z
_TEXT	SEGMENT
??$xr_free@PAVlight@@@@YAXAAPAPAVlight@@@Z PROC		; xr_free<light *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAVlight@@@@YAXAAPAPAVlight@@@Z ENDP		; xr_free<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z PROC ; std::_Uninitialized_copy<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	inc	DWORD PTR [edx+4]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ENDP ; std::_Uninitialized_copy<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::_Get_unwrapped<resptr_core<IRender_Light,resptrcode_light> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YA?A_TABQAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::_Get_unwrapped<resptr_core<IRender_Light,resptrcode_light> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::~_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAE@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >::_Vector_val<std::_Simple_types<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEII@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@ABEII@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV3@00@Z PROC ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN18@Umove
	inc	DWORD PTR [edx+4]
$LN18@Umove:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@AAEPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@PAV3@00@Z ENDP ; std::vector<resptr_core<IRender_Light,resptrcode_light>,xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@ABV2@@Z PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::construct, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	ecx, ecx
	je	SHORT $LN5@construct
	inc	DWORD PTR [ecx+4]
$LN5@construct:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	ret	8
?construct@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@ABV2@@Z ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAE@XZ PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::xalloc<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAE@XZ ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::xalloc<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<light *> >::_Vector_val<std::_Simple_types<light *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVlight@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<light *> >::_Vector_val<std::_Simple_types<light *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAVlight@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAVlight@@@@QAE@XZ PROC			; xalloc<light *>::xalloc<light *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAVlight@@@@QAE@XZ ENDP			; xalloc<light *>::xalloc<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@ABV0@@Z PROC ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>, COMDAT
; _this$ = ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN6@resptr_cor
	inc	DWORD PTR [eax+4]
$LN6@resptr_cor:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, ecx
	ret	4
??0?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAE@ABV0@@Z ENDP ; resptr_core<IRender_Light,resptrcode_light>::resptr_core<IRender_Light,resptrcode_light>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
??$destroy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::destroy<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::destroy<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVlight@@@std@@YAPAPAVlight@@PAPAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVlight@@@std@@YAPAPAVlight@@PAPAV1@@Z PROC ; std::_Unfancy<light *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAVlight@@@std@@YAPAPAVlight@@PAPAV1@@Z ENDP ; std::_Unfancy<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVlight@@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@@Z
_TEXT	SEGMENT
??$destroy@PAVlight@@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@@Z PROC ; std::_Normal_allocator_traits<xalloc<light *> >::destroy<light *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAVlight@@@?$_Normal_allocator_traits@V?$xalloc@PAVlight@@@@@std@@SAXAAV?$xalloc@PAVlight@@@@PAPAVlight@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<light *> >::destroy<light *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEXAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z PROC ; std::_Uninitialized_move<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	edx, edx
	je	SHORT $LN16@Uninitiali
	inc	DWORD PTR [edx+4]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@YAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@QAV1@0PAV1@AAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@Z ENDP ; std::_Uninitialized_move<resptr_core<IRender_Light,resptrcode_light> *,xalloc<resptr_core<IRender_Light,resptrcode_light> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@QAEXPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; xalloc<resptr_core<IRender_Light,resptrcode_light> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@@Z PROC	; xalloc<light *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAVlight@@@@QAEXPAPAVlight@@@Z ENDP	; xalloc<light *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z PROC ; std::forward<resptr_core<IRender_Light,resptrcode_light> &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAAAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@Z ENDP ; std::forward<resptr_core<IRender_Light,resptrcode_light> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN7@construct
	inc	DWORD PTR [eax+4]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@SAXAAV?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@AAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::construct<resptr_core<IRender_Light,resptrcode_light>,resptr_core<IRender_Light,resptrcode_light> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> >, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN12@Emplace_ba
	inc	DWORD PTR [eax+4]
$LN12@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@@@std@@QAEX$$QAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<resptr_core<IRender_Light,resptrcode_light> > >::_Emplace_back<resptr_core<IRender_Light,resptrcode_light> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z PROC ; std::_Destroy_in_place<resptr_core<IRender_Light,resptrcode_light> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@std@@YAXAAPAV?$resptr_core@VIRender_Light@@Uresptrcode_light@@@@@Z ENDP ; std::_Destroy_in_place<resptr_core<IRender_Light,resptrcode_light> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVlight@@@std@@YAXAAPAPAVlight@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAVlight@@@std@@YAXAAPAPAVlight@@@Z PROC ; std::_Destroy_in_place<light * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAVlight@@@std@@YAXAAPAPAVlight@@@Z ENDP ; std::_Destroy_in_place<light * *>
_TEXT	ENDS
END
