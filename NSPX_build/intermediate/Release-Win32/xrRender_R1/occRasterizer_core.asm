; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\occrasterizer_core.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?_abs@@YAHH@Z					; _abs
PUBLIC	?i_section_t1@@YGXXZ				; i_section_t1
PUBLIC	?i_section_t0@@YGXXZ				; i_section_t0
PUBLIC	?i_section_b1@@YGXXZ				; i_section_b1
PUBLIC	?i_section_b0@@YGXXZ				; i_section_b0
PUBLIC	?i_section@@YAXHH@Z				; i_section
PUBLIC	?i_scan@@YAXHMMMMMM@Z				; i_scan
PUBLIC	?Vclamp@@YAXAAHHH@Z				; Vclamp
PUBLIC	?i_order@@YAXPAM00@Z				; i_order
PUBLIC	?rasterize@occRasterizer@@QAEIPAVoccTri@@@Z	; occRasterizer::rasterize
?currentTri@@3PAVoccTri@@A DD 01H DUP (?)		; currentTri
?dwPixels@@3IA DD 01H DUP (?)				; dwPixels
?currentA@@3PAMA DD 03H DUP (?)				; currentA
?currentB@@3PAMA DD 03H DUP (?)				; currentB
?currentC@@3PAMA DD 03H DUP (?)				; currentC
_BSS	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_T$ = 8							; size = 4
?rasterize@occRasterizer@@QAEIPAVoccTri@@@Z PROC	; occRasterizer::rasterize
; _this$dead$ = ecx

; 307  : 	// Order the vertices by Y
; 308  : 	currentTri			= T;

	mov	ecx, DWORD PTR _T$[esp-4]
	push	esi
	mov	DWORD PTR ?currentTri@@3PAVoccTri@@A, ecx

; 309  : 	dwPixels			= 0;

	mov	DWORD PTR ?dwPixels@@3IA, 0

; 13   : 	if (A[1] <= B[1])

	movss	xmm1, DWORD PTR [ecx+16]

; 310  : 	i_order				(&(T->raster[0].x), &(T->raster[1].x),&(T->raster[2].x));

	lea	eax, DWORD PTR [ecx+12]

; 13   : 	if (A[1] <= B[1])

	movss	xmm2, DWORD PTR [ecx+28]
	comiss	xmm2, xmm1
	movss	xmm0, DWORD PTR [ecx+40]
	jb	SHORT $LN6@rasterize

; 14   : 	{
; 15   :         if (B[1] <= C[1]) 

	comiss	xmm0, xmm2
	jb	SHORT $LN8@rasterize

; 16   : 		{  
; 17   : 			min = A; mid = B; max = C; 

	mov	esi, 36					; 00000024H

; 18   : 		}

	jmp	SHORT $LN27@rasterize
$LN8@rasterize:

; 19   :         else // C < B
; 20   : 			if   (A[1] <= C[1]) 

	comiss	xmm0, xmm1
	mov	esi, 24					; 00000018H
	jb	SHORT $LN10@rasterize

; 21   : 			{
; 22   : 				min = A; mid = C; max = B; 

	lea	edx, DWORD PTR [esi+12]

; 23   : 			}

	jmp	SHORT $LN15@rasterize
$LN10@rasterize:

; 24   : 			else 
; 25   : 			{ 
; 26   : 				min = C; mid = A; max = B; 

	lea	eax, DWORD PTR [ecx+36]
	mov	edx, 12					; 0000000cH

; 27   : 			}
; 28   : 	}

	jmp	SHORT $LN15@rasterize
$LN6@rasterize:

; 29   : 	else // B < A
; 30   : 	{
; 31   : 		if (A[1] <= C[1]) 

	comiss	xmm0, xmm1
	jb	SHORT $LN12@rasterize

; 32   : 		{ 
; 33   : 			min = B; mid = A; max = C; 

	mov	edx, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+24]
	lea	esi, DWORD PTR [edx+24]

; 34   : 		}

	jmp	SHORT $LN15@rasterize
$LN12@rasterize:

; 35   : 		else // C < A
; 36   : 			if (B[1] <= C[1]) 

	comiss	xmm0, xmm2
	mov	esi, 12					; 0000000cH
	jb	SHORT $LN14@rasterize

; 37   : 			{ 
; 38   : 				min = B; mid = C; max = A; 

	lea	eax, DWORD PTR [ecx+24]
	lea	edx, DWORD PTR [esi+24]

; 39   : 			}

	jmp	SHORT $LN15@rasterize
$LN14@rasterize:

; 40   : 			else 
; 41   : 			{ 
; 42   : 				min = C; mid = B; max = A; 

	lea	eax, DWORD PTR [ecx+36]
$LN27@rasterize:

; 43   : 			}
; 44   : 	}
; 45   : 	
; 46   : 	currentA[0]	= min[0]+2;	currentB[0]	= mid[0]+2;	currentC[0]	= max[0]+2;

	mov	edx, 24					; 00000018H
$LN15@rasterize:
	movss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1
	push	edi
	movss	DWORD PTR ?currentA@@3PAMA, xmm0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentB@@3PAMA, xmm0
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentC@@3PAMA, xmm0

; 47   : 	currentA[1]	= min[1]+2;	currentB[1]	= mid[1]+2;	currentC[1]	= max[1]+2;

	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentA@@3PAMA+4, xmm0
	movss	xmm2, DWORD PTR [edx+ecx+4]
	addss	xmm2, xmm1
	movss	DWORD PTR ?currentB@@3PAMA+4, xmm2
	movss	xmm0, DWORD PTR [esi+ecx+4]
	addss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+4], xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 47   : 	currentA[1]	= min[1]+2;	currentB[1]	= mid[1]+2;	currentC[1]	= max[1]+2;

	movss	DWORD PTR ?currentC@@3PAMA+4, xmm0

; 48   : 	currentA[2]	= min[2];	currentB[2]	= mid[2];	currentC[2]	= max[2];

	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR ?currentA@@3PAMA+8, xmm0
	movss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR ?currentB@@3PAMA+8, xmm0
	movss	xmm0, DWORD PTR [esi+ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	mov	esi, DWORD PTR _a$1[esp+4]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 48   : 	currentA[2]	= min[2];	currentB[2]	= mid[2];	currentC[2]	= max[2];

	movss	DWORD PTR ?currentC@@3PAMA+8, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	shl	eax, cl

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 313  : 	if (currentB[1]-iFloor(currentB[1]) > .5f)	

	cvtsi2ss xmm0, edi
	pop	edi
	subss	xmm2, xmm0
	comiss	xmm2, DWORD PTR __real@3f000000
	jbe	SHORT $LN2@rasterize

; 301  : {	i_section	(TOP,0);	}

	xor	esi, esi
	lea	edx, DWORD PTR [esi+1]

; 314  : 	{
; 315  : 		i_section_b1	();	// Rasterise First Section
; 316  : 		i_section_t0	();	// Rasterise Second Section
; 317  : 	} else {

	jmp	SHORT $LN3@rasterize
$LN2@rasterize:

; 303  : {	i_section	(TOP,1);	}

	mov	esi, 1
	xor	edx, edx
$LN3@rasterize:

; 318  : 		i_section_b0	();	// Rasterise First Section
; 319  : 		i_section_t1	();	// Rasterise Second Section
; 320  : 	}
; 321  : 	return				dwPixels;

	xor	ecx, ecx
	call	?i_section@@YAXHH@Z			; i_section
	mov	edx, esi
	mov	ecx, 1
	call	?i_section@@YAXHH@Z			; i_section
	mov	eax, DWORD PTR ?dwPixels@@3IA
	pop	esi

; 322  : }

	ret	4
?rasterize@occRasterizer@@QAEIPAVoccTri@@@Z ENDP	; occRasterizer::rasterize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
_C$ = 8							; size = 4
?i_order@@YAXPAM00@Z PROC				; i_order
; _A$ = ecx
; _B$ = edx

; 12   : 	float *min, *max, *mid;
; 13   : 	if (A[1] <= B[1])

	mov	eax, DWORD PTR _C$[esp-4]
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [edi+4]
	movss	xmm2, DWORD PTR [esi+4]
	comiss	xmm2, xmm1
	jb	SHORT $LN2@i_order

; 14   : 	{
; 15   :         if (B[1] <= C[1]) 

	comiss	xmm0, xmm2
	jae	SHORT $LN11@i_order

; 16   : 		{  
; 17   : 			min = A; mid = B; max = C; 
; 18   : 		}
; 19   :         else // C < B
; 20   : 			if   (A[1] <= C[1]) 

	comiss	xmm0, xmm1
	jb	SHORT $LN6@i_order

; 21   : 			{
; 22   : 				min = A; mid = C; max = B; 

	mov	edx, eax
	mov	eax, esi

; 23   : 			}

	jmp	SHORT $LN11@i_order
$LN6@i_order:

; 24   : 			else 
; 25   : 			{ 
; 26   : 				min = C; mid = A; max = B; 

	mov	ecx, eax
	mov	edx, edi
	mov	eax, esi

; 27   : 			}
; 28   : 	}

	jmp	SHORT $LN11@i_order
$LN2@i_order:

; 29   : 	else // B < A
; 30   : 	{
; 31   : 		if (A[1] <= C[1]) 

	comiss	xmm0, xmm1
	jb	SHORT $LN8@i_order

; 32   : 		{ 
; 33   : 			min = B; mid = A; max = C; 

	mov	ecx, esi
	mov	edx, edi

; 34   : 		}

	jmp	SHORT $LN11@i_order
$LN8@i_order:

; 35   : 		else // C < A
; 36   : 			if (B[1] <= C[1]) 

	comiss	xmm0, xmm2
	jb	SHORT $LN10@i_order

; 37   : 			{ 
; 38   : 				min = B; mid = C; max = A; 

	mov	ecx, esi
	mov	edx, eax

; 39   : 			}

	jmp	SHORT $LN13@i_order
$LN10@i_order:

; 40   : 			else 
; 41   : 			{ 
; 42   : 				min = C; mid = B; max = A; 

	mov	ecx, eax
$LN13@i_order:

; 43   : 			}
; 44   : 	}
; 45   : 	
; 46   : 	currentA[0]	= min[0]+2;	currentB[0]	= mid[0]+2;	currentC[0]	= max[0]+2;

	mov	eax, edi
$LN11@i_order:
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR __real@40000000
	addss	xmm0, xmm1

; 47   : 	currentA[1]	= min[1]+2;	currentB[1]	= mid[1]+2;	currentC[1]	= max[1]+2;
; 48   : 	currentA[2]	= min[2];	currentB[2]	= mid[2];	currentC[2]	= max[2];

	pop	edi
	pop	esi
	movss	DWORD PTR ?currentA@@3PAMA, xmm0
	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentB@@3PAMA, xmm0
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentC@@3PAMA, xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentA@@3PAMA+4, xmm0
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentB@@3PAMA+4, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, xmm1
	movss	DWORD PTR ?currentC@@3PAMA+4, xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR ?currentA@@3PAMA+8, xmm0
	movss	xmm0, DWORD PTR [edx+8]
	movss	DWORD PTR ?currentB@@3PAMA+8, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR ?currentC@@3PAMA+8, xmm0

; 49   : }

	ret	0
?i_order@@YAXPAM00@Z ENDP				; i_order
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
;	COMDAT ?Vclamp@@YAXAAHHH@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?Vclamp@@YAXAAHHH@Z PROC				; Vclamp, COMDAT
; _v$ = ecx
; _a$ = edx

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	cmp	DWORD PTR [ecx], edx
	jge	SHORT $LN2@Vclamp
	mov	DWORD PTR [ecx], edx

; 55   : }

	ret	0
$LN2@Vclamp:

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	mov	eax, DWORD PTR _b$[esp-4]
	cmp	DWORD PTR [ecx], eax
	jl	SHORT $LN4@Vclamp
	dec	eax
	mov	DWORD PTR [ecx], eax
$LN4@Vclamp:

; 55   : }

	ret	0
?Vclamp@@YAXAAHHH@Z ENDP				; Vclamp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
_curY$1$ = -4						; size = 4
_maxT$2$ = 8						; size = 4
_a$1 = 8						; size = 4
_a$2 = 8						; size = 4
_leftX$ = 8						; size = 4
_i_base$1$ = 12						; size = 4
_a$3 = 12						; size = 4
_a$4 = 12						; size = 4
_lhx$ = 12						; size = 4
tv1215 = 16						; size = 4
_rightX$ = 16						; size = 4
_rhx$ = 20						; size = 4
_startZ$ = 24						; size = 4
_endZ$ = 28						; size = 4
?i_scan@@YAXHMMMMMM@Z PROC				; i_scan
; _curY$ = ecx

; 75   : {

	push	ecx

; 76   : 	// calculate span(s)
; 77   : 	float	start_c	= leftX+lhx;

	movss	xmm5, DWORD PTR _leftX$[esp]

; 78   : 	float	end_c	= rightX+rhx;

	movss	xmm3, DWORD PTR _rightX$[esp]
	movaps	xmm4, xmm5

; 79   : 	
; 80   : 	float	startR	= leftX-lhx;

	subss	xmm5, DWORD PTR _lhx$[esp]
	addss	xmm4, DWORD PTR _lhx$[esp]
	movaps	xmm2, xmm3
	mov	DWORD PTR _curY$1$[esp+4], ecx
	addss	xmm2, DWORD PTR _rhx$[esp]

; 81   : 	float	endR	= rightX-rhx;

	subss	xmm3, DWORD PTR _rhx$[esp]

; 82   : 	
; 83   : 	float	startT	=startR,	endT	=end_c;

	movaps	xmm1, xmm5

; 84   : 	float	startX	=start_c,	endX	=endR;
; 85   : 	if (start_c<startR)		{startT	= start_c;	startX	= startR;	}

	comiss	xmm5, xmm4
	movaps	xmm0, xmm2
	movaps	xmm6, xmm3
	jbe	SHORT $LN11@i_scan
	movaps	xmm1, xmm4
	movaps	xmm4, xmm5
$LN11@i_scan:

; 86   : 	if (end_c<endR)			{endT	= endR;		endX	= end_c;	}

	comiss	xmm3, xmm2
	jbe	SHORT $LN12@i_scan
	movaps	xmm0, xmm3
	movaps	xmm6, xmm2
$LN12@i_scan:
	push	ebx
	push	ebp
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$2[esp+16], xmm1

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edi, 158				; 0000009eH
	mov	esi, DWORD PTR _a$2[esp+16]
	mov	ecx, edi
	mov	eax, esi

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$1[esp+16], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebp, esi
	movzx	eax, al
	or	ebp, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebp, 8
	shr	ebp, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	ebx, 1
	sub	ecx, 96					; 00000060H
	mov	eax, ebx
	shl	eax, cl

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+16]

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax
	sbb	eax, eax
	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebp, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, edi

; 93   :         r			&=	exponent;

	and	ebp, eax

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	or	edi, -8388608				; ff800000H
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 93   :         r			&=	exponent;

	xor	ebp, edx

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	eax, al

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl
	mov	eax, ebx
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	shl	eax, cl
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 89   : 	int minT		= iFloor(startT)-1, maxT = iCeil(endT)+1;

	dec	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	dec	eax

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	not	edx
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	lea	ecx, DWORD PTR [ebx+65]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 114  :         r			&=	exponent;

	and	edi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 89   : 	int minT		= iFloor(startT)-1, maxT = iCeil(endT)+1;

	mov	eax, ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 114  :         r			&=	exponent;

	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 89   : 	int minT		= iFloor(startT)-1, maxT = iCeil(endT)+1;

	sub	eax, edi

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	cmp	ebp, ebx
	jge	SHORT $LN27@i_scan
	mov	ebp, ebx
	jmp	SHORT $LN29@i_scan
$LN27@i_scan:
	cmp	ebp, 67					; 00000043H
	cmovge	ebp, ecx
$LN29@i_scan:
	cmp	eax, 1
	jge	SHORT $LN32@i_scan
	mov	eax, ebx
	jmp	SHORT $LN81@i_scan
$LN32@i_scan:
	cmp	eax, 67					; 00000043H
	cmovge	eax, ecx
$LN81@i_scan:

; 90   : 	Vclamp			(minT,1,occ_dim-1);
; 91   : 	Vclamp			(maxT,1,occ_dim-1);
; 92   : 	if (minT >= maxT)		return;

	mov	DWORD PTR _maxT$2$[esp+16], eax
	cmp	ebp, eax
	jge	$LN9@i_scan
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$4[esp+16], xmm4

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
	mov	esi, DWORD PTR _a$4[esp+16]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	sub	ecx, 96					; 00000060H
	sar	edx, 31					; 0000001fH
	mov	eax, ebx

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$3[esp+16], xmm6

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	shl	eax, cl

; 110  :         exponent	-=	(31-127)+32;
; 111  :         exponent	>>=	31;
; 112  :         a			=	~((a-1)>>31);		/* change sign */

	not	edx
	dec	eax
	sar	eax, 8
	and	eax, esi

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$3[esp+16]

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	eax, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	or	ebx, -8388608				; ff800000H

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	inc	eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shl	ebx, 8

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH

; 114  :         r			&=	exponent;

	and	edi, eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, esi
	sar	eax, 23					; 00000017H

; 114  :         r			&=	exponent;

	xor	edi, edx

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	eax, al

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	sub	ecx, eax
	sar	edx, 31					; 0000001fH
	shr	ebx, cl
	mov	eax, 1
	sub	ecx, 96					; 00000060H
	shl	eax, cl
	dec	eax
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	mov	eax, 67					; 00000043H
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx

; 116  :         r			=	-r;                 /* change sign */

	neg	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	jns	SHORT $LN41@i_scan
	xor	edi, edi
	jmp	SHORT $LN43@i_scan
$LN41@i_scan:
	cmp	edi, 68					; 00000044H
	cmovge	edi, eax
$LN43@i_scan:
	test	ebx, ebx
	jns	SHORT $LN46@i_scan
	xor	ebx, ebx
	jmp	SHORT $LN48@i_scan
$LN46@i_scan:
	cmp	ebx, 68					; 00000044H
	cmovge	ebx, eax
$LN48@i_scan:

; 93   : 	
; 94   : 	int minX		= iCeil(startX), maxX = iFloor(endX);
; 95   : 	Vclamp			(minX,0,occ_dim);
; 96   : 	Vclamp			(maxX,0,occ_dim);
; 97   : 	int limLeft,limRight;
; 98   : 	if (minX >  maxX)	{ limLeft=maxX; limRight=minX;	}
; 99   : 	else				{ limLeft=minX; limRight=maxX;	}
; 100  : 	
; 101  : 	// interpolate
; 102  : 	float lenR		= endR - startR;
; 103  : 	float Zlen		= endZ - startZ;
; 104  : 	float Z			= startZ + (minT - startR)/lenR * Zlen;		// interpolate Z to the start

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm3, xmm5
	movss	xmm1, DWORD PTR _startZ$[esp+16]
	cmp	edi, ebx
	movss	xmm2, DWORD PTR _endZ$[esp+16]
	mov	eax, edi
	cmovle	eax, ebx

; 105  : 	float Zend		= startZ + (maxT - startR)/lenR * Zlen;		// interpolate Z to the end
; 106  : 	float dZ		= (Zend-Z)/(maxT-minT);						// incerement in Z / pixel wrt dX
; 107  : 	
; 108  : 	// gain access to buffers
; 109  : 	occTri** pFrame	= Raster.get_frame();
; 110  : 	float*	pDepth	= Raster.get_depth();
; 111  : 	
; 112  : 	// left connector
; 113  : 	int	i_base		= curY*occ_dim;

	mov	ecx, DWORD PTR _curY$1$[esp+20]
	mov	DWORD PTR tv1215[esp+16], eax
	subss	xmm2, xmm1
	mov	eax, DWORD PTR _maxT$2$[esp+16]
	divss	xmm0, xmm3

; 114  : 	int i			= i_base+minT;
; 115  : 	int limit		= i_base+limLeft;
; 116  : 	for (; i<limit; i++, Z+=dZ)

	mov	edx, DWORD PTR ?dwPixels@@3IA
	shl	ecx, 4
	add	ecx, DWORD PTR _curY$1$[esp+20]
	shl	ecx, 2
	mov	DWORD PTR _i_base$1$[esp+16], ecx
	cvtsi2ss xmm4, eax
	sub	eax, ebp
	cmp	edi, ebx
	cvtsi2ss xmm3, ebp
	subss	xmm4, xmm5
	movss	xmm6, DWORD PTR __real@3eaaaaab
	subss	xmm3, xmm5
	movss	xmm5, DWORD PTR __real@3f2aaaab
	mulss	xmm4, xmm0
	mulss	xmm3, xmm0
	mulss	xmm4, xmm2
	mulss	xmm3, xmm2
	addss	xmm4, xmm1
	cvtsi2ss xmm0, eax
	lea	eax, DWORD PTR [ecx+ebp]
	mov	ebp, ebx
	cmovle	ebp, edi
	add	ebp, ecx
	mov	ecx, DWORD PTR ?currentTri@@3PAVoccTri@@A
	addss	xmm3, xmm1
	movaps	xmm2, xmm4
	subss	xmm2, xmm3
	divss	xmm2, xmm0
	cmp	eax, ebp
	jge	SHORT $LN3@i_scan
$LL4@i_scan:

; 117  : 	{
; 118  : 		if (shared(currentTri,pFrame[i-1])) 

	mov	esi, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4-4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 69   : 	if (T1==T2)					return TRUE;

	cmp	ecx, esi
	je	SHORT $LN77@i_scan

; 70   : 	if (T1->adjacent[0]==T2)	return TRUE;

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN77@i_scan

; 71   : 	if (T1->adjacent[1]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+4], esi
	je	SHORT $LN77@i_scan

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+8], esi
	jne	SHORT $LN2@i_scan
$LN77@i_scan:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 120  : 			float ZR = (Z+2*pDepth[i-1])*one_div_3;

	movss	xmm1, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18492]
	movaps	xmm0, xmm3
	mulss	xmm0, xmm6
	mulss	xmm1, xmm5
	addss	xmm1, xmm0

; 121  : 			if (ZR<pDepth[i])	{ pFrame[i]	= currentTri; pDepth[i]	= ZR; dwPixels++; }

	movss	xmm0, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@i_scan
	mov	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4], ecx
	inc	edx
	movss	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496], xmm1
$LN2@i_scan:

; 114  : 	int i			= i_base+minT;
; 115  : 	int limit		= i_base+limLeft;
; 116  : 	for (; i<limit; i++, Z+=dZ)

	inc	eax
	movaps	xmm0, xmm2
	addss	xmm3, xmm0
	cmp	eax, ebp
	jl	SHORT $LL4@i_scan

; 121  : 			if (ZR<pDepth[i])	{ pFrame[i]	= currentTri; pDepth[i]	= ZR; dwPixels++; }

	mov	DWORD PTR ?dwPixels@@3IA, edx
$LN3@i_scan:

; 122  : 		}
; 123  : 	}
; 124  : 
; 125  : 	// compute the scanline 
; 126  : 	limit				= i_base+maxX;

	mov	ebp, DWORD PTR _i_base$1$[esp+16]
	lea	esi, DWORD PTR [ebx+ebp]

; 127  : 	for (; i<limit; i++, Z+=dZ) 

	cmp	eax, esi
	jge	SHORT $LN6@i_scan
	npad	1
$LL7@i_scan:

; 128  : 	{
; 129  : 		if (Z<pDepth[i])		{ pFrame[i]	= currentTri; pDepth[i] = Z;  dwPixels++; }

	movss	xmm0, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496]
	comiss	xmm0, xmm3
	jbe	SHORT $LN5@i_scan
	mov	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4], ecx
	inc	edx
	movss	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496], xmm3
$LN5@i_scan:

; 127  : 	for (; i<limit; i++, Z+=dZ) 

	inc	eax
	movaps	xmm0, xmm2
	addss	xmm3, xmm0
	cmp	eax, esi
	jl	SHORT $LL7@i_scan

; 128  : 	{
; 129  : 		if (Z<pDepth[i])		{ pFrame[i]	= currentTri; pDepth[i] = Z;  dwPixels++; }

	mov	DWORD PTR ?dwPixels@@3IA, edx
$LN6@i_scan:

; 130  : 	}
; 131  : 	
; 132  : 	// right connector
; 133  : 	i				= i_base+maxT-1;

	mov	eax, DWORD PTR _maxT$2$[esp+16]

; 134  : 	limit			= i_base+limRight;
; 135  : 	Z				= Zend-dZ;

	subss	xmm4, xmm2
	mov	edi, DWORD PTR tv1215[esp+16]
	dec	eax
	add	edi, ebp
	add	eax, ebp

; 136  : 	for (; i>=limit; i--, Z-=dZ)

	cmp	eax, edi
	jl	SHORT $LN9@i_scan
	npad	10
$LL10@i_scan:

; 137  : 	{
; 138  : 		if (shared(currentTri,pFrame[i+1])) {

	mov	esi, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer.cpp

; 69   : 	if (T1==T2)					return TRUE;

	cmp	ecx, esi
	je	SHORT $LN78@i_scan

; 70   : 	if (T1->adjacent[0]==T2)	return TRUE;

	cmp	DWORD PTR [ecx], esi
	je	SHORT $LN78@i_scan

; 71   : 	if (T1->adjacent[1]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+4], esi
	je	SHORT $LN78@i_scan

; 72   : 	if (T1->adjacent[2]==T2)	return TRUE;

	cmp	DWORD PTR [ecx+8], esi
	jne	SHORT $LN8@i_scan
$LN78@i_scan:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 139  : 			float ZR = (Z+2*pDepth[i+1])*one_div_3;

	movss	xmm1, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18500]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm6
	mulss	xmm1, xmm5
	addss	xmm1, xmm0

; 140  : 			if (ZR<pDepth[i])	{ pFrame[i]	= currentTri; pDepth[i]	= ZR; dwPixels++; }

	movss	xmm0, DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496]
	comiss	xmm0, xmm1
	jbe	SHORT $LN8@i_scan
	mov	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4], ecx
	inc	edx
	movss	DWORD PTR ?Raster@@3VoccRasterizer@@A[eax*4+18496], xmm1
$LN8@i_scan:

; 136  : 	for (; i>=limit; i--, Z-=dZ)

	dec	eax
	subss	xmm4, xmm2
	cmp	eax, edi
	jge	SHORT $LL10@i_scan

; 140  : 			if (ZR<pDepth[i])	{ pFrame[i]	= currentTri; pDepth[i]	= ZR; dwPixels++; }

	mov	DWORD PTR ?dwPixels@@3IA, edx
$LN9@i_scan:
	pop	edi

; 141  : 		}
; 142  : 	}
; 143  : }

	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
?i_scan@@YAXHMMMMMM@Z ENDP				; i_scan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
;	COMDAT ?i_section@@YAXHH@Z
_TEXT	SEGMENT
_E2$$sroa$623$1$ = -40					; size = 4
_rightX$ = -40						; size = 4
_E1$$sroa$630$1$ = -36					; size = 4
_rightZ$ = -36						; size = 4
_E1$$sroa$646$1$ = -32					; size = 4
_leftX$ = -32						; size = 4
_left_dX$1$ = -28					; size = 4
_startp2$1$ = -28					; size = 4
_bMiddle$1$ = -24					; size = 4
_leftZ$ = -24						; size = 4
_left_dZ$1$ = -20					; size = 4
_Sect$1$ = -20						; size = 4
_right_dZ$1$ = -16					; size = 4
_E1$$sroa$639$1$ = -16					; size = 4
_right_dX$1$ = -12					; size = 4
_a$1 = -12						; size = 4
_a$2 = -12						; size = 4
_a$3 = -12						; size = 4
_a$4 = -12						; size = 4
_a$5 = -12						; size = 4
_a$6 = -12						; size = 4
_leftX$1$ = -8						; size = 4
_endY$2$ = -8						; size = 4
_lhx$ = -8						; size = 4
_rhx$ = -4						; size = 4
?i_section@@YAXHH@Z PROC				; i_section, COMDAT
; _Sect$ = ecx
; _bMiddle$ = edx

; 212  : {

	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	mov	eax, ecx
	mov	DWORD PTR _bMiddle$1$[esp+48], edx
	mov	DWORD PTR _Sect$1$[esp+48], eax

; 213  : 	// Find the start/end Y pixel coord, set the starting pts for scan line ends
; 214  : 	int		startY, endY;
; 215  : 	float	*startp1, *startp2;
; 216  : 	float	E1[3], E2[3];
; 217  : 
; 218  : 	if (Sect == BOTTOM) { 

	mov	ebx, 158				; 0000009eH
	mov	ecx, ebx
	push	esi
	push	edi
	test	eax, eax
	jne	$LN5@i_section
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	xmm5, DWORD PTR ?currentA@@3PAMA+4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edi, 1
	movss	DWORD PTR _a$6[esp+56], xmm5
	mov	esi, DWORD PTR _a$6[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	mov	ebp, esi
	movzx	eax, al
	or	ebp, -8388608				; ff800000H
	sub	ecx, eax
	shl	ebp, 8
	shr	ebp, cl

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	sub	ecx, 96					; 00000060H

; 83   :     int a			= *(const int*)(&x);

	movss	xmm2, DWORD PTR ?currentB@@3PAMA+4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, edi

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	sar	edx, 31					; 0000001fH
	shl	eax, cl
	not	edx
	dec	eax

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$5[esp+56], xmm2

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sar	eax, 8
	and	eax, esi

; 83   :     int a			= *(const int*)(&x);

	movss	xmm1, DWORD PTR ?currentC@@3PAMA+4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$5[esp+56]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 228  : 		E1[0] = currentB[0]-currentA[0]; E2[0] = currentC[0]-currentA[0];

	movss	xmm6, DWORD PTR ?currentB@@3PAMA
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	eax, eax

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$4[esp+56], xmm1

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	inc	eax

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	ebp, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, ebx

; 114  :         r			&=	exponent;

	and	ebp, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	or	ebx, -8388608				; ff800000H
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 114  :         r			&=	exponent;

	xor	ebp, edx

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	eax, al

; 116  :         r			=	-r;                 /* change sign */

	neg	ebp

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shl	ebx, 8
	shr	ebx, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, edi
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$4[esp+56]

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	eax, eax
	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 220  : 		startp1 = startp2 = currentA;

	mov	eax, OFFSET ?currentA@@3PAMA
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 220  : 		startp1 = startp2 = currentA;

	mov	DWORD PTR _startp2$1$[esp+56], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	cmp	DWORD PTR _bMiddle$1$[esp+56], 0

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi

; 94   :         r			^=	a;

	lea	eax, DWORD PTR [ebx-1]

; 83   :     int a			= *(const int*)(&x);

	cmove	ebx, eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	or	edi, -8388608				; ff800000H
	movzx	eax, al
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	sar	edx, 31					; 0000001fH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 229  : 		E1[1] = currentB[1]-currentA[1]; E2[1] = currentC[1]-currentA[1];

	movss	xmm3, DWORD PTR ?currentC@@3PAMA
	subss	xmm2, xmm5

; 230  : 		E1[2] = currentB[2]-currentA[2]; E2[2] = currentC[2]-currentA[2];

	movss	xmm4, DWORD PTR ?currentC@@3PAMA+8
	subss	xmm1, xmm5
	subss	xmm3, DWORD PTR ?currentA@@3PAMA
	movss	xmm7, DWORD PTR ?currentB@@3PAMA+8
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	shl	eax, cl
	dec	eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 230  : 		E1[2] = currentB[2]-currentA[2]; E2[2] = currentC[2]-currentA[2];

	subss	xmm4, DWORD PTR ?currentA@@3PAMA+8
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sar	eax, 8
	and	eax, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 228  : 		E1[0] = currentB[0]-currentA[0]; E2[0] = currentC[0]-currentA[0];

	lea	esi, DWORD PTR [ebx-1]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax
	sbb	eax, eax
	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 228  : 		E1[0] = currentB[0]-currentA[0]; E2[0] = currentC[0]-currentA[0];

	cmp	ebx, edi
	cmovl	esi, ebx

; 231  : 	}

	jmp	$LN48@i_section
$LN5@i_section:
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	movss	xmm0, DWORD PTR ?currentB@@3PAMA+4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	ebp, 1
	movss	DWORD PTR _a$3[esp+56], xmm0
	mov	esi, DWORD PTR _a$3[esp+56]
	mov	eax, esi
	sar	eax, 23					; 00000017H
	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]
	sub	ecx, 96					; 00000060H

; 83   :     int a			= *(const int*)(&x);

	movss	xmm1, DWORD PTR ?currentC@@3PAMA+4

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	sar	edx, 31					; 0000001fH
	mov	eax, ebp
	shl	eax, cl
	not	edx
	dec	eax

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$2[esp+56], xmm1

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sar	eax, 8
	and	eax, esi

; 104  :     int a			= (*(const int*)(&x));

	movss	xmm4, DWORD PTR ?currentA@@3PAMA+4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$2[esp+56]

; 104  :     int a			= (*(const int*)(&x));

	movss	DWORD PTR _a$1[esp+56], xmm4

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	eax, eax
	inc	eax

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	eax, edx

; 113  :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, ebx

; 114  :         r			&=	exponent;

	and	edi, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ebx, esi
	or	ebx, -8388608				; ff800000H
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 114  :         r			&=	exponent;

	xor	edi, edx

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	eax, al

; 115  :         r			^=	a;

	neg	edi

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shl	ebx, 8
	shr	ebx, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, ebp
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+56]

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	eax
	sbb	eax, eax
	inc	eax

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	ebx, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH

; 93   :         r			&=	exponent;

	and	ebx, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 234  : 		startp1 = currentA; startp2 = currentB;

	mov	eax, OFFSET ?currentB@@3PAMA
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 93   :         r			&=	exponent;

	xor	ebx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 234  : 		startp1 = currentA; startp2 = currentB;

	mov	DWORD PTR _startp2$1$[esp+56], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 104  :     int a			= (*(const int*)(&x));

	cmp	DWORD PTR _bMiddle$1$[esp+56], 0

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	lea	edx, DWORD PTR [esi-1]

; 93   :         r			&=	exponent;

	mov	DWORD PTR _endY$2$[esp+56], ebx

; 105  :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, esi
	lea	ebx, DWORD PTR [edi-1]
	cmove	ebx, edi
	sar	eax, 23					; 00000017H

; 106  :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 107  :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	sar	edx, 31					; 0000001fH

; 110  :         exponent	-=	(31-127)+32;

	shl	ebp, cl
	lea	eax, DWORD PTR [ecx+64]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 242  : 		E1[0] = currentC[0]-currentA[0]; E2[0] = currentC[0]-currentB[0];

	movss	xmm3, DWORD PTR ?currentC@@3PAMA
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	dec	ebp
	sar	ebp, 8

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	not	edx
	and	ebp, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 243  : 		E1[1] = currentC[1]-currentA[1]; E2[1] = currentC[1]-currentB[1];

	movaps	xmm2, xmm1
	mov	esi, DWORD PTR _endY$2$[esp+56]
	subss	xmm2, xmm4

; 244  : 		E1[2] = currentC[2]-currentA[2]; E2[2] = currentC[2]-currentB[2];

	movss	xmm4, DWORD PTR ?currentC@@3PAMA+8
	subss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	neg	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 242  : 		E1[0] = currentC[0]-currentA[0]; E2[0] = currentC[0]-currentB[0];

	movaps	xmm6, xmm3
	subss	xmm3, DWORD PTR ?currentB@@3PAMA
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	sbb	ebp, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 244  : 		E1[2] = currentC[2]-currentA[2]; E2[2] = currentC[2]-currentB[2];

	movaps	xmm7, xmm4
	subss	xmm4, DWORD PTR ?currentB@@3PAMA+8
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 109  :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	inc	ebp

; 111  :         exponent	>>=	31;

	sar	eax, 31					; 0000001fH

; 112  :         a			=	~((a-1)>>31);		/* change sign */

	and	ebp, edx

; 113  :         r			-=	(imask&a);

	sub	edi, ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 242  : 		E1[0] = currentC[0]-currentA[0]; E2[0] = currentC[0]-currentB[0];

	lea	ebp, DWORD PTR [ebx+1]
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 114  :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx

; 116  :         r			=	-r;                 /* change sign */

	neg	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp

; 242  : 		E1[0] = currentC[0]-currentA[0]; E2[0] = currentC[0]-currentB[0];

	cmp	ebx, edi
	cmovge	ebp, ebx
$LN48@i_section:

; 54   : 	if (v<a)	v=a; else if (v>=b) v=b-1;

	movss	DWORD PTR _E2$$sroa$623$1$[esp+56], xmm1
	mov	eax, 67					; 00000043H
	movss	DWORD PTR _E1$$sroa$630$1$[esp+56], xmm2
	subss	xmm6, DWORD PTR ?currentA@@3PAMA
	subss	xmm7, DWORD PTR ?currentA@@3PAMA+8
	movss	DWORD PTR _E1$$sroa$639$1$[esp+56], xmm6
	movss	DWORD PTR _E1$$sroa$646$1$[esp+56], xmm7
	test	ebp, ebp
	jns	SHORT $LN30@i_section
	xor	ebp, ebp
	jmp	SHORT $LN32@i_section
$LN30@i_section:
	cmp	ebp, 68					; 00000044H
	cmovge	ebp, eax
$LN32@i_section:
	test	esi, esi
	jns	SHORT $LN35@i_section
	xor	esi, esi
	jmp	SHORT $LN37@i_section
$LN35@i_section:
	cmp	esi, 68					; 00000044H
	cmovge	esi, eax
$LN37@i_section:

; 245  : 	}
; 246  : 	Vclamp(startY,0,occ_dim);
; 247  : 	Vclamp(endY,  0,occ_dim);
; 248  : 	if (startY >= endY) return;

	cmp	ebp, esi
	jge	$LN3@i_section

; 249  : 	
; 250  : 	// Compute the inverse slopes of the lines, ie rate of change of X by Y
; 251  : 	float mE1	= E1[0]/E1[1];

	movaps	xmm5, xmm6

; 252  : 	float mE2	= E2[0]/E2[1];
; 253  : 	
; 254  : 	// Initial Y offset for left and right (due to pixel rounding)
; 255  : 	float	e1_init_dY = float(startY) - startp1[1], e2_init_dY = float(startY) - startp2[1];

	mov	ecx, DWORD PTR _startp2$1$[esp+56]
	divss	xmm5, xmm2

; 256  : 	float	t,leftX, leftZ, rightX, rightZ, left_dX, right_dX, left_dZ, right_dZ;
; 257  : 	
; 258  : 	// find initial values, step values
; 259  : 	if ( ((mE1<mE2)&&(Sect==BOTTOM)) || ((mE1>mE2)&&(Sect==TOP)) ) 

	mov	eax, DWORD PTR _Sect$1$[esp+56]
	movaps	xmm2, xmm3
	divss	xmm2, xmm1
	cvtsi2ss xmm0, ebp
	comiss	xmm2, xmm5
	movaps	xmm1, xmm0
	movss	DWORD PTR _right_dX$1$[esp+56], xmm2
	subss	xmm1, DWORD PTR ?currentA@@3PAMA+4
	subss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN15@i_section
	test	eax, eax
	je	SHORT $LN14@i_section
$LN15@i_section:
	comiss	xmm5, xmm2
	jbe	SHORT $LN12@i_section
	cmp	eax, 1
	jne	SHORT $LN12@i_section
$LN14@i_section:

; 260  : 	{ 
; 261  : 		// E1 is on the Left
; 262  : 		// Initial Starting values for left (from E1)
; 263  : 		t		= e1_init_dY/E1[1]; // Initial fraction of offset

	divss	xmm1, DWORD PTR _E1$$sroa$630$1$[esp+56]

; 264  : 		leftX	= startp1[0] + E1[0]*t; left_dX = mE1;
; 265  : 		leftZ	= startp1[2] + E1[2]*t; left_dZ = E1[2]/E1[1];
; 266  : 
; 267  : 		// Initial Ending values for right	(from E2)
; 268  : 		t		= e2_init_dY/E2[1]; // Initial fraction of offset

	divss	xmm0, DWORD PTR _E2$$sroa$623$1$[esp+56]
	mulss	xmm6, xmm1
	mulss	xmm7, xmm1
	movss	xmm1, DWORD PTR _E1$$sroa$646$1$[esp+56]
	divss	xmm1, DWORD PTR _E1$$sroa$630$1$[esp+56]
	addss	xmm6, DWORD PTR ?currentA@@3PAMA
	movss	DWORD PTR _left_dZ$1$[esp+56], xmm1

; 269  : 		rightX	= startp2[0] + E2[0]*t; right_dX = mE2;
; 270  : 		rightZ	= startp2[2] + E2[2]*t; right_dZ = E2[2]/E2[1];

	movaps	xmm1, xmm4
	divss	xmm4, DWORD PTR _E2$$sroa$623$1$[esp+56]
	addss	xmm7, DWORD PTR ?currentA@@3PAMA+8
	mulss	xmm1, xmm0
	mulss	xmm3, xmm0
	addss	xmm1, DWORD PTR [ecx+8]
	movss	DWORD PTR _left_dX$1$[esp+56], xmm5
	addss	xmm3, DWORD PTR [ecx]
	movss	DWORD PTR _right_dZ$1$[esp+56], xmm4
	movss	DWORD PTR _rightZ$[esp+56], xmm1

; 271  : 	}

	jmp	$LN49@i_section
$LN12@i_section:

; 272  : 	else { 
; 273  : 		// E2 is on left
; 274  : 		// Initial Starting values for left (from E2)
; 275  : 		t		= e2_init_dY/E2[1]; // Initial fraction of offset

	divss	xmm0, DWORD PTR _E2$$sroa$623$1$[esp+56]

; 276  : 		leftX	= startp2[0] + E2[0]*t; left_dX = mE2;
; 277  : 		leftZ	= startp2[2] + E2[2]*t; left_dZ = E2[2]/E2[1];

	movaps	xmm6, xmm4
	movss	DWORD PTR _left_dX$1$[esp+56], xmm2
	divss	xmm6, DWORD PTR _E2$$sroa$623$1$[esp+56]
	mulss	xmm3, xmm0
	movaps	xmm7, xmm4
	movss	DWORD PTR _left_dZ$1$[esp+56], xmm6

; 278  : 
; 279  : 		// Initial Ending values for right	(from E1)
; 280  : 		t		= e1_init_dY/E1[1]; // Initial fraction of offset
; 281  : 		rightX	= startp1[0] + E1[0]*t; right_dX = mE1;

	movaps	xmm2, xmm5
	movss	xmm6, DWORD PTR _E1$$sroa$630$1$[esp+56]
	divss	xmm1, xmm6
	mulss	xmm7, xmm0

; 282  : 		rightZ	= startp1[2] + E1[2]*t; right_dZ = E1[2]/E1[1];

	movss	xmm0, DWORD PTR _E1$$sroa$646$1$[esp+56]
	mulss	xmm0, xmm1
	addss	xmm3, DWORD PTR [ecx]
	addss	xmm7, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR ?currentA@@3PAMA+8
	movss	xmm5, DWORD PTR _left_dX$1$[esp+56]
	movss	DWORD PTR _right_dX$1$[esp+56], xmm2
	movss	DWORD PTR _leftX$1$[esp+56], xmm3
	movss	xmm3, DWORD PTR _E1$$sroa$639$1$[esp+56]
	movss	DWORD PTR _rightZ$[esp+56], xmm0
	movss	xmm0, DWORD PTR _E1$$sroa$646$1$[esp+56]
	divss	xmm0, xmm6
	movss	xmm6, DWORD PTR _leftX$1$[esp+56]
	mulss	xmm3, xmm1
	movss	DWORD PTR _right_dZ$1$[esp+56], xmm0
	addss	xmm3, DWORD PTR ?currentA@@3PAMA
$LN49@i_section:

; 283  : 	}
; 284  : 
; 285  : 	// Now scan all lines in this section
; 286  : 	float lhx = left_dX/2;	leftX	+= lhx;	// half pixel

	movaps	xmm1, xmm5
	movss	DWORD PTR _leftZ$[esp+56], xmm7
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _lhx$[esp+56], xmm1
	addss	xmm1, xmm6

; 287  : 	float rhx = right_dX/2;	rightX	+= rhx;	// half pixel

	fld	DWORD PTR _lhx$[esp+56]
	movss	DWORD PTR _leftX$[esp+56], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR _rhx$[esp+56], xmm1
	addss	xmm1, xmm3
	fld	DWORD PTR _rhx$[esp+56]
	movss	DWORD PTR _rightX$[esp+56], xmm1
	jmp	SHORT $LN4@i_section
$LN46@i_section:

; 288  : 	for (; startY<=endY; startY++) 

	fxch	ST(1)
$LN4@i_section:

; 289  : 	{
; 290  : 		i_scan	(startY, leftX, lhx, rightX, rhx, leftZ, rightZ);

	fld	DWORD PTR _rightZ$[esp+56]
	sub	esp, 24					; 00000018H
	mov	ecx, ebp
	fstp	DWORD PTR [esp+20]
	fld	DWORD PTR _leftZ$[esp+80]
	fstp	DWORD PTR [esp+16]
	fst	DWORD PTR [esp+12]
	fld	DWORD PTR _rightX$[esp+80]
	fstp	DWORD PTR [esp+8]
	fxch	ST(1)
	fst	DWORD PTR [esp+4]
	fld	DWORD PTR _leftX$[esp+80]
	fstp	DWORD PTR [esp]
	call	?i_scan@@YAXHMMMMMM@Z			; i_scan

; 291  : 		leftX	+= left_dX; rightX += right_dX;

	movss	xmm0, DWORD PTR _left_dX$1$[esp+80]
	inc	ebp
	addss	xmm0, DWORD PTR _leftX$[esp+80]

; 292  : 		leftZ	+= left_dZ; rightZ += right_dZ;

	addss	xmm7, DWORD PTR _left_dZ$1$[esp+80]
	add	esp, 24					; 00000018H
	movss	DWORD PTR _leftX$[esp+56], xmm0
	movss	xmm0, DWORD PTR _right_dX$1$[esp+56]
	movss	DWORD PTR _leftZ$[esp+56], xmm7
	addss	xmm0, DWORD PTR _rightX$[esp+56]
	movss	DWORD PTR _rightX$[esp+56], xmm0
	movss	xmm0, DWORD PTR _right_dZ$1$[esp+56]
	addss	xmm0, DWORD PTR _rightZ$[esp+56]
	movss	DWORD PTR _rightZ$[esp+56], xmm0
	cmp	ebp, esi
	jle	SHORT $LN46@i_section

; 288  : 	for (; startY<=endY; startY++) 

	fstp	ST(0)
	fstp	ST(0)
$LN3@i_section:

; 293  : 	}
; 294  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 40					; 00000028H
	ret	0
?i_section@@YAXHH@Z ENDP				; i_section
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
?i_section_b0@@YGXXZ PROC				; i_section_b0

; 297  : {	i_section	(BOTTOM,0);	}

	xor	edx, edx
	xor	ecx, ecx
	jmp	?i_section@@YAXHH@Z			; i_section
?i_section_b0@@YGXXZ ENDP				; i_section_b0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
?i_section_b1@@YGXXZ PROC				; i_section_b1

; 299  : {	i_section	(BOTTOM,1);	}

	mov	edx, 1
	xor	ecx, ecx
	jmp	?i_section@@YAXHH@Z			; i_section
?i_section_b1@@YGXXZ ENDP				; i_section_b1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
?i_section_t0@@YGXXZ PROC				; i_section_t0

; 301  : {	i_section	(TOP,0);	}

	xor	edx, edx
	lea	ecx, DWORD PTR [edx+1]
	jmp	?i_section@@YAXHH@Z			; i_section
?i_section_t0@@YGXXZ ENDP				; i_section_t0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\occRasterizer_core.cpp
_TEXT	SEGMENT
?i_section_t1@@YGXXZ PROC				; i_section_t1

; 303  : {	i_section	(TOP,1);	}

	mov	edx, 1
	mov	ecx, edx
	jmp	?i_section@@YAXHH@Z			; i_section
?i_section_t1@@YGXXZ ENDP				; i_section_t1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
;	COMDAT ?_abs@@YAHH@Z
_TEXT	SEGMENT
?_abs@@YAHH@Z PROC					; _abs, COMDAT
; _x$ = ecx

; 157  : IC s32		_abs	(s32 x)			{ return (x>=0)? x : s32(-x); }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	ret	0
?_abs@@YAHH@Z ENDP					; _abs
_TEXT	ENDS
END
