; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\wallmarksengine.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?g_r@@3IA					; g_r
PUBLIC	??_C@_0CE@POEPPKEP@?$CB?5Failed?5to?5render?5dynamic?5wall@ ; `string'
EXTRN	__imp_??1CSkeletonWallmark@@QAE@XZ:PROC
EXTRN	__imp_?Parent@CSkeletonWallmark@@QAEPAVCKinematics@@XZ:PROC
EXTRN	__imp_?VCount@CSkeletonWallmark@@QAEIXZ:PROC
EXTRN	__imp_?Shader@CSkeletonWallmark@@QAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ:PROC
EXTRN	__imp_?RenderWallmark@CKinematics@@QAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAPAULIT@FVF@@@Z:PROC
EXTRN	__imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z:PROC
EXTRN	__imp_?AddWallmark@CKinematics@@QAEXPBU?$_matrix@M@@ABU?$_vector3@M@@1V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z:PROC
EXTRN	__imp_?clear@Collector@CDB@@QAEXXZ:PROC
;	COMDAT ??_C@_0CE@POEPPKEP@?$CB?5Failed?5to?5render?5dynamic?5wall@
CONST	SEGMENT
??_C@_0CE@POEPPKEP@?$CB?5Failed?5to?5render?5dynamic?5wall@ DB '! Failed '
	DB	'to render dynamic wallmark', 00H		; `string'
?g_r@@3IA DD	01H					; g_r
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?set@LIT@FVF@@QAEXABU?$_vector3@M@@IMM@Z	; FVF::LIT::set
PUBLIC	??0?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QAE@ABV0@@Z ; resptr_core<SGeometry,resptrcode_geom>::resptr_core<SGeometry,resptrcode_geom>
PUBLIC	??_GCSkeletonWallmark@@QAEPAXI@Z		; CSkeletonWallmark::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@VCSkeletonWallmark@@@@QAEXAAPAVCSkeletonWallmark@@@Z ; xr_special_free<0,CSkeletonWallmark>::operator()
PUBLIC	??$construct@ULIT@FVF@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@$$QAU34@@Z ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT>
PUBLIC	??$forward@ULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z ; std::forward<FVF::LIT>
PUBLIC	??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@$$QAV3@@Z ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$forward@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$xr_delete@VCSkeletonWallmark@@@@YAXAAPAVCSkeletonWallmark@@@Z ; xr_delete<CSkeletonWallmark>
PUBLIC	??$_Destroy_in_place@PAULIT@FVF@@@std@@YAXAAPAULIT@FVF@@@Z ; std::_Destroy_in_place<FVF::LIT *>
PUBLIC	??$_Destroy_in_place@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z ; std::_Destroy_in_place<WallmarksEngine::wm_slot * *>
PUBLIC	??$_Destroy_in_place@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::_Destroy_in_place<intrusive_ptr<CSkeletonWallmark,intrusive_base> *>
PUBLIC	??$_Refancy@PAPAUwm_slot@WallmarksEngine@@$0A@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z ; std::_Refancy<WallmarksEngine::wm_slot * *,0>
PUBLIC	??$_Emplace_back@ULIT@FVF@@@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEX$$QAULIT@FVF@@@Z ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Emplace_back<FVF::LIT>
PUBLIC	??$move@AAULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z ; std::move<FVF::LIT &>
PUBLIC	??$_Emplace_back@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEX$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$move@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ; std::move<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
PUBLIC	??$construct@PAUstatic_wallmark@CWallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@$$QAPAU34@@Z ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark *>
PUBLIC	??$forward@PAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z ; std::forward<CWallmarksEngine::static_wallmark *>
PUBLIC	??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV3@@Z ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
PUBLIC	??$forward@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
PUBLIC	??$forward@PAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAPAUwm_slot@WallmarksEngine@@AAPAPAU12@@Z ; std::forward<WallmarksEngine::wm_slot * *>
PUBLIC	??$_Find_unchecked1@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@QAPAU12@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
PUBLIC	??0?$xalloc@ULIT@FVF@@@@QAE@XZ			; xalloc<FVF::LIT>::xalloc<FVF::LIT>
PUBLIC	?destroy@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@@Z ; xalloc<FVF::LIT>::destroy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<FVF::LIT> >::_Vector_val<std::_Simple_types<FVF::LIT> >
PUBLIC	?destroy@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@@Z ; xalloc<WallmarksEngine::wm_slot *>::destroy
PUBLIC	?destroy@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::destroy
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEXPBQAUwm_slot@WallmarksEngine@@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Seek_to
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@PAULIT@FVF@@AAV?$xalloc@ULIT@FVF@@@@@Z ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Uninitialized_backout_al<xalloc<FVF::LIT> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::~_Uninitialized_backout_al<xalloc<FVF::LIT> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@XZ ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Release
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1><>
PUBLIC	??$xr_alloc@ULIT@FVF@@@@YAPAULIT@FVF@@I@Z	; xr_alloc<FVF::LIT>
PUBLIC	??$xr_free@ULIT@FVF@@@@YAXAAPAULIT@FVF@@@Z	; xr_free<FVF::LIT>
PUBLIC	??$_Get_unwrapped@ABQAULIT@FVF@@@std@@YA?A_TABQAULIT@FVF@@@Z ; std::_Get_unwrapped<FVF::LIT * const &>
PUBLIC	??$_Uninitialized_move@PAULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@YAPAULIT@FVF@@QAU12@0PAU12@AAV?$xalloc@ULIT@FVF@@@@@Z ; std::_Uninitialized_move<FVF::LIT *,xalloc<FVF::LIT> >
PUBLIC	??$_Destroy_in_place@PAPAUstatic_wallmark@CWallmarksEngine@@@std@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z ; std::_Destroy_in_place<CWallmarksEngine::static_wallmark * *>
PUBLIC	??$_Uninitialized_move@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ; std::_Uninitialized_move<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??$destroy@ULIT@FVF@@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@@Z ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::destroy<FVF::LIT>
PUBLIC	??$_Emplace_back@PAUstatic_wallmark@CWallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEX$$QAPAUstatic_wallmark@CWallmarksEngine@@@Z ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back<CWallmarksEngine::static_wallmark *>
PUBLIC	??$move@AAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z ; std::move<CWallmarksEngine::static_wallmark * &>
PUBLIC	??$_Emplace_back@PAUwm_slot@WallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back<WallmarksEngine::wm_slot *>
PUBLIC	??$_Emplace_back@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
PUBLIC	??$destroy@PAUwm_slot@WallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@@Z ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::destroy<WallmarksEngine::wm_slot *>
PUBLIC	??$destroy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::destroy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@$$QAPAPAUwm_slot@WallmarksEngine@@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,WallmarksEngine::wm_slot * *>
PUBLIC	??$_Find_unchecked@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::_Find_unchecked<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > >
PUBLIC	?set@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAEXABV1@@Z ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::set
PUBLIC	?dec@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IAEXXZ ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::dec
PUBLIC	?max_size@?$xalloc@ULIT@FVF@@@@QBEIXZ		; xalloc<FVF::LIT>::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULIT@FVF@@@@XZ ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAIABV?$xalloc@ULIT@FVF@@@@@Z ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::max_size
PUBLIC	??0?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::vector<FVF::LIT,xalloc<FVF::LIT> >
PUBLIC	?capacity@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00U?$integral_constant@_N$00@2@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept1
PUBLIC	?_Tidy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Tidy
PUBLIC	?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEABV?$xalloc@ULIT@FVF@@@@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal
PUBLIC	??1wm_slot@WallmarksEngine@@QAE@XZ		; WallmarksEngine::wm_slot::~wm_slot
PUBLIC	??1static_wallmark@CWallmarksEngine@@QAE@XZ	; CWallmarksEngine::static_wallmark::~static_wallmark
PUBLIC	??_Gwm_slot@WallmarksEngine@@QAEPAXI@Z		; WallmarksEngine::wm_slot::`scalar deleting destructor'
PUBLIC	??_Gstatic_wallmark@CWallmarksEngine@@QAEPAXI@Z	; CWallmarksEngine::static_wallmark::`scalar deleting destructor'
PUBLIC	?allocate@?$xalloc@ULIT@FVF@@@@QBEPAULIT@FVF@@IPBX@Z ; xalloc<FVF::LIT>::allocate
PUBLIC	?deallocate@?$xalloc@ULIT@FVF@@@@QBEXPAULIT@FVF@@I@Z ; xalloc<FVF::LIT>::deallocate
PUBLIC	?construct@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@ABU23@@Z ; xalloc<FVF::LIT>::construct
PUBLIC	??1?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::~vector<FVF::LIT,xalloc<FVF::LIT> >
PUBLIC	?max_size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::max_size
PUBLIC	?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEII@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXQAULIT@FVF@@II@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Change_array
PUBLIC	?_Xlength@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@CAXXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Xlength
PUBLIC	??0?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::xr_vector<FVF::LIT,xalloc<FVF::LIT> >
PUBLIC	??0?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAE@XZ ; xalloc<CWallmarksEngine::static_wallmark *>::xalloc<CWallmarksEngine::static_wallmark *>
PUBLIC	?construct@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@ABQAU23@@Z ; xalloc<CWallmarksEngine::static_wallmark *>::construct
PUBLIC	?destroy@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@@Z ; xalloc<CWallmarksEngine::static_wallmark *>::destroy
PUBLIC	?_Umove@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU34@00@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEII@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >
PUBLIC	??0?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAE@XZ ; xalloc<WallmarksEngine::wm_slot *>::xalloc<WallmarksEngine::wm_slot *>
PUBLIC	?construct@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@ABQAU23@@Z ; xalloc<WallmarksEngine::wm_slot *>::construct
PUBLIC	?_Umove@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEPAPAUwm_slot@WallmarksEngine@@PAPAU34@00@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove
PUBLIC	?_Calculate_growth@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEII@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >
PUBLIC	??0?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAE@XZ ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	?construct@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV2@@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::construct
PUBLIC	?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove
PUBLIC	?_Calculate_growth@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEII@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Calculate_growth
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEPAPAUwm_slot@WallmarksEngine@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Unwrapped
PUBLIC	??R?$xr_special_free@$0A@Uwm_slot@WallmarksEngine@@@@QAEXAAPAUwm_slot@WallmarksEngine@@@Z ; xr_special_free<0,WallmarksEngine::wm_slot>::operator()
PUBLIC	??R?$xr_special_free@$0A@Ustatic_wallmark@CWallmarksEngine@@@@QAEXAAPAUstatic_wallmark@CWallmarksEngine@@@Z ; xr_special_free<0,CWallmarksEngine::static_wallmark>::operator()
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::~_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@XZ ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::~_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@XZ ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Release
PUBLIC	??1?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::~xr_vector<FVF::LIT,xalloc<FVF::LIT> >
PUBLIC	??0static_wallmark@CWallmarksEngine@@QAE@XZ	; CWallmarksEngine::static_wallmark::static_wallmark
PUBLIC	??$_Destroy_range@V?$xalloc@ULIT@FVF@@@@@std@@YAXPAULIT@FVF@@QAU12@AAV?$xalloc@ULIT@FVF@@@@@Z ; std::_Destroy_range<xalloc<FVF::LIT> >
PUBLIC	??$_Get_unwrapped@ABQAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA?A_TABQAPAUstatic_wallmark@CWallmarksEngine@@@Z ; std::_Get_unwrapped<CWallmarksEngine::static_wallmark * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ; std::_Uninitialized_move<CWallmarksEngine::static_wallmark * *,xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	??$_Get_unwrapped@ABQAPAUwm_slot@WallmarksEngine@@@std@@YA?A_TABQAPAUwm_slot@WallmarksEngine@@@Z ; std::_Get_unwrapped<WallmarksEngine::wm_slot * * const &>
PUBLIC	??$_Uninitialized_move@PAPAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ; std::_Uninitialized_move<WallmarksEngine::wm_slot * *,xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	??$_Get_unwrapped@ABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA?A_TABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::_Get_unwrapped<intrusive_ptr<CSkeletonWallmark,intrusive_base> * const &>
PUBLIC	??$_Uninitialized_copy@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ; std::_Uninitialized_copy<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??$xr_alloc@PAUstatic_wallmark@CWallmarksEngine@@@@YAPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ; xr_alloc<CWallmarksEngine::static_wallmark *>
PUBLIC	??$xr_free@PAUstatic_wallmark@CWallmarksEngine@@@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z ; xr_free<CWallmarksEngine::static_wallmark *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAXPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ; std::_Destroy_range<xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	??$xr_alloc@PAUwm_slot@WallmarksEngine@@@@YAPAPAUwm_slot@WallmarksEngine@@I@Z ; xr_alloc<WallmarksEngine::wm_slot *>
PUBLIC	??$xr_free@PAUwm_slot@WallmarksEngine@@@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z ; xr_free<WallmarksEngine::wm_slot *>
PUBLIC	??$_Destroy_range@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAXPAPAUwm_slot@WallmarksEngine@@QAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ; std::_Destroy_range<xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	??$xr_alloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ; xr_alloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$xr_free@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; xr_free<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$_Destroy_range@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ; std::_Destroy_range<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1><>
PUBLIC	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
PUBLIC	??$construct@ULIT@FVF@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@ABU34@@Z ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT const &>
PUBLIC	??$_Unfancy@ULIT@FVF@@@std@@YAPAULIT@FVF@@PAU12@@Z ; std::_Unfancy<FVF::LIT>
PUBLIC	??$forward@ABULIT@FVF@@@std@@YAABULIT@FVF@@ABU12@@Z ; std::forward<FVF::LIT const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
PUBLIC	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
PUBLIC	??$construct@PAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@ABQAU34@@Z ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark * const &>
PUBLIC	??$forward@ABQAUstatic_wallmark@CWallmarksEngine@@@std@@YAABQAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@Z ; std::forward<CWallmarksEngine::static_wallmark * const &>
PUBLIC	??$destroy@PAUstatic_wallmark@CWallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@@Z ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::destroy<CWallmarksEngine::static_wallmark *>
PUBLIC	??$_Unfancy@PAUstatic_wallmark@CWallmarksEngine@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU12@@Z ; std::_Unfancy<CWallmarksEngine::static_wallmark *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
PUBLIC	??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>
PUBLIC	??$construct@PAUwm_slot@WallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@$$QAPAU34@@Z ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::construct<WallmarksEngine::wm_slot *,WallmarksEngine::wm_slot *>
PUBLIC	??$_Unfancy@PAUwm_slot@WallmarksEngine@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z ; std::_Unfancy<WallmarksEngine::wm_slot *>
PUBLIC	??$forward@PAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z ; std::forward<WallmarksEngine::wm_slot *>
PUBLIC	??$move@AAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z ; std::move<WallmarksEngine::wm_slot * &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
PUBLIC	??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
PUBLIC	??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV3@@Z ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
PUBLIC	??$_Unfancy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV1@@Z ; std::_Unfancy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
PUBLIC	??$forward@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@Z ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
PUBLIC	??$xr_new@Ustatic_wallmark@CWallmarksEngine@@@@YAPAUstatic_wallmark@CWallmarksEngine@@XZ ; xr_new<CWallmarksEngine::static_wallmark>
PUBLIC	??$xr_delete@Ustatic_wallmark@CWallmarksEngine@@@@YAXAAPAUstatic_wallmark@CWallmarksEngine@@@Z ; xr_delete<CWallmarksEngine::static_wallmark>
PUBLIC	??$xr_delete@Uwm_slot@WallmarksEngine@@@@YAXAAPAUwm_slot@WallmarksEngine@@@Z ; xr_delete<WallmarksEngine::wm_slot>
PUBLIC	??$xr_new@Uwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; xr_new<WallmarksEngine::wm_slot,resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > const &>
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > &>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@V10@V10@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,resptr_core<Shader,resptrcode_shader> >
PUBLIC	??$?8UShader@@U0@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ; operator==<Shader,Shader,resptrcode_shader>
PUBLIC	??7?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBE_NXZ ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator!
PUBLIC	??C?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBEPAVCSkeletonWallmark@@XZ ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator->
PUBLIC	??1?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@XZ ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::~intrusive_ptr<CSkeletonWallmark,intrusive_base>
PUBLIC	??0?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@ABV0@@Z ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::intrusive_ptr<CSkeletonWallmark,intrusive_base>
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Verify_offset
PUBLIC	?_Destroy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@0@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Destroy
PUBLIC	?max_size@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEIXZ ; xalloc<CWallmarksEngine::static_wallmark *>::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00U?$integral_constant@_N$00@2@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEIXZ ; xalloc<WallmarksEngine::wm_slot *>::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00U?$integral_constant@_N$00@2@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first
PUBLIC	?max_size@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEIXZ ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00U?$integral_constant@_N$0A@@2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept1
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=
PUBLIC	?clear@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::clear
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULIT@FVF@@@@XZ ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first
PUBLIC	?allocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEPAPAUstatic_wallmark@CWallmarksEngine@@IPBX@Z ; xalloc<CWallmarksEngine::static_wallmark *>::allocate
PUBLIC	?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ; xalloc<CWallmarksEngine::static_wallmark *>::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::max_size
PUBLIC	?clear@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Destroy
PUBLIC	?_Change_array@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXQAPAUstatic_wallmark@CWallmarksEngine@@II@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Change_array
PUBLIC	?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first
PUBLIC	?allocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEPAPAUwm_slot@WallmarksEngine@@IPBX@Z ; xalloc<WallmarksEngine::wm_slot *>::allocate
PUBLIC	?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z ; xalloc<WallmarksEngine::wm_slot *>::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::max_size
PUBLIC	?clear@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@0@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Destroy
PUBLIC	?_Change_array@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXQAPAUwm_slot@WallmarksEngine@@II@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Change_array
PUBLIC	?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first
PUBLIC	?allocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IPBX@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::allocate
PUBLIC	?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::deallocate
PUBLIC	?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAIABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size
PUBLIC	?clear@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear
PUBLIC	?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Destroy
PUBLIC	?_Change_array@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@II@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Change_array
PUBLIC	?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Compat
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Compat
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Compat
PUBLIC	?size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::size
PUBLIC	?_Orphan_range@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEXPAULIT@FVF@@0@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Orphan_range
PUBLIC	?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEAAV?$xalloc@ULIT@FVF@@@@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear_and_free
PUBLIC	??0?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
PUBLIC	?size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size
PUBLIC	?max_size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::max_size
PUBLIC	?capacity@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::capacity
PUBLIC	?_Tidy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@CAXXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear_and_free
PUBLIC	??0?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::max_size
PUBLIC	?capacity@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::capacity
PUBLIC	?_Tidy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@CAXXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEXPAPAUwm_slot@WallmarksEngine@@0@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear_and_free
PUBLIC	??0?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size
PUBLIC	?capacity@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::capacity
PUBLIC	?_Tidy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@CAXXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Xlength
PUBLIC	?_Orphan_range@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal
PUBLIC	?clear_and_free@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear_and_free
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEABQAUwm_slot@WallmarksEngine@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator==
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEABQAUstatic_wallmark@CWallmarksEngine@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator==
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEABULIT@FVF@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator==
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
PUBLIC	?set@?$_vector2@M@@QAEAAU1@ABU1@@Z		; _vector2<float>::set
PUBLIC	?rotateZ@?$_matrix@M@@QAEAAU1@M@Z		; _matrix<float>::rotateZ
PUBLIC	?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera
PUBLIC	?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera_dir
PUBLIC	??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@ABV0@@Z ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAE?A_TABULIT@FVF@@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_back_with_unused_capacity<FVF::LIT const &>
PUBLIC	??$emplace_back@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?A_TABULIT@FVF@@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::emplace_back<FVF::LIT const &>
PUBLIC	?push_back@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXABULIT@FVF@@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::push_back
PUBLIC	?begin@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::begin
PUBLIC	?end@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::end
PUBLIC	?size@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QBEIXZ ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::size
PUBLIC	?clear@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear
PUBLIC	??1?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back_with_unused_capacity<CWallmarksEngine::static_wallmark * const &>
PUBLIC	??$emplace_back@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::emplace_back<CWallmarksEngine::static_wallmark * const &>
PUBLIC	?push_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXABQAUstatic_wallmark@CWallmarksEngine@@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::push_back
PUBLIC	?reserve@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::reserve
PUBLIC	?pop_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::pop_back
PUBLIC	?begin@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::begin
PUBLIC	?end@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::end
PUBLIC	?empty@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBE_NXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::empty
PUBLIC	?back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@XZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::back
PUBLIC	??0?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	?size@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QBEIXZ ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size
PUBLIC	?clear@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear
PUBLIC	??A?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@I@Z ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::operator[]
PUBLIC	??1?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back_with_unused_capacity<WallmarksEngine::wm_slot *>
PUBLIC	??$emplace_back@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::emplace_back<WallmarksEngine::wm_slot *>
PUBLIC	?push_back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::push_back
PUBLIC	?reserve@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::reserve
PUBLIC	?begin@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::begin
PUBLIC	?end@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::end
PUBLIC	?back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEAAPAUwm_slot@WallmarksEngine@@XZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::back
PUBLIC	??0?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	?clear@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear
PUBLIC	??1?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back_with_unused_capacity<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
PUBLIC	??$emplace_back@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
PUBLIC	?push_back@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::push_back
PUBLIC	?reserve@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::reserve
PUBLIC	?begin@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::begin
PUBLIC	?end@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::end
PUBLIC	??0?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	?clear@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEAAPAUwm_slot@WallmarksEngine@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEAAPAUstatic_wallmark@CWallmarksEngine@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEAAULIT@FVF@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++
PUBLIC	?Render@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::Render
PUBLIC	?FlushStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAIAAPAULIT@FVF@@3H@Z ; FlushStream
PUBLIC	?BeginStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@AAIAAPAULIT@FVF@@2@Z ; BeginStream
PUBLIC	?AddSkeletonWallmark@CWallmarksEngine@@QAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ; CWallmarksEngine::AddSkeletonWallmark
PUBLIC	?AddSkeletonWallmark@CWallmarksEngine@@QAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z ; CWallmarksEngine::AddSkeletonWallmark
PUBLIC	?AddStaticWallmark@CWallmarksEngine@@QAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ; CWallmarksEngine::AddStaticWallmark
PUBLIC	?AddWallmark_internal@CWallmarksEngine@@AAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ; CWallmarksEngine::AddWallmark_internal
PUBLIC	?BuildMatrix@CWallmarksEngine@@AAEXAAU?$_matrix@M@@MABU?$_vector3@M@@@Z ; CWallmarksEngine::BuildMatrix
PUBLIC	?RecurseTri@CWallmarksEngine@@AAEXIAAU?$_matrix@M@@AAUstatic_wallmark@1@@Z ; CWallmarksEngine::RecurseTri
PUBLIC	?static_wm_render@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@AAPAULIT@FVF@@@Z ; CWallmarksEngine::static_wm_render
PUBLIC	?static_wm_destroy@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@@Z ; CWallmarksEngine::static_wm_destroy
PUBLIC	?static_wm_allocate@CWallmarksEngine@@AAEPAUstatic_wallmark@1@XZ ; CWallmarksEngine::static_wm_allocate
PUBLIC	?clear@CWallmarksEngine@@QAEXXZ			; CWallmarksEngine::clear
PUBLIC	??1CWallmarksEngine@@QAE@XZ			; CWallmarksEngine::~CWallmarksEngine
PUBLIC	??1?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
PUBLIC	??0CWallmarksEngine@@QAE@XZ			; CWallmarksEngine::CWallmarksEngine
PUBLIC	?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::AppendSlot
PUBLIC	?FindSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::FindSlot
PUBLIC	??8@YA_NPBUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; operator==
PUBLIC	??1?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
PUBLIC	??1?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
PUBLIC	??0wm_slot@WallmarksEngine@@QAE@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; WallmarksEngine::wm_slot::wm_slot
__ehfuncinfo$?Render@CWallmarksEngine@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Render@CWallmarksEngine@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?Render@CWallmarksEngine@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?Render@CWallmarksEngine@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Render@CWallmarksEngine@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Render@CWallmarksEngine@@QAEXXZ$2
__catchsym$?Render@CWallmarksEngine@@QAEXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Render@CWallmarksEngine@@QAEXXZ$0
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z$2
__catchsym$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z$2
__catchsym$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z$2
__catchsym$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z$2
__catchsym$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z$2
__catchsym$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z$0
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
;	COMDAT ??0wm_slot@WallmarksEngine@@QAE@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
_sh$ = 8						; size = 4
??0wm_slot@WallmarksEngine@@QAE@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; WallmarksEngine::wm_slot::wm_slot, COMDAT
; _this$ = ecx

; 22   : 						wm_slot		(ref_shader sh)	{shader=sh;static_items.reserve(256);skeleton_items.reserve(256);}

	push	ebx
	mov	ebx, ecx
	push	ebp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	ebp, DWORD PTR _sh$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 22   : 						wm_slot		(ref_shader sh)	{shader=sh;static_items.reserve(256);skeleton_items.reserve(256);}

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 22   : 						wm_slot		(ref_shader sh)	{shader=sh;static_items.reserve(256);skeleton_items.reserve(256);}

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	ebp, ebp

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN28@wm_slot
	inc	DWORD PTR [ebp]
$LN28@wm_slot:
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR [ebx], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+4]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN31@wm_slot

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebx+4]
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN31@wm_slot:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+24]
	sub	eax, DWORD PTR [ebx+16]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN38@wm_slot

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebx+16]
	call	?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly
$LN38@wm_slot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _sh$[esp+12]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 22   : 						wm_slot		(ref_shader sh)	{shader=sh;static_items.reserve(256);skeleton_items.reserve(256);}

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??0wm_slot@WallmarksEngine@@QAE@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; WallmarksEngine::wm_slot::wm_slot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ PROC ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ ENDP ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
;	COMDAT ??8@YA_NPBUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
??8@YA_NPBUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; operator==, COMDAT
; _slot$ = ecx
; _shader$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 33   : IC bool operator == (const CWallmarksEngine::wm_slot* slot, const ref_shader& shader){return slot->shader==shader;}

	ret	0
??8@YA_NPBUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_shader$ = 8						; size = 4
?FindSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; CWallmarksEngine::FindSlot
; _this$ = ecx

; 35   : {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5227 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	esi, DWORD PTR [ecx+16]

; 5221 :     return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});

	mov	ecx, DWORD PTR [ecx+12]

; 5185 :     for (; _First != _Last; ++_First) {

	cmp	ecx, esi
	je	SHORT $LN3@FindSlot
	mov	eax, DWORD PTR _shader$[esp]
	npad	1
$LL24@FindSlot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edx, DWORD PTR [ecx]

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	cmp	DWORD PTR [edx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5186 :         if (*_First == _Val) {

	je	SHORT $LN52@FindSlot

; 5185 :     for (; _First != _Last; ++_First) {

	add	ecx, 4
	cmp	ecx, esi
	jne	SHORT $LL24@FindSlot
$LN3@FindSlot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _shader$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 37   : 	return						(it!=marks.end())?*it:0;

	xor	esi, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 37   : 	return						(it!=marks.end())?*it:0;

	mov	eax, esi
	pop	esi

; 38   : }

	ret	4
$LN52@FindSlot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _shader$[esp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 37   : 	return						(it!=marks.end())?*it:0;

	mov	esi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 37   : 	return						(it!=marks.end())?*it:0;

	mov	eax, esi
	pop	esi

; 38   : }

	ret	4
?FindSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; CWallmarksEngine::FindSlot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -8						; size = 4
_this$1$ = -4						; size = 4
_shader$ = 8						; size = 4
?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; CWallmarksEngine::AppendSlot
; _this$ = ecx

; 40   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+24], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	esi, DWORD PTR _shader$[esp+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 75   : 	return new (ptr) T(p1);

	mov	ebx, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR $T1[esp+24], esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	esi, esi
	je	SHORT $LN7@AppendSlot
	inc	DWORD PTR [esi]
	mov	esi, DWORD PTR $T1[esp+24]
$LN7@AppendSlot:

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN37@AppendSlot
	inc	DWORD PTR [esi]
$LN37@AppendSlot:
	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR [ebx], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+4]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN40@AppendSlot

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebx+4]
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN40@AppendSlot:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebx+24]
	sub	eax, DWORD PTR [ebx+16]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN47@AppendSlot

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebx+16]
	call	?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly
$LN47@AppendSlot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 41   : 	marks.push_back				(xr_new<wm_slot>(shader));

	mov	esi, DWORD PTR _this$1$[esp+24]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 41   : 	marks.push_back				(xr_new<wm_slot>(shader));

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T2[esp+24], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $LN59@AppendSlot

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ebx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN58@AppendSlot
$LN59@AppendSlot:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR $T2[esp+24]
	push	edx
	push	eax
	call	??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>
$LN58@AppendSlot:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 42   : 	return marks.back			();

	mov	eax, DWORD PTR [esi+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _shader$[esp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 42   : 	return marks.back			();

	mov	esi, DWORD PTR [eax-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 43   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; CWallmarksEngine::AppendSlot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
??0CWallmarksEngine@@QAE@XZ PROC			; CWallmarksEngine::CWallmarksEngine
; _this$ = ecx

; 53   : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+1444]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 21   : 	svector() : count(0) 

	mov	DWORD PTR [esi+860], 0
	mov	DWORD PTR [esi+1440], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrXRC@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??0Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1504]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [esi+1492], 0
	mov	DWORD PTR [esi+1496], 0
	mov	DWORD PTR [esi+1500], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 53   : {

	call	DWORD PTR __imp_??0xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN34@CWallmarks

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	mov	ecx, esi
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN34@CWallmarks:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN41@CWallmarks

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly
$LN41@CWallmarks:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 56   : 	hGeom.create			(FVF::F_LIT, RCache.Vertex.Buffer(), NULL);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	ecx, DWORD PTR [esi+24]
	push	0
	push	DWORD PTR [eax]
	push	322					; 00000142H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z

; 57   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	0
??0CWallmarksEngine@@QAE@XZ ENDP			; CWallmarksEngine::CWallmarksEngine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ PROC ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ ENDP ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
??1CWallmarksEngine@@QAE@XZ PROC			; CWallmarksEngine::~CWallmarksEngine
; _this$ = ecx

; 60   : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 61   : 	clear			();

	call	?clear@CWallmarksEngine@@QAEXXZ		; CWallmarksEngine::clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1504]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	DWORD PTR [esi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	call	DWORD PTR __imp_??1xrCriticalSection@@QAE@XZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+1492]
	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN13@CWallmarks
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+1492], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+1496], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+1500], 0
$LN13@CWallmarks:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_??1Collector@CDB@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1444]
	call	DWORD PTR __imp_??1xrXRC@@QAE@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR [esi+24]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN27@CWallmarks
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+12], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+20], 0
$LN27@CWallmarks:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN39@CWallmarks
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN39@CWallmarks:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 63   : }

	pop	esi
	pop	ebx
	ret	0
??1CWallmarksEngine@@QAE@XZ ENDP			; CWallmarksEngine::~CWallmarksEngine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_W$ = -4						; size = 4
?clear@CWallmarksEngine@@QAEXXZ PROC			; CWallmarksEngine::clear
; _this$ = ecx

; 66   : {

	push	ecx

; 68   : 		for (WMSlotVecIt p_it=marks.begin(); p_it!=marks.end(); p_it++){

	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	ebp, DWORD PTR [edi+12]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebp, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 68   : 		for (WMSlotVecIt p_it=marks.begin(); p_it!=marks.end(); p_it++){

	je	$LN3@clear
	npad	7
$LL4@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	ebx, DWORD PTR [ebp]

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 69   : 			for (StaticWMVecIt m_it=(*p_it)->static_items.begin(); m_it!=(*p_it)->static_items.end(); m_it++)

	je	SHORT $LN154@clear
	npad	5
$LL7@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 70   : 				static_wm_destroy	(*m_it);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _W$[esp+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN57@clear

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], ecx

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [edi+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN5@clear
$LN57@clear:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _W$[esp+20]
	push	ecx
	push	eax
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
$LN5@clear:

; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	ebx, DWORD PTR [ebp]

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 69   : 			for (StaticWMVecIt m_it=(*p_it)->static_items.begin(); m_it!=(*p_it)->static_items.end(); m_it++)

	jne	SHORT $LL7@clear
	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN154@clear:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	ebx, ebx
	je	SHORT $LN2@clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN76@clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [ebx+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [ebx+24], 0
$LN76@clear:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN88@clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [ebx+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [ebx+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [ebx+12], 0
$LN88@clear:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, ebx
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebp]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	esi

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebp], 0
$LN2@clear:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 68   : 		for (WMSlotVecIt p_it=marks.begin(); p_it!=marks.end(); p_it++){

	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	ebp, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	ebp, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 68   : 		for (WMSlotVecIt p_it=marks.begin(); p_it!=marks.end(); p_it++){

	jne	$LL4@clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 154  : 		ptr = nullptr;

	mov	ebp, DWORD PTR [edi+12]
$LN3@clear:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 73   : 		marks.clear	();

	mov	DWORD PTR [edi+16], ebp

; 76   : 		for (u32 it=0; it<static_pool.size(); it++)

	xor	ebx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 76   : 		for (u32 it=0; it<static_pool.size(); it++)

	test	eax, eax
	je	SHORT $LN157@clear
	npad	6
$LL10@clear:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [ecx+ebx*4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	lea	ebp, DWORD PTR [ecx+ebx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	esi, esi
	je	SHORT $LN8@clear
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN133@clear
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
	mov	esi, DWORD PTR [ebp]
$LN133@clear:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	mov	esi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	call	esi

; 154  : 		ptr = nullptr;

	mov	DWORD PTR [ebp], 0
$LN8@clear:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 76   : 		for (u32 it=0; it<static_pool.size(); it++)

	inc	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 76   : 		for (u32 it=0; it<static_pool.size(); it++)

	mov	edx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 76   : 		for (u32 it=0; it<static_pool.size(); it++)

	cmp	ebx, eax
	jb	SHORT $LL10@clear
$LN157@clear:

; 77   : 			xr_delete		(static_pool[it]);
; 78   : 		static_pool.clear	();
; 79   : 	}
; 80   : }

	mov	DWORD PTR [edi+4], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
?clear@CWallmarksEngine@@QAEXXZ ENDP			; CWallmarksEngine::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
?static_wm_allocate@CWallmarksEngine@@AAEPAUstatic_wallmark@1@XZ PROC ; CWallmarksEngine::static_wm_allocate
; _this$ = ecx

; 84   : {

	mov	edx, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 86   : 	if (static_pool.empty())  W = xr_new<static_wallmark> ();

	jne	SHORT $LN2@static_wm_
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 90   : 	W->verts.clear		();

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+28], 1133903872		; 43960000H
	mov	DWORD PTR [eax+20], ecx

; 91   : 	return W;
; 92   : }

	ret	0
$LN2@static_wm_:

; 87   : 	else					{ W = static_pool.back(); static_pool.pop_back(); }

	mov	eax, DWORD PTR [ecx-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	add	ecx, -4					; fffffffcH

; 1390 :         --_Mylast;

	mov	DWORD PTR [edx+4], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 90   : 	W->verts.clear		();

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+28], 1133903872		; 43960000H
	mov	DWORD PTR [eax+20], ecx

; 91   : 	return W;
; 92   : }

	ret	0
?static_wm_allocate@CWallmarksEngine@@AAEPAUstatic_wallmark@1@XZ ENDP ; CWallmarksEngine::static_wm_allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_W$ = 8							; size = 4
?static_wm_destroy@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@@Z PROC ; CWallmarksEngine::static_wm_destroy
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN6@static_wm_

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _W$[esp-4]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 97   : }

	ret	4
$LN6@static_wm_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _W$[esp-4]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 97   : }

	ret	4
?static_wm_destroy@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@@Z ENDP ; CWallmarksEngine::static_wm_destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_a$1 = 8						; size = 4
_W$ = 8							; size = 4
_V$ = 12						; size = 4
?static_wm_render@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@AAPAULIT@FVF@@@Z PROC ; CWallmarksEngine::static_wm_render
; _this$dead$ = ecx

; 101  : 	float		a		= 1-(W->ttl/ps_r__WallmarkTTL);
; 102  : 	int			aC		= iFloor	( a * 255.f);	clamp	(aC,0,255);

	movss	xmm0, DWORD PTR __real@437f0000
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	ecx, 158				; 0000009eH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 100  : {

	push	ebx

; 101  : 	float		a		= 1-(W->ttl/ps_r__WallmarkTTL);
; 102  : 	int			aC		= iFloor	( a * 255.f);	clamp	(aC,0,255);

	mov	ebx, DWORD PTR _W$[esp]
	push	esi
	push	edi
	movss	xmm1, DWORD PTR [ebx+28]
	mulss	xmm1, DWORD PTR __real@3f59999a
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$1[esp+8], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	esi, DWORD PTR _a$1[esp+8]
	mov	eax, esi
	sar	eax, 23					; 00000017H

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	edi, esi
	movzx	eax, al
	or	edi, -8388608				; ff800000H
	sub	ecx, eax
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	ecx, 96					; 00000060H

; 89   :         exponent	-=	(31-127)+32;
; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	mov	edx, esi
	shl	eax, cl
	dec	eax
	sar	edx, 31					; 0000001fH
	sar	eax, 8
	and	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax
	lea	eax, DWORD PTR [ecx+64]
	sar	eax, 31					; 0000001fH

; 93   :         r			&=	exponent;

	and	edi, eax
	xor	edi, edx
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN9@static_wm_
	xor	edi, edi
	jmp	SHORT $LN11@static_wm_
$LN9@static_wm_:
	mov	eax, 255				; 000000ffH
	cmp	edi, eax
	cmovg	edi, eax
$LN11@static_wm_:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 105  : 	FVF::LIT*	E		= &*W->verts.end	();

	mov	esi, DWORD PTR [ebx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	ecx, DWORD PTR [ebx+16]
	shl	edi, 24					; 00000018H
	or	edi, 8421504				; 00808080H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 106  : 	for (; S!=E; S++, V++){

	cmp	ecx, esi
	je	SHORT $LN3@static_wm_
	mov	edx, DWORD PTR _V$[esp+8]
$LL4@static_wm_:

; 107  : 		V->p.set		(S->p);

	mov	eax, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 108  : 		V->color		= C;

	mov	DWORD PTR [eax+12], edi

; 109  : 		V->t.set		(S->t);

	mov	eax, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 18   : 	IC SelfRef set(const Self &p)					{ x=p.x; y=p.y;					return *this;	}

	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	fld	DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 106  : 	for (; S!=E; S++, V++){

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 18   : 	IC SelfRef set(const Self &p)					{ x=p.x; y=p.y;					return *this;	}

	fstp	DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 106  : 	for (; S!=E; S++, V++){

	add	eax, 24					; 00000018H
	mov	DWORD PTR [edx], eax
	cmp	ecx, esi
	jne	SHORT $LL4@static_wm_
$LN3@static_wm_:
	pop	edi

; 110  : 	}
; 111  : }

	pop	esi
	pop	ebx
	ret	8
?static_wm_render@CWallmarksEngine@@AAEXPAUstatic_wallmark@1@AAPAULIT@FVF@@@Z ENDP ; CWallmarksEngine::static_wm_render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_i$1$ = -136						; size = 4
_T$1$ = -136						; size = 4
_v_data$1$ = -132					; size = 4
_test_normal$1$sroa$825$1$ = -128			; size = 4
_V0$4$ = -128						; size = 4
_V1$2 = -124						; size = 24
tv1725 = -100						; size = 4
_this$1$ = -96						; size = 4
_V0$5$ = -92						; size = 4
_V0$2$ = -88						; size = 4
_V0$3$ = -84						; size = 4
_V0$6$ = -80						; size = 4
tv1611 = -76						; size = 4
tv1612 = -72						; size = 4
tv1613 = -68						; size = 4
tv1614 = -64						; size = 4
tv1615 = -60						; size = 4
_P$1$ = -56						; size = 4
tv1750 = -52						; size = 4
_V0$3 = -48						; size = 24
_V2$4 = -24						; size = 24
_t$ = 8							; size = 4
_mView$ = 12						; size = 4
_W$ = 16						; size = 4
?RecurseTri@CWallmarksEngine@@AAEXIAAU?$_matrix@M@@AAUstatic_wallmark@1@@Z PROC ; CWallmarksEngine::RecurseTri
; _this$ = ecx

; 114  : {

	sub	esp, 136				; 00000088H
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+152], ebp

; 115  : 	CDB::TRI*	T			= sml_collector.getT()+t;

	lea	esi, DWORD PTR [ebp+1468]
	mov	ecx, esi
	mov	DWORD PTR tv1750[esp+152], esi
	call	DWORD PTR __imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ
	mov	ebx, eax
	mov	eax, DWORD PTR _t$[esp+148]
	shl	eax, 4
	add	ebx, eax
	mov	DWORD PTR _T$1$[esp+152], ebx

; 116  : 	if (T->dummy)			return;

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN6@RecurseTri

; 117  : 	T->dummy				= 0xffffffff;
; 118  : 	
; 119  : 	// Some vars
; 120  : 	u32*		v_ids		= T->verts;
; 121  : 	Fvector*	v_data		= sml_collector.getV();

	mov	ecx, esi
	mov	DWORD PTR [ebx+12], -1
	call	DWORD PTR __imp_?getV@Collector@CDB@@QAEPAU?$_vector3@M@@XZ

; 122  : 	sml_poly_src.clear		();

	mov	DWORD PTR [ebp+1440], 0

; 123  : 	sml_poly_src.push_back	(v_data[v_ids[0]]);

	mov	ecx, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebp+864]
	mov	DWORD PTR _v_data$1$[esp+152], eax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [eax+ecx*4+4]
	mov	ecx, DWORD PTR [eax+ecx*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [ebx+576]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ebx+eax*4], edx
	mov	DWORD PTR [ebx+eax*4+4], esi
	mov	DWORD PTR [ebx+eax*4+8], ecx
	inc	DWORD PTR [ebx+576]
	mov	edi, DWORD PTR [ebx+576]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 124  : 	sml_poly_src.push_back	(v_data[v_ids[1]]);

	mov	eax, DWORD PTR _T$1$[esp+152]
	mov	esi, DWORD PTR _v_data$1$[esp+152]
	mov	eax, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	edx, DWORD PTR [esi+eax*4+4]
	mov	esi, DWORD PTR [esi+eax*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	lea	eax, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [ebx+eax*4], ecx
	mov	DWORD PTR [ebx+eax*4+4], edx
	mov	DWORD PTR [ebx+eax*4+8], esi
	inc	DWORD PTR [ebx+576]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 125  : 	sml_poly_src.push_back	(v_data[v_ids[2]]);

	mov	eax, DWORD PTR _T$1$[esp+152]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	edi, DWORD PTR [ebx+576]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 125  : 	sml_poly_src.push_back	(v_data[v_ids[2]]);

	mov	esi, DWORD PTR _v_data$1$[esp+152]
	mov	eax, DWORD PTR [eax+8]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	ecx, DWORD PTR [esi+eax*4]
	mov	edx, DWORD PTR [esi+eax*4+4]
	mov	esi, DWORD PTR [esi+eax*4+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	lea	eax, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [ebx+eax*4], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 128  : 	sPoly* P = sml_clipper.ClipPoly	(sml_poly_src, sml_poly_dest);

	lea	ecx, DWORD PTR [ebp+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	DWORD PTR [ebx+eax*4+4], edx
	mov	DWORD PTR [ebx+eax*4+8], esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 128  : 	sPoly* P = sml_clipper.ClipPoly	(sml_poly_src, sml_poly_dest);

	lea	eax, DWORD PTR [ebp+284]
; File I:\Vitalya\mine\NSProjectX\xrCore\FixedVector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	inc	DWORD PTR [ebx+576]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 128  : 	sPoly* P = sml_clipper.ClipPoly	(sml_poly_src, sml_poly_dest);

	push	eax
	push	ebx
	mov	DWORD PTR [ebp+860], 0
	call	DWORD PTR __imp_?ClipPoly@CFrustum@@QBEPAV?$svector@U?$_vector3@M@@$0DA@@@AAV2@0@Z
	mov	ecx, eax
	mov	DWORD PTR _P$1$[esp+152], ecx

; 129  : 	
; 130  : 	//. todo
; 131  : 	// uv_gen = mView * []
; 132  : 	// UV = pos*uv_gen
; 133  : 
; 134  : 	if (P) {

	test	ecx, ecx
	je	$LN6@RecurseTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	eax, DWORD PTR _mView$[esp+148]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	xor	edx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 144  : 		for (u32 i=2; i<P->size(); i++)

	cmp	DWORD PTR [ecx+576], 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+16]
	movss	xmm3, DWORD PTR [ecx+8]
	mulss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR _V0$3[esp+164], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR _V1$2[esp+164], edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 142  : 		V1.set				((*P)[1],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	movss	xmm5, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V0$3[esp+156], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V0$3[esp+152], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 144  : 		for (u32 i=2; i<P->size(); i++)

	mov	DWORD PTR _i$1$[esp+152], 2
	movss	xmm6, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V0$3[esp+160], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm0, DWORD PTR [eax+48]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm4

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm4, DWORD PTR [ecx+12]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V1$2[esp+152], xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 140  : 		V0.set				((*P)[0],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	addss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _V0$3[esp+168], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, xmm2

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm2, DWORD PTR [ecx+16]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V1$2[esp+156], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+36]
	mulss	xmm0, xmm3

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movss	xmm3, DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V1$2[esp+160], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm0, DWORD PTR [eax+52]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm4, DWORD PTR [eax+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 140  : 		V0.set				((*P)[0],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	mulss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _V0$3[esp+172], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+16]

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	mulss	xmm2, DWORD PTR [eax+20]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+32]
	mulss	xmm3, DWORD PTR [eax+36]
	addss	xmm4, xmm2
	addss	xmm0, DWORD PTR [eax+48]
	addss	xmm3, DWORD PTR [eax+52]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movaps	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	addss	xmm4, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 142  : 		V1.set				((*P)[1],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	addss	xmm1, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	subss	xmm0, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 142  : 		V1.set				((*P)[1],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	mulss	xmm1, DWORD PTR __real@3f000000
	mulss	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _V1$2[esp+168], xmm1
	movss	DWORD PTR _V1$2[esp+172], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 144  : 		for (u32 i=2; i<P->size(); i++)

	jbe	$LN3@RecurseTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mov	ebp, DWORD PTR _V0$3[esp+168]
	lea	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _V0$3[esp+172]
	mov	ebx, DWORD PTR _W$[esp+148]
	mov	edi, DWORD PTR _V1$2[esp+172]
	mov	DWORD PTR _V0$6$[esp+152], ebp
	mov	ebp, DWORD PTR _V0$3[esp+160]
	mov	DWORD PTR _V0$3$[esp+152], ebp
	mov	ebp, DWORD PTR _V0$3[esp+156]
	mov	DWORD PTR _V0$2$[esp+152], ebp
	mov	ebp, DWORD PTR _V0$3[esp+152]
	mov	DWORD PTR _V0$5$[esp+152], ebp
	mov	ebp, DWORD PTR _mView$[esp+148]
	mov	DWORD PTR tv1725[esp+152], eax
	mov	DWORD PTR _V0$4$[esp+152], ecx
	npad	8
$LL4@RecurseTri:
	movss	xmm3, DWORD PTR [eax-4]
	movss	xmm2, DWORD PTR [eax-8]
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [ebp+16]
	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR _V2$4[esp+164], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	mulss	xmm0, DWORD PTR [ebp]
	movss	xmm4, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ebp+32]
	movss	DWORD PTR tv1612[esp+152], xmm3
	movss	DWORD PTR tv1611[esp+152], xmm2
	addss	xmm0, DWORD PTR [ebp+48]
	movss	DWORD PTR tv1613[esp+152], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR _V2$4[esp+152], xmm2
	movss	DWORD PTR _V2$4[esp+156], xmm3
	movss	DWORD PTR _V2$4[esp+160], xmm4
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ebp+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 147  : 			V2.set				((*P)[i],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	addss	xmm1, xmm5
	mulss	xmm1, xmm6
	movss	DWORD PTR tv1614[esp+152], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _V2$4[esp+168], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ebp+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ebp+36]
	addss	xmm0, DWORD PTR [ebp+52]
	addss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movaps	xmm0, xmm5
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 147  : 			V2.set				((*P)[i],0,(1+UV.x)*.5f,(1-UV.y)*.5f);

	mulss	xmm0, xmm6
	movss	DWORD PTR tv1615[esp+152], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR _V2$4[esp+172], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ebx+24]
	je	SHORT $LN85@RecurseTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ebp, DWORD PTR _V0$5$[esp+152]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR _V0$2$[esp+152]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR _V0$3$[esp+152]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR _V0$6$[esp+152]
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], ebp
	mov	DWORD PTR [eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+20], 24			; 00000018H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN161@RecurseTri
$LN85@RecurseTri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _V0$3[esp+152]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
	mov	edx, DWORD PTR _V1$2[esp+164]
$LN161@RecurseTri:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [ebx+24]
	je	SHORT $LN96@RecurseTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _V1$2[esp+152]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _V1$2[esp+156]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _V1$2[esp+160]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _V1$2[esp+168]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+20], 24			; 00000018H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN162@RecurseTri
$LN96@RecurseTri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _V1$2[esp+152]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
$LN162@RecurseTri:

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, DWORD PTR [ebx+24]
	je	SHORT $LN107@RecurseTri
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	movss	xmm0, DWORD PTR tv1611[esp+152]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR tv1612[esp+152]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR tv1613[esp+152]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR tv1614[esp+152]
	mov	DWORD PTR [eax+12], 0
	movss	DWORD PTR [eax+16], xmm0
	movss	xmm0, DWORD PTR tv1615[esp+152]
	movss	DWORD PTR [eax+20], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+20], 24			; 00000018H

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN106@RecurseTri
$LN107@RecurseTri:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _V2$4[esp+152]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+16]
	call	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
$LN106@RecurseTri:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 151  : 			V1					= V2;

	mov	eax, DWORD PTR _V2$4[esp+152]
	xor	edx, edx
	mov	ebp, DWORD PTR _P$1$[esp+152]
	mov	ecx, DWORD PTR _i$1$[esp+152]
	mov	edi, DWORD PTR _V2$4[esp+172]
	inc	ecx
	movss	xmm5, DWORD PTR __real@3f800000
	movss	xmm6, DWORD PTR __real@3f000000
	mov	DWORD PTR _V1$2[esp+152], eax
	mov	eax, DWORD PTR _V2$4[esp+156]
	mov	DWORD PTR _V1$2[esp+156], eax
	mov	eax, DWORD PTR _V2$4[esp+160]
	mov	DWORD PTR _V1$2[esp+160], eax
	mov	eax, DWORD PTR _V2$4[esp+168]
	mov	DWORD PTR _V1$2[esp+168], eax
	mov	eax, DWORD PTR tv1725[esp+152]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _i$1$[esp+152], ecx
	cmp	ecx, DWORD PTR [ebp+576]
	mov	ebp, DWORD PTR _mView$[esp+148]
	mov	ecx, DWORD PTR _V0$4$[esp+152]
	mov	DWORD PTR _V1$2[esp+164], edx
	mov	DWORD PTR _V1$2[esp+172], edi
	mov	DWORD PTR tv1725[esp+152], eax
	jb	$LL4@RecurseTri
	mov	ebp, DWORD PTR _this$1$[esp+152]
$LN3@RecurseTri:

; 152  : 		}
; 153  : 		
; 154  : 		// recurse
; 155  : 		for (i=0; i<3; i++)

	mov	eax, DWORD PTR _t$[esp+148]
	mov	ebx, 3
	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 2
$LL7@RecurseTri:

; 156  : 		{
; 157  : 			u32 adj					= sml_adjacency[3*t+i];

	mov	eax, DWORD PTR [ebp+1492]
	mov	edi, DWORD PTR [esi+eax]

; 158  : 			if (0xffffffff==adj)	continue;

	cmp	edi, -1
	je	$LN5@RecurseTri

; 159  : 			CDB::TRI*	SML			= sml_collector.getT() + adj;

	mov	ecx, DWORD PTR tv1750[esp+152]
	call	DWORD PTR __imp_?getT@Collector@CDB@@QAEPAVTRI@2@XZ
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	ebp, DWORD PTR _v_data$1$[esp+152]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 159  : 			CDB::TRI*	SML			= sml_collector.getT() + adj;

	mov	ecx, edi
	shl	ecx, 4
	add	eax, ecx

; 163  : 			test_normal.mknormal	(v_data[v_ids[0]],v_data[v_ids[1]],v_data[v_ids[2]]);

	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ecx+ecx*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [ebp+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 163  : 			test_normal.mknormal	(v_data[v_ids[0]],v_data[v_ids[1]],v_data[v_ids[2]]);

	lea	eax, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [ebp+ecx*4+4]
	movaps	xmm6, xmm2
	movss	xmm0, DWORD PTR [ebp+ecx*4+8]
	movaps	xmm5, xmm1
	subss	xmm5, DWORD PTR [ebp+eax*4+4]
	subss	xmm6, DWORD PTR [ebp+eax*4]
	mov	ecx, ebp
	movaps	xmm3, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	mov	ebp, DWORD PTR _this$1$[esp+152]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm7, DWORD PTR [ecx+edx*4+4]
	subss	xmm3, DWORD PTR [ecx+eax*4+8]
	movss	xmm4, DWORD PTR [ecx+edx*4]
	subss	xmm7, xmm1
	movss	xmm1, DWORD PTR [ecx+edx*4+8]
	subss	xmm4, xmm2
	subss	xmm1, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm7

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm7, xmm6
	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm2, xmm1
	mulss	xmm2, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm1, xmm6
	subss	xmm2, xmm0
	movss	DWORD PTR _test_normal$1$sroa$825$1$[esp+152], xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm5
	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR _test_normal$1$sroa$825$1$[esp+152]
	movaps	xmm3, xmm1
	subss	xmm7, xmm4
	mulss	xmm3, xmm1

; 200  : 		T magnitude=x*x + y*y + z*z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm3, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7
	addss	xmm3, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm3, DWORD PTR __real@00800000
	jbe	SHORT $LN143@RecurseTri

; 202  : 			magnitude=_sqrt(1/magnitude);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	mulss	xmm1, xmm0

; 203  : 			x *= magnitude;

	mulss	xmm2, xmm0

; 204  : 			y *= magnitude;

	mulss	xmm7, xmm0
$LN143@RecurseTri:

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [ebp+32]
	mulss	xmm1, DWORD PTR [ebp+28]
	mulss	xmm7, DWORD PTR [ebp+36]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 165  : 			if (cosa<0.034899f)		continue;	// cos(88)

	movss	xmm0, DWORD PTR __real@3d0ef241
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
	addss	xmm2, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 165  : 			if (cosa<0.034899f)		continue;	// cos(88)

	comiss	xmm0, xmm2
	ja	SHORT $LN5@RecurseTri

; 166  : 			RecurseTri				(adj,mView,W);

	push	DWORD PTR _W$[esp+148]
	mov	ecx, ebp
	push	DWORD PTR _mView$[esp+152]
	push	edi
	call	?RecurseTri@CWallmarksEngine@@AAEXIAAU?$_matrix@M@@AAUstatic_wallmark@1@@Z ; CWallmarksEngine::RecurseTri
$LN5@RecurseTri:

; 152  : 		}
; 153  : 		
; 154  : 		// recurse
; 155  : 		for (i=0; i<3; i++)

	add	esi, 4
	sub	ebx, 1
	jne	$LL7@RecurseTri
$LN6@RecurseTri:

; 167  : 		}
; 168  : 	}
; 169  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 136				; 00000088H
	ret	12					; 0000000cH
?RecurseTri@CWallmarksEngine@@AAEXIAAU?$_matrix@M@@AAUstatic_wallmark@1@@Z ENDP ; CWallmarksEngine::RecurseTri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
tv1310 = -44						; size = 4
tv1311 = -40						; size = 4
tv1312 = -36						; size = 4
tv1313 = -32						; size = 4
tv1314 = -28						; size = 4
_up$ = -24						; size = 12
_at$ = -12						; size = 12
_mView$ = 8						; size = 4
_invsz$ = 12						; size = 4
_from$ = 16						; size = 4
?BuildMatrix@CWallmarksEngine@@AAEXAAU?$_matrix@M@@MABU?$_vector3@M@@@Z PROC ; CWallmarksEngine::BuildMatrix
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 44					; 0000002cH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	eax, DWORD PTR _from$[ebp]

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	xorps	xmm7, xmm7

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [ecx+28]
	movss	xmm2, DWORD PTR [ecx+32]
	movss	xmm5, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, xmm6

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 172  : {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR _at$[esp+48], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, xmm2
	movss	DWORD PTR _at$[esp+52], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, xmm5
	movss	DWORD PTR _at$[esp+56], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	movaps	xmm0, xmm2
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 178  : 	if (_abs(sml_normal.y)>.99f) y.set(1,0,0);

	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jbe	SHORT $LN2@BuildMatri
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm7, xmm1
	xorps	xmm1, xmm1
$LN2@BuildMatri:

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	mov	esi, DWORD PTR _mView$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm0, xmm1
	movaps	xmm3, xmm5
	mulss	xmm2, xmm7
	movaps	xmm4, xmm5
	mulss	xmm3, xmm7

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm7, DWORD PTR [ecx+32]

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm2, xmm0
	mulss	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	lea	ecx, DWORD PTR _up$[esp+48]
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm5
	mulss	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	lea	ecx, DWORD PTR _at$[esp+52]
	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm1, xmm7

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm5, xmm4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm7, xmm4
	subss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm2
	mulss	xmm6, xmm3
	subss	xmm5, xmm0
	movss	DWORD PTR _up$[esp+60], xmm1
	subss	xmm6, xmm7
	movss	DWORD PTR _up$[esp+64], xmm5
	movss	DWORD PTR _up$[esp+68], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 181  : 	mView.build_camera	(from,at,up);

	call	?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm2, DWORD PTR [esi+8]
	movss	xmm3, DWORD PTR [esi+16]
	movss	xmm4, DWORD PTR [esi+20]
	movss	xmm5, DWORD PTR [esi+24]
	movss	xmm6, DWORD PTR [esi+32]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	movss	xmm7, DWORD PTR _invsz$[ebp]
	movaps	xmm0, xmm7
	mulss	xmm1, xmm7
	mulss	xmm0, DWORD PTR [esi]

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];
; 113  : 		m[0][2] = A.m[0][2] * B.m[0][0] + A.m[1][2] * B.m[0][1] + A.m[2][2] * B.m[0][2];

	mulss	xmm2, xmm7
	movss	DWORD PTR [esi], xmm0
	movss	DWORD PTR [esi+4], xmm1
	movss	DWORD PTR [esi+8], xmm2

; 114  : 		m[0][3] = 0;

	mov	DWORD PTR [esi+12], 0

; 115  : 
; 116  : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2];

	mulss	xmm3, xmm7

; 117  : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2];
; 118  : 		m[1][2] = A.m[0][2] * B.m[1][0] + A.m[1][2] * B.m[1][1] + A.m[2][2] * B.m[1][2];
; 119  : 		m[1][3] = 0;

	mov	DWORD PTR [esi+28], 0
	mulss	xmm4, xmm7
	movss	DWORD PTR [esi+16], xmm3
	mulss	xmm5, xmm7
	movss	DWORD PTR [esi+20], xmm4

; 120  : 
; 121  : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2];

	mulss	xmm6, xmm7
	movss	DWORD PTR [esi+24], xmm5
	movss	DWORD PTR [esi+32], xmm6
	movss	xmm0, DWORD PTR [esi+36]
	mulss	xmm0, xmm7

; 122  : 		m[2][1] = A.m[0][1] * B.m[2][0] + A.m[1][1] * B.m[2][1] + A.m[2][1] * B.m[2][2];

	movss	DWORD PTR [esi+36], xmm0

; 123  : 		m[2][2] = A.m[0][2] * B.m[2][0] + A.m[1][2] * B.m[2][1] + A.m[2][2] * B.m[2][2];

	movss	xmm0, DWORD PTR [esi+40]
	mulss	xmm0, xmm7

; 124  : 		m[2][3] = 0;

	mov	DWORD PTR [esi+44], 0
	movss	DWORD PTR [esi+40], xmm0

; 125  : 
; 126  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0];

	movss	xmm0, DWORD PTR [esi+48]
	mulss	xmm0, xmm7
	movss	DWORD PTR [esi+48], xmm0
	movss	xmm0, DWORD PTR [esi+52]
	mulss	xmm0, xmm7

; 127  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1];

	movss	DWORD PTR [esi+52], xmm0

; 128  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2];

	movss	xmm0, DWORD PTR [esi+56]
	mulss	xmm0, xmm7

; 129  : 		m[3][3] = 1;

	mov	DWORD PTR [esi+60], 1065353216		; 3f800000H
	movss	DWORD PTR [esi+56], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 184  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BuildMatrix@CWallmarksEngine@@AAEXAAU?$_matrix@M@@MABU?$_vector3@M@@@Z ENDP ; CWallmarksEngine::BuildMatrix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_triCount$1$ = -112					; size = 4
tv2359 = -112						; size = 4
_W$ = -112						; size = 4
_bb$5$ = -108						; size = 4
__My_data$1$ = -108					; size = 4
$T1 = -108						; size = 4
_sina$2 = -108						; size = 4
_this$1$ = -104						; size = 4
$T3 = -100						; size = 4
_tris$1$ = -100						; size = 4
$T4 = -96						; size = 4
_N$$sroa$1491$1$ = -96					; size = 4
_slot$1$ = -96						; size = 4
tv3539 = -96						; size = 4
tv3373 = -96						; size = 4
_W$ = -96						; size = 4
_W$ = -96						; size = 4
$T5 = -92						; size = 4
_bbd$6 = -88						; size = 12
_bbc$7 = -76						; size = 12
_mView$ = -64						; size = 64
_pTri$ = 8						; size = 4
_pVerts$ = 12						; size = 4
_contact_point$ = 16					; size = 4
_hShader$ = 20						; size = 4
_sz$ = 24						; size = 4
?AddWallmark_internal@CWallmarksEngine@@AAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z PROC ; CWallmarksEngine::AddWallmark_internal
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 112				; 00000070H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR _contact_point$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 194  : 		bb_query.grow		(sz*2.5f);

	movss	xmm7, DWORD PTR _sz$[ebp]
	mulss	xmm7, DWORD PTR __real@40200000
	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	xmm4, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 187  : {

	mov	esi, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	movss	xmm5, DWORD PTR [eax+4]
	movss	xmm6, DWORD PTR [eax+8]
	subss	xmm4, xmm7
	subss	xmm5, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 187  : {

	mov	DWORD PTR _this$1$[esp+116], esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	movaps	xmm1, xmm7

; 35   : 	ICF SelfRef	sub(T s)								{ x-=s;		y-=s;		z-=s;			return *this;	};

	subss	xmm6, xmm7

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm1, DWORD PTR [eax]
	movaps	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	lea	ecx, DWORD PTR [esi+1444]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 30   : 	ICF SelfRef	add(T s)								{ x+=s;		y+=s;		z+=s;			return *this;	};

	addss	xmm0, DWORD PTR [eax+4]
	addss	xmm7, DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 187  : {

	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 148  : 		ICF void		box_options		(u32 f)	{	box_mode = f;		}

	mov	DWORD PTR [esi+1448], 8
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	lea	eax, DWORD PTR _bbd$6[esp+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm5
	subss	xmm7, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm1, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	lea	eax, DWORD PTR _bbc$7[esp+124]
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm0, DWORD PTR __real@3f000000
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	mulss	xmm7, DWORD PTR __real@3f000000
	movss	DWORD PTR _bbd$6[esp+128], xmm1

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm1, xmm4
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _bbd$6[esp+132], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\xr_area.h

; 61   : 	CDB::MODEL* GetStaticModel() { return &Static; }

	add	eax, 172				; 000000acH
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 40   : 	ICF SelfRef	mul(T s)								{ x*=s;		y*=s;		z*=s;			return *this;	};

	movss	DWORD PTR _bbd$6[esp+136], xmm7

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm0, xmm5
	addss	xmm7, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR _bbc$7[esp+132], xmm1
	movss	DWORD PTR _bbc$7[esp+136], xmm0
	movss	DWORD PTR _bbc$7[esp+140], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 197  : 		xrc.box_query		(g_pGameLevel->ObjectSpace.GetStaticModel(),bbc,bbd);

	call	DWORD PTR __imp_?box_query@xrXRC@@QAEXPBVMODEL@CDB@@ABU?$_vector3@M@@1@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [esi+1460]
	lea	ecx, DWORD PTR [esi+1456]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1227133513
	mov	DWORD PTR __My_data$1$[esp+120], ecx
	mov	DWORD PTR _triCount$1$[esp+120], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 199  : 		if (0==triCount)	return;

	test	eax, eax
	je	$LN391@AddWallmar

; 200  : 		CDB::TRI* tris		= g_pGameLevel->ObjectSpace.GetStaticTris();

	mov	eax, DWORD PTR __imp_?g_pGameLevel@@3PAVIGame_Level@@A
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+184]
	mov	DWORD PTR _tris$1$[esp+120], eax

; 201  : 		sml_collector.clear	();

	lea	eax, DWORD PTR [esi+1468]
	mov	ecx, eax
	mov	DWORD PTR tv3373[esp+120], eax
	call	DWORD PTR __imp_?clear@Collector@CDB@@QAEXXZ

; 202  : 		sml_collector.add_face_packed_D	(pVerts[pTri->verts[0]],pVerts[pTri->verts[1]],pVerts[pTri->verts[2]],0);

	mov	edi, DWORD PTR _pVerts$[ebp]
	fld	DWORD PTR __real@3727c5ac
	push	ecx
	mov	ecx, DWORD PTR _pTri$[ebp]
	fstp	DWORD PTR [esp]
	push	0
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [esi+1468]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	call	DWORD PTR __imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z

; 203  : 		for (u32 t=0; t<triCount; t++)	{

	cmp	DWORD PTR _triCount$1$[esp+120], 0
	jbe	SHORT $LN3@AddWallmar
; File I:\Vitalya\mine\NSProjectX\xrCDB\xrCDB.h

; 86   : 		IC TRI*					get_tris		()			{ return tris;		}

	xor	esi, esi
	npad	2
$LL4@AddWallmar:

; 154  : 		ICF RESULT*		r_begin			()	{	return &*rd.begin();		};

	mov	ecx, DWORD PTR __My_data$1$[esp+120]
	lea	eax, DWORD PTR $T5[esp+120]
	push	eax
	call	?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 204  : 			CDB::TRI*	T	= tris+xrc.r_begin()[t].id;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+eax+40]
	shl	ecx, 4
	add	ecx, DWORD PTR _tris$1$[esp+120]

; 205  : 			if (T==pTri)	continue;

	cmp	ecx, DWORD PTR _pTri$[ebp]
	je	SHORT $LN2@AddWallmar

; 206  : 			sml_collector.add_face_packed_D		(pVerts[T->verts[0]],pVerts[T->verts[1]],pVerts[T->verts[2]],0);

	mov	eax, DWORD PTR [ecx+8]
	fld	DWORD PTR __real@3727c5ac
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	0
	push	eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv3373[esp+136]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	eax
	call	DWORD PTR __imp_?add_face_packed_D@Collector@CDB@@QAEXABU?$_vector3@M@@00IM@Z
$LN2@AddWallmar:

; 203  : 		for (u32 t=0; t<triCount; t++)	{

	add	esi, 56					; 00000038H
	sub	DWORD PTR _triCount$1$[esp+120], 1
	jne	SHORT $LL4@AddWallmar
	mov	esi, DWORD PTR _this$1$[esp+120]
$LN3@AddWallmar:

; 207  : 		}
; 208  : 		sml_collector.calc_adjacency	(sml_adjacency);

	lea	eax, DWORD PTR [esi+1492]
	push	eax
	lea	ecx, DWORD PTR [esi+1468]
	call	DWORD PTR __imp_?calc_adjacency@Collector@CDB@@QAEXAAV?$xr_vector@IV?$xalloc@I@@@@@Z

; 213  : 	N.mknormal			(pVerts[pTri->verts[0]],pVerts[pTri->verts[1]],pVerts[pTri->verts[2]]);

	mov	ecx, DWORD PTR _pTri$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [edi+edx*4+4]
	movss	xmm1, DWORD PTR [edi+edx*4+8]
	movss	xmm4, DWORD PTR [edi+edx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 213  : 	N.mknormal			(pVerts[pTri->verts[0]],pVerts[pTri->verts[1]],pVerts[pTri->verts[2]]);

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR _pTri$[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [edi+ecx*4+4]
	subss	xmm1, DWORD PTR [edi+ecx*4+8]
	subss	xmm2, DWORD PTR [edi+ecx*4+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 213  : 	N.mknormal			(pVerts[pTri->verts[0]],pVerts[pTri->verts[1]],pVerts[pTri->verts[2]]);

	mov	eax, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [edi+ecx*4+8]
	subss	xmm4, DWORD PTR [edi+ecx*4]
	movss	xmm6, DWORD PTR [edi+ecx*4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 213  : 	N.mknormal			(pVerts[pTri->verts[0]],pVerts[pTri->verts[1]],pVerts[pTri->verts[2]]);

	lea	eax, DWORD PTR [eax+eax*2]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm5, DWORD PTR [edi+eax*4+4]
	subss	xmm3, DWORD PTR [edi+eax*4+8]
	subss	xmm6, DWORD PTR [edi+eax*4]
	movaps	xmm7, xmm5

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm5, xmm4
	mulss	xmm0, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mulss	xmm7, xmm1

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	movss	DWORD PTR _N$$sroa$1491$1$[esp+120], xmm0

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm6
	movss	xmm3, DWORD PTR _N$$sroa$1491$1$[esp+120]
	mulss	xmm0, xmm1
	mulss	xmm6, xmm2
	subss	xmm3, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm0, xmm7
	mulss	xmm0, xmm7

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm6, xmm5
	movaps	xmm1, xmm3
	mulss	xmm1, xmm3

; 200  : 		T magnitude=x*x + y*y + z*z;

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0

; 201  : 		if (magnitude> std::numeric_limits<T>::min()) {

	comiss	xmm1, DWORD PTR __real@00800000
	jbe	SHORT $LN82@AddWallmar

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm2
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 202  : 			magnitude=_sqrt(1/magnitude);

	movaps	xmm0, xmm1

; 203  : 			x *= magnitude;
; 204  : 			y *= magnitude;

	mulss	xmm6, xmm1
	mulss	xmm7, xmm0
	mulss	xmm3, xmm0
$LN82@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 218  : 	BuildMatrix			(mView,1/sz,contact_point);

	push	DWORD PTR _contact_point$[ebp]
	movaps	xmm0, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [esi+28], xmm7
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 218  : 	BuildMatrix			(mView,1/sz,contact_point);

	divss	xmm0, DWORD PTR _sz$[ebp]
	push	ecx
	lea	eax, DWORD PTR _mView$[esp+128]
	mov	ecx, esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [esi+32], xmm3
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 218  : 	BuildMatrix			(mView,1/sz,contact_point);

	movss	DWORD PTR [esp], xmm0
	push	eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR [esi+36], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 218  : 	BuildMatrix			(mView,1/sz,contact_point);

	call	?BuildMatrix@CWallmarksEngine@@AAEXAAU?$_matrix@M@@MABU?$_vector3@M@@@Z ; CWallmarksEngine::BuildMatrix
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	mov	ecx, DWORD PTR __imp_?Random@@3VCRandom@@A
	call	?randI@CRandom@@QAEHXZ			; CRandom::randI
	mov	DWORD PTR tv3539[esp+120], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 221  : 	sml_clipper.CreateFromMatrix	(mView,FRUSTUM_P_LRTB);

	lea	ecx, DWORD PTR [esi+40]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 39   : 	IC 	float	randF	()							{ return float(randI())/maxF();	}

	fild	DWORD PTR tv3539[esp+120]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 221  : 	sml_clipper.CreateFromMatrix	(mView,FRUSTUM_P_LRTB);

	lea	eax, DWORD PTR _mView$[esp+120]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 114  : 		m[0][3] = 0;

	mov	DWORD PTR _mView$[esp+132], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 221  : 	sml_clipper.CreateFromMatrix	(mView,FRUSTUM_P_LRTB);

	push	15					; 0000000fH
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 119  : 		m[1][3] = 0;

	mov	DWORD PTR _mView$[esp+152], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm3, DWORD PTR _mView$[esp+124]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 40   : 	IC 	float	randF	(float max)					{ return randF()*max; }

	fmul	DWORD PTR __real@37b2ba28
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movaps	xmm0, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	movss	xmm2, DWORD PTR _mView$[esp+128]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm4, DWORD PTR _mView$[esp+140]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	movaps	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm5, DWORD PTR _mView$[esp+156]
	movss	xmm6, DWORD PTR _mView$[esp+172]
; File I:\Vitalya\mine\NSProjectX\xrCore\_random.h

; 41   : 	IC 	float	randF	(float min,float max)		{ return min+randF(max-min); }

	fsub	DWORD PTR __real@3eb2b8c3
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 124  : 		m[2][3] = 0;

	mov	DWORD PTR _mView$[esp+168], 0

; 128  : 		m[3][2] = A.m[0][2] * B.m[3][0] + A.m[1][2] * B.m[3][1] + A.m[2][2] * B.m[3][2] + A.m[3][2];
; 129  : 		m[3][3] = 1;

	mov	DWORD PTR _mView$[esp+184], 1065353216	; 3f800000H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 221  : 	sml_clipper.CreateFromMatrix	(mView,FRUSTUM_P_LRTB);

	push	eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	ST(0)
	fcos
	fstp	DWORD PTR tv2359[esp+128]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mulss	xmm0, DWORD PTR tv2359[esp+128]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];

	mulss	xmm2, DWORD PTR tv2359[esp+128]

; 289  : 		T sina	= _sin(Angle);

	fstp	DWORD PTR _sina$2[esp+128]

; 290  : 		i.set		(cosa,	sina,	0	);	_14 = 0;
; 291  : 		j.set		(-sina,	cosa,	0	);	_24 = 0;

	movss	xmm7, DWORD PTR _sina$2[esp+128]
	xorps	xmm7, DWORD PTR __xmm@80000000800000008000000080000000

; 111  : 		m[0][0] = A.m[0][0] * B.m[0][0] + A.m[1][0] * B.m[0][1] + A.m[2][0] * B.m[0][2];

	mulss	xmm3, DWORD PTR _sina$2[esp+128]
	mulss	xmm1, xmm7

; 112  : 		m[0][1] = A.m[0][1] * B.m[0][0] + A.m[1][1] * B.m[0][1] + A.m[2][1] * B.m[0][2];

	addss	xmm2, xmm3

; 115  : 
; 116  : 		m[1][0] = A.m[0][0] * B.m[1][0] + A.m[1][0] * B.m[1][1] + A.m[2][0] * B.m[1][2];

	movss	xmm3, DWORD PTR _sina$2[esp+128]
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _mView$[esp+148]
	movss	DWORD PTR _mView$[esp+132], xmm2
	movss	DWORD PTR _mView$[esp+128], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR tv2359[esp+128]
	mulss	xmm4, xmm3
	addss	xmm1, xmm0

; 117  : 		m[1][1] = A.m[0][1] * B.m[1][0] + A.m[1][1] * B.m[1][1] + A.m[2][1] * B.m[1][2];

	movss	xmm0, DWORD PTR tv2359[esp+128]
	mulss	xmm0, DWORD PTR _mView$[esp+148]
	addss	xmm4, xmm0
	movss	DWORD PTR _mView$[esp+144], xmm1

; 119  : 		m[1][3] = 0;

	movaps	xmm1, xmm5

; 120  : 
; 121  : 		m[2][0] = A.m[0][0] * B.m[2][0] + A.m[1][0] * B.m[2][1] + A.m[2][0] * B.m[2][2];

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _mView$[esp+164]

; 125  : 
; 126  : 		m[3][0] = A.m[0][0] * B.m[3][0] + A.m[1][0] * B.m[3][1] + A.m[2][0] * B.m[3][2] + A.m[3][0];

	mulss	xmm7, DWORD PTR _mView$[esp+180]
	movss	DWORD PTR _mView$[esp+148], xmm4
	movss	xmm4, DWORD PTR tv2359[esp+128]
	mulss	xmm1, xmm4
	mulss	xmm5, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _mView$[esp+164]
	addss	xmm5, xmm0
	movss	DWORD PTR _mView$[esp+160], xmm1
	movaps	xmm0, xmm6
	mulss	xmm6, xmm3
	mulss	xmm0, xmm4

; 127  : 		m[3][1] = A.m[0][1] * B.m[3][0] + A.m[1][1] * B.m[3][1] + A.m[2][1] * B.m[3][2] + A.m[3][1];

	mulss	xmm4, DWORD PTR _mView$[esp+180]
	addss	xmm0, xmm7
	movss	DWORD PTR _mView$[esp+164], xmm5
	addss	xmm6, xmm4
	movss	DWORD PTR _mView$[esp+176], xmm0
	movss	DWORD PTR _mView$[esp+180], xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 221  : 	sml_clipper.CreateFromMatrix	(mView,FRUSTUM_P_LRTB);

	call	DWORD PTR __imp_?CreateFromMatrix@CFrustum@@QAEXAAU?$_matrix@M@@I@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 86   : 	if (static_pool.empty())  W = xr_new<static_wallmark> ();

	jne	SHORT $LN178@AddWallmar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	mov	edi, eax

; 69   : 	return new (ptr) T();

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 86   : 	if (static_pool.empty())  W = xr_new<static_wallmark> ();

	jmp	SHORT $LN179@AddWallmar
$LN178@AddWallmar:

; 87   : 	else					{ W = static_pool.back(); static_pool.pop_back(); }

	mov	edi, DWORD PTR [eax-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1611 :         return _My_data._Mylast[-1];

	add	eax, -4					; fffffffcH

; 1390 :         --_Mylast;

	mov	DWORD PTR [esi+4], eax
$LN179@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 90   : 	W->verts.clear		();

	mov	eax, DWORD PTR [edi+16]

; 225  : 	RecurseTri			(0,mView,*W);

	mov	ecx, esi

; 90   : 	W->verts.clear		();

	mov	DWORD PTR [edi+20], eax

; 225  : 	RecurseTri			(0,mView,*W);

	lea	eax, DWORD PTR _mView$[esp+120]
	push	edi
	push	eax
	push	0

; 89   : 	W->ttl				= ps_r__WallmarkTTL;

	mov	DWORD PTR [edi+28], 1133903872		; 43960000H

; 222  : 
; 223  : 	// create wallmark
; 224  : 	static_wallmark* W	= static_wm_allocate();

	mov	DWORD PTR _W$[esp+132], edi

; 225  : 	RecurseTri			(0,mView,*W);

	call	?RecurseTri@CWallmarksEngine@@AAEXIAAU?$_matrix@M@@AAUstatic_wallmark@1@@Z ; CWallmarksEngine::RecurseTri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 228  : 	if (W->verts.size()<3) { static_wm_destroy(W); return; }

	cmp	eax, 3
	jae	SHORT $LN13@AddWallmar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [esi+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 228  : 	if (W->verts.size()<3) { static_wm_destroy(W); return; }

	mov	DWORD PTR _W$[esp+120], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN208@AddWallmar

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hShader$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [esi+4], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 260  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN208@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _W$[esp+120]
	push	ecx
	mov	ecx, esi
	jmp	$LN420@AddWallmar
$LN13@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm2, DWORD PTR __real@ff7fffff
	movss	xmm1, DWORD PTR __real@7f7fffff
	movaps	xmm6, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 233  : 		FVF::LIT* E=&*W->verts.end		();

	mov	eax, DWORD PTR [edi+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movaps	xmm0, xmm1
	movss	DWORD PTR _bb$5$[esp+120], xmm2
	movaps	xmm7, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 37   : 	IC	SelfRef	invalidate	()								{ min.set(type_max(T),type_max(T),type_max(T)); max.set(type_min(T),type_min(T),type_min(T));	return *this;	}

	movaps	xmm3, xmm1
	movaps	xmm4, xmm2
	movaps	xmm5, xmm2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 234  : 		for (; I!=E; I++)	bb.modify	(I->p);

	cmp	ecx, eax
	je	SHORT $LN6@AddWallmar
	npad	7
$LL7@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm3, DWORD PTR [ecx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm3, xmm1
	ja	SHORT $LN251@AddWallmar
	movaps	xmm1, xmm3
$LN251@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm4, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm4, xmm0
	ja	SHORT $LN255@AddWallmar
	movaps	xmm0, xmm4
$LN255@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	xmm5, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm5, xmm7
	ja	SHORT $LN259@AddWallmar
	movaps	xmm7, xmm5
$LN259@AddWallmar:

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm2, xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 53   : 	IC	SelfRef	min(const Self &v)						{ x = _min(x,v.x);	y = _min(y,v.y);	z = _min(z,v.z);			return *this;	}

	movss	DWORD PTR $T4[esp+120], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	ja	SHORT $LN265@AddWallmar
	movaps	xmm2, xmm3
$LN265@AddWallmar:
	movss	xmm3, DWORD PTR _bb$5$[esp+120]
	comiss	xmm3, xmm4
	jbe	SHORT $LN268@AddWallmar
	movss	DWORD PTR _bb$5$[esp+120], xmm3
	jmp	SHORT $LN269@AddWallmar
$LN268@AddWallmar:
	movaps	xmm3, xmm4
	movss	DWORD PTR _bb$5$[esp+120], xmm4
$LN269@AddWallmar:
	comiss	xmm6, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movss	DWORD PTR $T3[esp+120], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_std_extensions.h

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	ja	SHORT $LN273@AddWallmar
	movaps	xmm6, xmm5
$LN273@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 234  : 		for (; I!=E; I++)	bb.modify	(I->p);

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 55   : 	IC	SelfRef	max(const Self &v)						{ x = _max(x,v.x);	y = _max(y,v.y);	z = _max(z,v.z);			return *this;	}

	movaps	xmm4, xmm6
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 234  : 		for (; I!=E; I++)	bb.modify	(I->p);

	cmp	ecx, eax
	jne	SHORT $LL7@AddWallmar
	movss	xmm3, DWORD PTR $T4[esp+120]
	movss	xmm5, DWORD PTR $T3[esp+120]
$LN6@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 97   : 		C.x = (min.x + max.x) * 0.5f;

	movss	xmm6, DWORD PTR __real@3f000000

; 98   : 		C.y = (min.y + max.y) * 0.5f;

	addss	xmm0, xmm5
	addss	xmm1, xmm2

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	addss	xmm3, xmm4
	mulss	xmm0, xmm6
	mulss	xmm1, xmm6
	movss	DWORD PTR [edi+4], xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm0, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	mulss	xmm3, xmm6
	movss	DWORD PTR [edi], xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 99   : 		C.z = (min.z + max.z) * 0.5f;

	movss	DWORD PTR [edi+8], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	subss	xmm3, xmm4
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	mulss	xmm3, xmm3
	addss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 238  : 	if (W->bounds.R < 1.f)	

	movss	xmm1, DWORD PTR __real@3f800000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	addss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 238  : 	if (W->bounds.R < 1.f)	

	comiss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_fbox.h

; 116  : 		R = C.distance_to	(max);

	movss	DWORD PTR [edi+12], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 238  : 	if (W->bounds.R < 1.f)	

	jbe	$LN391@AddWallmar
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _hShader$[ebp]
	mov	DWORD PTR $T1[esp+120], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN288@AddWallmar
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T1[esp+120]
$LN288@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5221 :     return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});

	mov	edx, DWORD PTR [esi+12]

; 5185 :     for (; _First != _Last; ++_First) {

	cmp	edx, DWORD PTR [esi+16]
	je	SHORT $LN293@AddWallmar
$LL314@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	ecx, DWORD PTR [edx]

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	cmp	DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5186 :         if (*_First == _Val) {

	je	SHORT $LN419@AddWallmar

; 5185 :     for (; _First != _Last; ++_First) {

	add	edx, 4
	cmp	edx, DWORD PTR [esi+16]
	jne	SHORT $LL314@AddWallmar
$LN293@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 37   : 	return						(it!=marks.end())?*it:0;

	lea	ecx, DWORD PTR $T1[esp+120]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
$LN16@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _hShader$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 254  : 			slot		= AppendSlot(hShader);

	push	ecx
	mov	ecx, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR _hShader$[ebp]
	test	eax, eax
	je	SHORT $LN386@AddWallmar
	inc	DWORD PTR [eax]
$LN386@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 254  : 			slot		= AppendSlot(hShader);

	mov	ecx, esi
	call	?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::AppendSlot
	mov	edx, eax
$LN17@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 258  : 		slot->static_items.push_back(W);

	lea	ecx, DWORD PTR [edx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	eax, DWORD PTR [ecx+8]
	je	$LN392@AddWallmar

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hShader$[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 260  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN419@AddWallmar:

; 37   : 	return						(it!=marks.end())?*it:0;

	mov	DWORD PTR _slot$1$[esp+120], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+120]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 242  : 		if (slot){

	mov	edx, DWORD PTR _slot$1$[esp+120]
	test	edx, edx
	je	SHORT $LN16@AddWallmar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+8]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 245  : 			for (; it!=end; it++)	{

	je	SHORT $LN17@AddWallmar
	movss	xmm3, DWORD PTR [edi]
	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm2, DWORD PTR __real@3ca3d70a
$LL10@AddWallmar:

; 246  : 				static_wallmark* wm		=	*it;

	mov	ecx, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	SHORT $LN359@AddWallmar
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	jbe	SHORT $LN359@AddWallmar
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [edi+8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

	andps	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm2, xmm0
	ja	SHORT $LN403@AddWallmar
$LN359@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 245  : 			for (; it!=end; it++)	{

	jne	SHORT $LL10@AddWallmar
	jmp	$LN17@AddWallmar
$LN403@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR _this$1$[esp+120]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 248  : 					static_wm_destroy	(wm);

	mov	DWORD PTR _W$[esp+120], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN378@AddWallmar

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [edx], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hShader$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [eax+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 249  : 					*it					=	W;

	mov	DWORD PTR [esi], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 260  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN378@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _W$[esp+120]
	push	ecx
	push	edx
	mov	ecx, eax
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hShader$[ebp]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 249  : 					*it					=	W;

	mov	DWORD PTR [esi], edi
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 260  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN392@AddWallmar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR _W$[esp+120]
	push	edx
$LN420@AddWallmar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	push	eax
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
$LN391@AddWallmar:
	lea	ecx, DWORD PTR _hShader$[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 260  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddWallmark_internal@CWallmarksEngine@@AAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ENDP ; CWallmarksEngine::AddWallmark_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_pTri$ = 8						; size = 4
_pVerts$ = 12						; size = 4
_contact_point$ = 16					; size = 4
_hShader$ = 20						; size = 4
_sz$ = 24						; size = 4
?AddStaticWallmark@CWallmarksEngine@@QAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z PROC ; CWallmarksEngine::AddStaticWallmark
; _this$ = ecx

; 265  : 	if (contact_point.distance_to_sqr(Device.vCameraPosition) > _sqr(100.f))	return;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	push	ebx
	push	esi
	push	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	mov	edi, DWORD PTR _contact_point$[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 263  : {

	mov	ebx, ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [edi+4]
	movss	xmm2, DWORD PTR [edi]
	subss	xmm2, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [eax+492]
	movss	xmm0, DWORD PTR [edi+8]
	subss	xmm0, DWORD PTR [eax+496]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 265  : 	if (contact_point.distance_to_sqr(Device.vCameraPosition) > _sqr(100.f))	return;

	comiss	xmm2, DWORD PTR __real@461c4000
	ja	SHORT $LN4@AddStaticW

; 266  : 
; 267  : 	// Physics may add wallmarks in parallel with rendering
; 268  : 	lock.Enter				();

	lea	ecx, DWORD PTR [ebx+1504]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _hShader$[esp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 269  : 	AddWallmark_internal	(pTri,pVerts,contact_point,hShader,sz);

	sub	esp, 8
	fld	DWORD PTR _sz$[esp+16]
	mov	ecx, esp
	fstp	DWORD PTR [esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	mov	eax, DWORD PTR _hShader$[esp+16]
	test	eax, eax
	je	SHORT $LN13@AddStaticW
	inc	DWORD PTR [eax]
$LN13@AddStaticW:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 269  : 	AddWallmark_internal	(pTri,pVerts,contact_point,hShader,sz);

	push	edi
	push	DWORD PTR _pVerts$[esp+20]
	mov	ecx, ebx
	push	DWORD PTR _pTri$[esp+24]
	call	?AddWallmark_internal@CWallmarksEngine@@AAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ; CWallmarksEngine::AddWallmark_internal

; 270  : 	lock.Leave				();

	lea	ecx, DWORD PTR [ebx+1504]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
$LN4@AddStaticW:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hShader$[esp+8]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 271  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	20					; 00000014H
?AddStaticWallmark@CWallmarksEngine@@QAEXPAVTRI@CDB@@PBU?$_vector3@M@@ABU4@V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z ENDP ; CWallmarksEngine::AddStaticWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_xf$ = 8						; size = 4
_obj$ = 12						; size = 4
_sh$ = 16						; size = 4
_start$ = 20						; size = 4
_dir$ = 24						; size = 4
_size$ = 28						; size = 4
?AddSkeletonWallmark@CWallmarksEngine@@QAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z PROC ; CWallmarksEngine::AddSkeletonWallmark
; _this$ = ecx

; 275  : 	if( 0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL)				return;

	cmp	DWORD PTR ?g_r@@3IA, 0			; g_r
	push	esi
	push	edi
	je	$LN6@AddSkeleto
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 0
	jne	$LN6@AddSkeleto

; 277  : 	if (xf->c.distance_to_sqr(Device.vCameraPosition) > _sqr(50.f))				return;

	mov	edi, DWORD PTR _xf$[esp+4]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [edi+52]
	movss	xmm2, DWORD PTR [edi+48]
	subss	xmm2, DWORD PTR [eax+488]
	subss	xmm1, DWORD PTR [eax+492]
	movss	xmm0, DWORD PTR [edi+56]
	subss	xmm0, DWORD PTR [eax+496]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 277  : 	if (xf->c.distance_to_sqr(Device.vCameraPosition) > _sqr(50.f))				return;

	comiss	xmm2, DWORD PTR __real@451c4000
	ja	SHORT $LN6@AddSkeleto

; 278  : 
; 279  : 	VERIFY					(obj&&xf&&(size>EPS_L));
; 280  : 	lock.Enter				();

	lea	esi, DWORD PTR [ecx+1504]
	mov	ecx, esi
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _sh$[esp+4]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	sub	esp, 8
	fld	DWORD PTR _size$[esp+12]
	mov	ecx, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	fstp	DWORD PTR [esp+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN15@AddSkeleto
	inc	DWORD PTR [eax]
$LN15@AddSkeleto:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 281  : 	obj->AddWallmark		(xf,start,dir,sh,size);

	push	DWORD PTR _dir$[esp+12]
	mov	ecx, DWORD PTR _obj$[esp+16]
	push	DWORD PTR _start$[esp+16]
	push	edi
	call	DWORD PTR __imp_?AddWallmark@CKinematics@@QAEXPBU?$_matrix@M@@ABU?$_vector3@M@@1V?$resptr_core@UShader@@Uresptrcode_shader@@@@M@Z

; 282  : 	lock.Leave				();

	mov	ecx, esi
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
$LN6@AddSkeleto:

; 283  : }

	pop	edi
	pop	esi
	ret	24					; 00000018H
?AddSkeletonWallmark@CWallmarksEngine@@QAEXPBU?$_matrix@M@@PAVCKinematics@@AAV?$resptr_core@UShader@@Uresptrcode_shader@@@@ABU?$_vector3@M@@3M@Z ENDP ; CWallmarksEngine::AddSkeletonWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_wm$ = 8						; size = 4
?AddSkeletonWallmark@CWallmarksEngine@@QAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; CWallmarksEngine::AddSkeletonWallmark
; _this$ = ecx

; 287  : 	if(0==g_r || ::RImplementation.phase != CRender::PHASE_NORMAL) return;

	cmp	DWORD PTR ?g_r@@3IA, 0			; g_r
	push	esi
	mov	esi, ecx
	je	$LN3@AddSkeleto
	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+292, 0
	jne	SHORT $LN3@AddSkeleto

; 288  : 
; 289  : 	if (!::RImplementation.val_bHUD)

	cmp	DWORD PTR ?RImplementation@@3VCRender@@A+268, 0
	jne	SHORT $LN3@AddSkeleto

; 290  : 	{
; 291  : 		lock.Enter			();

	push	edi
	lea	ecx, DWORD PTR [esi+1504]
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ

; 292  : 		// search if similar wallmark exists
; 293  : 		wm_slot* slot		= FindSlot	(wm->Shader());

	push	ecx
	mov	ecx, DWORD PTR _wm$[esp+8]
	push	esp
	call	DWORD PTR __imp_?Shader@CSkeletonWallmark@@QAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
	mov	ecx, esi
	call	?FindSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::FindSlot

; 294  : 		if (0==slot) slot	= AppendSlot(wm->Shader());

	test	eax, eax
	jne	SHORT $LN5@AddSkeleto
	push	ecx
	mov	ecx, DWORD PTR _wm$[esp+8]
	push	esp
	call	DWORD PTR __imp_?Shader@CSkeletonWallmark@@QAE?AV?$resptr_core@UShader@@Uresptrcode_shader@@@@XZ
	mov	ecx, esi
	call	?AppendSlot@CWallmarksEngine@@AAEPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ; CWallmarksEngine::AppendSlot
$LN5@AddSkeleto:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 296  : 		slot->skeleton_items.push_back(wm);

	lea	ecx, DWORD PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN11@AddSkeleto
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _wm$[esp+4]
	test	eax, eax
	je	SHORT $LN21@AddSkeleto

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN21@AddSkeleto:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN10@AddSkeleto
$LN11@AddSkeleto:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR _wm$[esp+4]
	push	eax
	push	edx
	call	??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
$LN10@AddSkeleto:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 300  : 		lock.Leave			();

	lea	ecx, DWORD PTR [esi+1504]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ
	pop	edi
$LN3@AddSkeleto:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 44   : 	if (!m_object)

	mov	eax, DWORD PTR _wm$[esp]
	pop	esi
	test	eax, eax
	je	SHORT $LN33@AddSkeleto

; 45   : 		return;
; 46   : 	
; 47   : 	--m_object->base_type::m_ref_count;

	dec	DWORD PTR [eax]

; 48   : 	if (!m_object->base_type::m_ref_count)

	mov	eax, DWORD PTR _wm$[esp-4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN33@AddSkeleto

; 49   : 		m_object->base_type::_release	(m_object);

	push	eax
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN33@AddSkeleto:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 302  : }

	ret	4
?AddSkeletonWallmark@CWallmarksEngine@@QAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; CWallmarksEngine::AddSkeletonWallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
;	COMDAT ?BeginStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@AAIAAPAULIT@FVF@@2@Z
_TEXT	SEGMENT
_hGeom$ = 8						; size = 4
_w_start$ = 12						; size = 4
?BeginStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@AAIAAPAULIT@FVF@@2@Z PROC ; BeginStream, COMDAT
; _w_offset$ = ecx
; _w_verts$ = edx

; 307  : 	w_offset				= 0;
; 308  : 	w_verts					= (FVF::LIT*)RCache.Vertex.Lock	(MAX_TRIS*3,hGeom->vb_stride,w_offset);

	mov	eax, DWORD PTR _hGeom$[esp-4]
	push	esi
	push	ecx
	mov	DWORD PTR [ecx], 0
	mov	esi, edx
	push	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	push	3072					; 00000c00H
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z

; 309  : 	w_start					= w_verts;

	mov	ecx, DWORD PTR _w_start$[esp]
	mov	DWORD PTR [esi], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 309  : 	w_start					= w_verts;

	mov	DWORD PTR [ecx], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hGeom$[esp-4]
	jmp	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
?BeginStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@AAIAAPAULIT@FVF@@2@Z ENDP ; BeginStream
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
;	COMDAT ?FlushStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAIAAPAULIT@FVF@@3H@Z
_TEXT	SEGMENT
_w_offset$1$ = -4					; size = 4
_hGeom$ = 8						; size = 4
_shader$ = 12						; size = 4
_w_start$ = 16						; size = 4
_bSuppressCull$ = 20					; size = 4
?FlushStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAIAAPAULIT@FVF@@3H@Z PROC ; FlushStream, COMDAT
; _w_offset$ = ecx
; _w_verts$ = edx

; 313  : {

	push	ecx

; 314  : 	u32 w_count					= u32(w_verts-w_start);

	mov	eax, DWORD PTR _w_start$[esp]
	mov	edx, DWORD PTR [edx]
	push	ebp
	mov	DWORD PTR _w_offset$1$[esp+8], ecx
	sub	edx, DWORD PTR [eax]

; 315  : 	RCache.Vertex.Unlock		(w_count,hGeom->vb_stride);

	mov	eax, DWORD PTR _hGeom$[esp+4]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	sar	edx, 3
	imul	ebp, edx, -1431655765
	push	DWORD PTR [eax+20]
	push	ebp
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 316  : 	if (w_count)			

	test	ebp, ebp
	je	$LN2@FlushStrea

; 317  : 	{
; 318  : 		RCache.set_Shader		(shader);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	eax, DWORD PTR _shader$[esp+4]
	push	esi
	push	edi
	push	0
	push	eax
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 175  : 	ICF void						set_Geometry(ref_geom& _geom) { set_Geometry(&*_geom); }

	mov	edi, DWORD PTR _hGeom$[esp+12]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 319  : 		RCache.set_Geometry		(hGeom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN15@FlushStrea

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN15@FlushStrea:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	edx, DWORD PTR [edi+20]
	push	ebx
	mov	ebx, DWORD PTR [edi+12]

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], ebx
	jne	SHORT $LN19@FlushStrea
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN18@FlushStrea
$LN19@FlushStrea:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], ebx

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	ebx
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN18@FlushStrea:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN22@FlushStrea

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN22@FlushStrea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 320  : 		if (bSuppressCull)		RCache.set_CullMode (CULL_NONE);

	mov	edi, DWORD PTR _bSuppressCull$[esp+16]
	test	edi, edi
	je	SHORT $LN25@FlushStrea
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 1
	je	SHORT $LN25@FlushStrea
	mov	DWORD PTR [eax+8916], 1
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	1
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
$LN25@FlushStrea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	eax, -1431655765			; aaaaaaabH
	mov	ebx, DWORD PTR _w_offset$1$[esp+20]
	mul	ebp
	mov	ebx, DWORD PTR [ebx]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 209  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	esi, edx
	shr	esi, 1
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 211  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], esi
	lea	eax, DWORD PTR [esi+esi*2]
	add	DWORD PTR [ecx+9020], eax

; 212  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN31@FlushStrea
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN30@FlushStrea
$LN31@FlushStrea:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN30@FlushStrea:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	esi
	push	ebx
	push	4
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 322  : 		if (bSuppressCull)		RCache.set_CullMode	(CULL_CCW);

	pop	ebx
	test	edi, edi
	je	SHORT $LN34@FlushStrea
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 3
	je	SHORT $LN34@FlushStrea
	mov	DWORD PTR [eax+8916], 3
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	3
	push	22					; 00000016H
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]
$LN34@FlushStrea:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 323  : 		Device.Statistic->RenderDUMP_WMT_Count += w_count/3;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	pop	edi
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2240], esi
	pop	esi
$LN2@FlushStrea:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR _hGeom$[esp+4]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR _shader$[esp+4]
	pop	ebp
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 325  : }

	add	esp, 4
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	jmp	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
?FlushStream@@YAXV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@AAIAAPAULIT@FVF@@3H@Z ENDP ; FlushStream
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp
_TEXT	SEGMENT
_mSavedView$ = -160					; size = 64
_mViewPos$ = -96					; size = 12
__43$ = -84						; size = 4
tv136 = -80						; size = 4
tv2297 = -76						; size = 4
_w_count$1$ = -72					; size = 4
_W$2 = -72						; size = 4
_slot_it$3 = -68					; size = 4
_ssaCLIP$ = -64						; size = 4
_slot$4 = -60						; size = 4
_w_count$1$ = -56					; size = 4
__vb$1$ = -56						; size = 4
$T5 = -56						; size = 4
_w_it$6 = -56						; size = 4
_this$ = -52						; size = 4
$T7 = -48						; size = 4
tv1720 = -48						; size = 4
$T8 = -48						; size = 4
__geom$1$ = -44						; size = 4
$T9 = -44						; size = 4
$T10 = -44						; size = 4
_w_offset$11 = -40					; size = 4
__geom$1$ = -36						; size = 4
_W$1$ = -36						; size = 4
$T12 = -36						; size = 4
$T13 = -36						; size = 4
$T14 = -36						; size = 4
$T15 = -32						; size = 4
_a$16 = -32						; size = 4
$T17 = -32						; size = 4
$T18 = -32						; size = 4
_w_start$19 = -32					; size = 4
_w_count$1$ = -28					; size = 4
_w_start$2$ = -28					; size = 4
_w_start$1$ = -28					; size = 4
$T20 = -28						; size = 4
_startV$1$ = -24					; size = 4
__vb$1$ = -24						; size = 4
__vb$1$ = -24						; size = 4
_E$1$ = -24						; size = 4
_C$1$ = -24						; size = 4
_startV$1$ = -24					; size = 4
_w_count$1$ = -24					; size = 4
_W$ = -24						; size = 4
_w_save$21 = -24					; size = 4
_w_verts$22 = -20					; size = 4
__$EHRec$ = -16						; size = 16
?Render@CWallmarksEngine@@QAEXXZ PROC			; CWallmarksEngine::Render
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Render@CWallmarksEngine@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], eax
	mov	DWORD PTR tv2297[ebp], eax

; 329  : //	if (marks.empty())			return;
; 330  : 	// Projection and xform
; 331  : 	float	_43					= Device.mProject._43;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm0, DWORD PTR [eax+656]
	movss	DWORD PTR __43$[ebp], xmm0

; 332  : 	Device.mProject._43			-= ps_r__WallmarkSHIFT; 

	subss	xmm0, DWORD PTR __real@38d1b717
	movss	DWORD PTR [eax+656], xmm0

; 333  : 	RCache.set_xform_world		(Fidentity);

	push	DWORD PTR __imp_?Fidentity@@3U?$_matrix@M@@A
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_world@CBackend@@QAEXABU?$_matrix@M@@@Z

; 334  : 	RCache.set_xform_project	(Device.mProject);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	eax, 600				; 00000258H
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 335  : 
; 336  : 	Fmatrix	mSavedView			= Device.mView;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	lea	ebx, DWORD PTR [eax+536]
	mov	ecx, 16					; 00000010H
	mov	esi, ebx
	lea	edi, DWORD PTR _mSavedView$[ebp]
	rep movsd

; 337  : 	Fvector	mViewPos			;
; 338  : 			mViewPos.mad		(Device.vCameraPosition, Device.vCameraDirection,ps_r__WallmarkSHIFT_V);

	lea	edx, DWORD PTR [eax+500]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 144  : 		x = p.x + d.x*m;

	movss	xmm0, DWORD PTR [edx]
	movss	xmm1, DWORD PTR __real@38d1b717
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+488]
	movss	DWORD PTR _mViewPos$[ebp], xmm0

; 145  : 		y = p.y + d.y*m;

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+492]
	movss	DWORD PTR _mViewPos$[ebp+4], xmm0

; 146  : 		z = p.z + d.z*m;

	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+496]
	movss	DWORD PTR _mViewPos$[ebp+8], xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 339  : 	Device.mView.build_camera_dir	(mViewPos,Device.vCameraDirection,Device.vCameraTop);

	add	eax, 512				; 00000200H
	push	eax
	push	edx
	lea	eax, DWORD PTR _mViewPos$[ebp]
	push	eax
	mov	ecx, ebx
	call	?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ; _matrix<float>::build_camera_dir

; 340  : 	RCache.set_xform_view		(Device.mView);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	eax, 536				; 00000218H
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z

; 341  : 
; 342  : 	Device.Statistic->RenderDUMP_WM.Begin	();

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [eax+436]
	add	esi, 2152				; 00000868H
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 173  : 	ICF void	Begin			()		{	if (!g_bEnableStatGather) return;	count++; T.Start();				}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN434@Render
	inc	DWORD PTR [esi+68]

; 73   : 		if (bPause)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN434@Render

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}

	call	DWORD PTR __imp_?QPC@CPU@@YA_KXZ
	sub	eax, DWORD PTR [esi+16]
	sbb	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], edx

; 78   : 		m_real_ticks	= 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 79   : 		m_ticks			= 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN434@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 343  : 	Device.Statistic->RenderDUMP_WMS_Count	= 0;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	mov	DWORD PTR [eax+2232], 0

; 344  : 	Device.Statistic->RenderDUMP_WMD_Count	= 0;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	mov	DWORD PTR [eax+2236], 0

; 345  : 	Device.Statistic->RenderDUMP_WMT_Count	= 0;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	mov	DWORD PTR [eax+2240], 0

; 346  : 
; 347  : 	float	ssaCLIP				= r_ssaDISCARD/4;

	movss	xmm0, DWORD PTR ?r_ssaDISCARD@@3MA
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _ssaCLIP$[ebp], xmm0

; 348  : 
; 349  : 	lock.Enter		();			// Physics may add wallmarks in parallel with rendering

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ebx+1504]
	mov	DWORD PTR tv136[ebp], ecx
	call	DWORD PTR __imp_?Enter@xrCriticalSection@@QAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ebx+12]
$LN442@Render:
	mov	DWORD PTR _slot_it$3[ebp], esi
	mov	eax, DWORD PTR tv2297[ebp]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 351  : 	for (WMSlotVecIt slot_it=marks.begin(); slot_it!=marks.end(); slot_it++){

	je	$LN3@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR $T8[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN59@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T8[ebp]
$LN59@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 307  : 	w_offset				= 0;

	mov	DWORD PTR _w_offset$11[ebp], 0

; 308  : 	w_verts					= (FVF::LIT*)RCache.Vertex.Lock	(MAX_TRIS*3,hGeom->vb_stride,w_offset);

	lea	ecx, DWORD PTR _w_offset$11[ebp]
	push	ecx
	push	DWORD PTR [eax+20]
	push	3072					; 00000c00H
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	DWORD PTR _w_start$1$[ebp], eax
	mov	DWORD PTR _w_verts$22[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 355  : 		wm_slot* slot			= *slot_it;	

	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _slot$4[ebp], edi
	mov	DWORD PTR tv1720[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [edi+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 357  : 		for (StaticWMVecIt w_it=slot->static_items.begin(); w_it!=slot->static_items.end(); ){

	je	$LN6@Render
$LL5@Render:

; 358  : 			static_wallmark* W	= *w_it;

	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _W$1$[ebp], edi

; 359  : 			if (RImplementation.ViewBase.testSphere_dirty(W->bounds.P,W->bounds.R)){

	push	ecx
	fld	DWORD PTR [edi+12]
	fstp	DWORD PTR [esp]
	push	edi
	mov	ecx, OFFSET ?RImplementation@@3VCRender@@A+8
	call	DWORD PTR __imp_?testSphere_dirty@CFrustum@@QBEHAAU?$_vector3@M@@M@Z
	test	eax, eax
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	je	$LN11@Render

; 360  : 				Device.Statistic->RenderDUMP_WMS_Count++;

	mov	eax, DWORD PTR [eax+436]
	inc	DWORD PTR [eax+2232]

; 361  : 				float dst	= Device.vCameraPosition.distance_to_sqr(W->bounds.P);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	subss	xmm1, DWORD PTR [edi+4]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, DWORD PTR [edi+8]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 362  : 				float ssa	= W->bounds.R * W->bounds.R / dst;

	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, xmm0
	divss	xmm0, xmm2

; 363  : 				if (ssa>=ssaCLIP)	{

	comiss	xmm0, DWORD PTR _ssaCLIP$[ebp]
	jb	$LN148@Render

; 364  : 					u32 w_count		= u32(w_verts-w_start);

	mov	ebx, DWORD PTR _w_verts$22[ebp]
	mov	eax, ebx
	mov	edx, DWORD PTR _w_start$1$[ebp]
	sub	eax, edx
	sar	eax, 3
	imul	ecx, eax, -1431655765
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+20]
	sub	eax, DWORD PTR [edi+16]
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 365  : 					if ((w_count+W->verts.size())>=(MAX_TRIS*3)){

	add	eax, ecx
	cmp	eax, 3072				; 00000c00H
	jb	$LN14@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _slot$4[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T17[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN90@Render
	inc	DWORD PTR [eax]
	mov	ebx, DWORD PTR _w_verts$22[ebp]
$LN90@Render:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR $T20[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN95@Render
	inc	DWORD PTR [eax]
	mov	ebx, DWORD PTR _w_verts$22[ebp]
	mov	eax, DWORD PTR $T20[ebp]
$LN95@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 314  : 	u32 w_count					= u32(w_verts-w_start);

	sub	ebx, edx
	sar	ebx, 3
	imul	ebx, ebx, -1431655765
	mov	DWORD PTR _w_count$1$[ebp], ebx

; 315  : 	RCache.Vertex.Unlock		(w_count,hGeom->vb_stride);

	push	DWORD PTR [eax+20]
	push	ebx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 316  : 	if (w_count)			

	test	ebx, ebx
	je	$LN99@Render

; 317  : 	{
; 318  : 		RCache.set_Shader		(shader);

	push	0
	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z

; 319  : 		RCache.set_Geometry		(hGeom);

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 175  : 	ICF void						set_Geometry(ref_geom& _geom) { set_Geometry(&*_geom); }

	mov	ecx, DWORD PTR $T20[ebp]
	mov	DWORD PTR __geom$1$[ebp], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [ebx+592], edx
	je	SHORT $LN112@Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [ebx+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+348]
	mov	ecx, DWORD PTR __geom$1$[ebp]
$LN112@Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __vb$1$[ebp], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [ebx+596], eax
	jne	SHORT $LN116@Render
	cmp	DWORD PTR [ebx+604], edx
	je	SHORT $LN115@Render
$LN116@Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [ebx+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [ebx+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	0
	push	DWORD PTR __vb$1$[ebp]
	push	0
	push	eax
	call	DWORD PTR [ecx+400]
	mov	ecx, DWORD PTR __geom$1$[ebp]
$LN115@Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ecx+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [ebx+600], edx
	je	SHORT $LN119@Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [ebx+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+416]
$LN119@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _w_count$1$[ebp]
	mov	ebx, edx
	shr	ebx, 1
	mov	eax, DWORD PTR _w_offset$11[ebp]
	mov	DWORD PTR _startV$1$[ebp], eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 209  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]

; 210  : 	stat.verts += 3 * PC;

	lea	eax, DWORD PTR [ebx+ebx*2]
	add	DWORD PTR [ecx+9020], eax

; 211  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], ebx

; 212  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN128@Render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN127@Render
$LN128@Render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN127@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	DWORD PTR _startV$1$[ebp]
	push	4
	push	eax
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 323  : 		Device.Statistic->RenderDUMP_WMT_Count += w_count/3;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2240], ebx
$LN99@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T20[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR $T17[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR $T18[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN139@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T18[ebp]
$LN139@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 307  : 	w_offset				= 0;

	mov	DWORD PTR _w_offset$11[ebp], 0

; 308  : 	w_verts					= (FVF::LIT*)RCache.Vertex.Lock	(MAX_TRIS*3,hGeom->vb_stride,w_offset);

	lea	ecx, DWORD PTR _w_offset$11[ebp]
	push	ecx
	push	DWORD PTR [eax+20]
	push	3072					; 00000c00H
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	DWORD PTR _w_start$1$[ebp], eax
	mov	DWORD PTR _w_verts$22[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T18[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	ebx, DWORD PTR _w_verts$22[ebp]
$LN14@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 102  : 	int			aC		= iFloor	( a * 255.f);	clamp	(aC,0,255);

	movss	xmm1, DWORD PTR [edi+28]
	mulss	xmm1, DWORD PTR __real@3f59999a
	movss	xmm0, DWORD PTR __real@437f0000
	subss	xmm0, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR _a$16[ebp], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, DWORD PTR _a$16[ebp]
	sar	eax, 23					; 00000017H
	movzx	eax, al
	mov	ecx, 158				; 0000009eH
	sub	ecx, eax

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	eax, DWORD PTR _a$16[ebp]
	mov	edi, eax
	or	edi, -8388608				; ff800000H
	shl	edi, 8
	shr	edi, cl

; 86   :     exponent		+= 31-127;

	sub	ecx, 96					; 00000060H

; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edx, 1
	shl	edx, cl
	dec	edx
	sar	edx, 8
	and	edx, eax
	neg	edx
	sbb	edx, edx
	inc	edx

; 89   :         exponent	-=	(31-127)+32;

	add	ecx, 64					; 00000040H

; 90   :         exponent	>>=	31;

	sar	ecx, 31					; 0000001fH

; 91   :         a			>>=	31;

	sar	eax, 31					; 0000001fH
	mov	DWORD PTR _C$1$[ebp], eax
	and	eax, edx

; 92   :         r			-=	(imask&a);

	sub	edi, eax

; 93   :         r			&=	exponent;

	and	edi, ecx
	mov	edx, DWORD PTR _C$1$[ebp]
	xor	edx, edi
; File I:\Vitalya\mine\NSProjectX\xrCore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	jge	SHORT $LN154@Render
	xor	edx, edx
	jmp	SHORT $LN156@Render
$LN154@Render:
	cmp	edx, 255				; 000000ffH
	mov	eax, 255				; 000000ffH
	cmovg	edx, eax
$LN156@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	edx, 24					; 00000018H
	or	edx, 8421504				; 00808080H
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 105  : 	FVF::LIT*	E		= &*W->verts.end	();

	mov	edi, DWORD PTR _W$1$[ebp]
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _E$1$[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	mov	ecx, DWORD PTR [edi+16]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 106  : 	for (; S!=E; S++, V++){

	cmp	ecx, eax
	je	SHORT $LN436@Render
	mov	edi, eax
$LL149@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ebx]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ebx+4]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ebx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 108  : 		V->color		= C;

	mov	eax, DWORD PTR _w_verts$22[ebp]
	mov	DWORD PTR [eax+12], edx

; 109  : 		V->t.set		(S->t);

	mov	eax, DWORD PTR _w_verts$22[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 18   : 	IC SelfRef set(const Self &p)					{ x=p.x; y=p.y;					return *this;	}

	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 106  : 	for (; S!=E; S++, V++){

	add	ecx, 24					; 00000018H
	mov	ebx, DWORD PTR _w_verts$22[ebp]
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _w_verts$22[ebp], ebx
	cmp	ecx, edi
	jne	SHORT $LL149@Render
	mov	edi, DWORD PTR _W$1$[ebp]
$LN436@Render:

; 366  : 						FlushStream	(hGeom,slot->shader,w_offset,w_verts,w_start,FALSE);
; 367  : 						BeginStream	(hGeom,w_offset,w_verts,w_start);
; 368  : 					}
; 369  : 					static_wm_render	(W,w_verts);
; 370  : 				}
; 371  : 				W->ttl	-= 0.1f*Device.fTimeDelta;	// visible wallmarks fade much slower

	mov	ebx, DWORD PTR _this$[ebp]
$LN148@Render:
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	xmm0, DWORD PTR [eax+468]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	xmm1, DWORD PTR [edi+28]
	subss	xmm1, xmm0

; 372  : 			} else {

	jmp	SHORT $LN439@Render
$LN11@Render:

; 373  : 				W->ttl	-= Device.fTimeDelta;

	movss	xmm1, DWORD PTR [edi+28]
	subss	xmm1, DWORD PTR [eax+468]
$LN439@Render:

; 374  : 			}
; 375  : 			if (W->ttl<=EPS){	

	movss	DWORD PTR [edi+28], xmm1
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm1
	jb	SHORT $LN15@Render

; 376  : 				static_wm_destroy	(W);

	mov	DWORD PTR _W$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR [ebx+4]
	cmp	eax, DWORD PTR [ebx+8]
	je	SHORT $LN183@Render

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	DWORD PTR [eax], edi

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ebx+4], 4
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 377  : 				*w_it				= slot->static_items.back();

	mov	edi, DWORD PTR _slot$4[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax-4]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	add	DWORD PTR [edi+8], -4			; fffffffcH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 379  : 			}else{

	jmp	SHORT $LN440@Render
$LN183@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR _W$[ebp]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 377  : 				*w_it				= slot->static_items.back();

	mov	edi, DWORD PTR _slot$4[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax-4]
	mov	DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1390 :         --_Mylast;

	add	DWORD PTR [edi+8], -4			; fffffffcH
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 379  : 			}else{

	jmp	SHORT $LN440@Render
$LN15@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4
	mov	edi, DWORD PTR _slot$4[ebp]
$LN440@Render:

; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR [edi+8]
	cmp	esi, eax
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 357  : 		for (StaticWMVecIt w_it=slot->static_items.begin(); w_it!=slot->static_items.end(); ){

	jne	$LL5@Render
$LN6@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR $T13[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN197@Render
	inc	DWORD PTR [eax]
$LN197@Render:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR $T10[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN202@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T10[ebp]
$LN202@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 314  : 	u32 w_count					= u32(w_verts-w_start);

	mov	ecx, DWORD PTR _w_verts$22[ebp]
	sub	ecx, DWORD PTR _w_start$1$[ebp]
	sar	ecx, 3
	imul	esi, ecx, -1431655765
	mov	DWORD PTR _w_count$1$[ebp], esi

; 315  : 	RCache.Vertex.Unlock		(w_count,hGeom->vb_stride);

	push	DWORD PTR [eax+20]
	push	esi
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 316  : 	if (w_count)			

	test	esi, esi
	je	$LN206@Render

; 317  : 	{
; 318  : 		RCache.set_Shader		(shader);

	push	0
	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z

; 319  : 		RCache.set_Geometry		(hGeom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 175  : 	ICF void						set_Geometry(ref_geom& _geom) { set_Geometry(&*_geom); }

	mov	edi, DWORD PTR $T10[ebp]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [edi+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN219@Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+348]
$LN219@Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR __vb$1$[ebp], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], eax
	jne	SHORT $LN223@Render
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN222@Render
$LN223@Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	0
	push	DWORD PTR __vb$1$[ebp]
	push	0
	push	eax
	call	DWORD PTR [ecx+400]
$LN222@Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN226@Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+416]
$LN226@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _w_count$1$[ebp]
	mov	esi, edx
	shr	esi, 1
	mov	edi, DWORD PTR _w_offset$11[ebp]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 209  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]

; 210  : 	stat.verts += 3 * PC;

	lea	eax, DWORD PTR [esi+esi*2]
	add	DWORD PTR [ecx+9020], eax

; 211  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], esi

; 212  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN235@Render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN234@Render
$LN235@Render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN234@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	edi
	push	4
	push	eax
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 323  : 		Device.Statistic->RenderDUMP_WMT_Count += w_count/3;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2240], esi
	mov	edi, DWORD PTR _slot$4[ebp]
$LN206@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T10[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR $T14[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN246@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T14[ebp]
$LN246@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 307  : 	w_offset				= 0;

	mov	DWORD PTR _w_offset$11[ebp], 0

; 308  : 	w_verts					= (FVF::LIT*)RCache.Vertex.Lock	(MAX_TRIS*3,hGeom->vb_stride,w_offset);

	lea	ecx, DWORD PTR _w_offset$11[ebp]
	push	ecx
	push	DWORD PTR [eax+20]
	push	3072					; 00000c00H
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	ebx, eax
	mov	DWORD PTR _w_start$2$[ebp], ebx
	mov	DWORD PTR _w_verts$22[ebp], ebx

; 309  : 	w_start					= w_verts;

	mov	DWORD PTR _w_start$19[ebp], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	edi, DWORD PTR [edi+16]
	mov	eax, DWORD PTR tv1720[ebp]
$LN441@Render:

; 150  :         return _Ptr == _Right._Ptr;

	mov	DWORD PTR _w_it$6[ebp], edi
	cmp	edi, DWORD PTR [eax+20]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 388  : 		for (xr_vector<intrusive_ptr<CSkeletonWallmark> >::iterator w_it=slot->skeleton_items.begin(); w_it!=slot->skeleton_items.end(); w_it++){

	je	$LN9@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	$LN8@Render

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR _W$2[ebp], esi

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 403  : 			float dst	= Device.vCameraPosition.distance_to_sqr(W->m_Bounds.P);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm1, DWORD PTR [eax+492]
	subss	xmm1, DWORD PTR [esi+64]
	movss	xmm2, DWORD PTR [eax+488]
	subss	xmm2, DWORD PTR [esi+60]
	movss	xmm0, DWORD PTR [eax+496]
	subss	xmm0, DWORD PTR [esi+68]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 404  : 			float ssa	= W->m_Bounds.R * W->m_Bounds.R / dst;

	movss	xmm0, DWORD PTR [esi+72]
	mulss	xmm0, xmm0
	divss	xmm0, xmm2

; 405  : 			if (ssa>=ssaCLIP){

	comiss	xmm0, DWORD PTR _ssaCLIP$[ebp]
	jb	$LN24@Render

; 406  : 				Device.Statistic->RenderDUMP_WMD_Count++;

	mov	eax, DWORD PTR [eax+436]
	inc	DWORD PTR [eax+2236]

; 407  : 				u32 w_count		= u32(w_verts-w_start);

	mov	eax, DWORD PTR _w_verts$22[ebp]
	sub	eax, ebx
	sar	eax, 3
	imul	ebx, eax, -1431655765

; 408  : 				if ((w_count+W->VCount())>=(MAX_TRIS*3)){

	mov	ecx, esi
	call	DWORD PTR __imp_?VCount@CSkeletonWallmark@@QAEIXZ
	add	eax, ebx
	cmp	eax, 3072				; 00000c00H
	jb	$LN435@Render
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _slot$4[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T15[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN295@Render
	inc	DWORD PTR [eax]
$LN295@Render:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR $T9[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN300@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T9[ebp]
$LN300@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 314  : 	u32 w_count					= u32(w_verts-w_start);

	mov	ecx, DWORD PTR _w_verts$22[ebp]
	sub	ecx, DWORD PTR _w_start$2$[ebp]
	sar	ecx, 3
	imul	ebx, ecx, -1431655765
	mov	DWORD PTR _w_count$1$[ebp], ebx

; 315  : 	RCache.Vertex.Unlock		(w_count,hGeom->vb_stride);

	push	DWORD PTR [eax+20]
	push	ebx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 316  : 	if (w_count)			

	test	ebx, ebx
	je	$LN304@Render

; 317  : 	{
; 318  : 		RCache.set_Shader		(shader);

	push	0
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z

; 319  : 		RCache.set_Geometry		(hGeom);

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 175  : 	ICF void						set_Geometry(ref_geom& _geom) { set_Geometry(&*_geom); }

	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR __geom$1$[ebp], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [ebx+592], edx
	je	SHORT $LN317@Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [ebx+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+348]
	mov	ecx, DWORD PTR __geom$1$[ebp]
$LN317@Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __vb$1$[ebp], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [ebx+596], eax
	jne	SHORT $LN321@Render
	cmp	DWORD PTR [ebx+604], edx
	je	SHORT $LN320@Render
$LN321@Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [ebx+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [ebx+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	0
	push	DWORD PTR __vb$1$[ebp]
	push	0
	push	eax
	call	DWORD PTR [ecx+400]
	mov	ecx, DWORD PTR __geom$1$[ebp]
$LN320@Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ecx+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [ebx+600], edx
	je	SHORT $LN324@Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [ebx+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+416]
$LN324@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 320  : 		if (bSuppressCull)		RCache.set_CullMode (CULL_NONE);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 1
	je	SHORT $LN327@Render
	mov	DWORD PTR [eax+8916], 1
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	1
	push	22					; 00000016H
	push	eax
	call	DWORD PTR [ecx+228]
$LN327@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _w_count$1$[ebp]
	mov	ebx, edx
	shr	ebx, 1
	mov	eax, DWORD PTR _w_offset$11[ebp]
	mov	DWORD PTR _startV$1$[ebp], eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 209  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]

; 210  : 	stat.verts += 3 * PC;

	lea	eax, DWORD PTR [ebx+ebx*2]
	add	DWORD PTR [ecx+9020], eax

; 211  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], ebx

; 212  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN333@Render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN332@Render
$LN333@Render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN332@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	DWORD PTR _startV$1$[ebp]
	push	4
	push	eax
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 322  : 		if (bSuppressCull)		RCache.set_CullMode	(CULL_CCW);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 3
	je	SHORT $LN336@Render
	mov	DWORD PTR [eax+8916], 3
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	3
	push	22					; 00000016H
	push	eax
	call	DWORD PTR [ecx+228]
$LN336@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 323  : 		Device.Statistic->RenderDUMP_WMT_Count += w_count/3;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2240], ebx
$LN304@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR $T12[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN344@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T12[ebp]
$LN344@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 307  : 	w_offset				= 0;

	mov	DWORD PTR _w_offset$11[ebp], 0

; 308  : 	w_verts					= (FVF::LIT*)RCache.Vertex.Lock	(MAX_TRIS*3,hGeom->vb_stride,w_offset);

	lea	ecx, DWORD PTR _w_offset$11[ebp]
	push	ecx
	push	DWORD PTR [eax+20]
	push	3072					; 00000c00H
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z
	mov	ebx, eax
	mov	DWORD PTR _w_start$2$[ebp], ebx
	mov	DWORD PTR _w_verts$22[ebp], ebx

; 309  : 	w_start					= w_verts;

	mov	DWORD PTR _w_start$19[ebp], ebx
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 408  : 				if ((w_count+W->VCount())>=(MAX_TRIS*3)){

	jmp	SHORT $LN19@Render
$LN435@Render:
	mov	ebx, DWORD PTR _w_start$2$[ebp]
$LN19@Render:

; 409  : 					FlushStream	(hGeom,slot->shader,w_offset,w_verts,w_start,TRUE);
; 410  : 					BeginStream	(hGeom,w_offset,w_verts,w_start);
; 411  : 				}
; 412  : 
; 413  : 				FVF::LIT	*w_save = w_verts;

	mov	eax, DWORD PTR _w_verts$22[ebp]
	mov	DWORD PTR _w_save$21[ebp], eax

; 414  : 				try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	fwait

; 415  : 					W->Parent()->RenderWallmark	(W,w_verts);

	lea	eax, DWORD PTR _w_verts$22[ebp]
	push	eax
	push	ecx
	mov	eax, esp
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [eax], 0

; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [eax], esi

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 415  : 					W->Parent()->RenderWallmark	(W,w_verts);

	mov	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_?RenderWallmark@CKinematics@@QAEXV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAPAULIT@FVF@@@Z

; 416  : 				} catch (...)
; 417  : 				{

	fwait
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN24@Render
__catch$?Render@CWallmarksEngine@@QAEXXZ$0:

; 418  : 					Msg		("! Failed to render dynamic wallmark");

	push	OFFSET ??_C@_0CE@POEPPKEP@?$CB?5Failed?5to?5render?5dynamic?5wall@
	call	DWORD PTR __imp_?Msg@@YAXPBDZZ
	add	esp, 4

; 419  : 					w_verts = w_save;

	mov	eax, DWORD PTR _w_save$21[ebp]
	mov	DWORD PTR _w_verts$22[ebp], eax

; 420  : 				}

	mov	eax, $LN25@Render
	ret	0
$LN25@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ebx, DWORD PTR _w_start$19[ebp]
	mov	DWORD PTR _w_start$2$[ebp], ebx
	mov	edi, DWORD PTR _w_it$6[ebp]
	mov	esi, DWORD PTR _W$2[ebp]
$LN24@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 47   : 	--m_object->base_type::m_ref_count;

	add	DWORD PTR [esi], -1

; 48   : 	if (!m_object->base_type::m_ref_count)

	jne	SHORT $LN437@Render

; 49   : 		m_object->base_type::_release	(m_object);

	push	esi
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN437@Render:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	eax, DWORD PTR tv1720[ebp]
$LN8@Render:
	add	edi, 4
	jmp	$LN441@Render
$LN9@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 426  : 		slot->skeleton_items.clear();

	mov	ecx, DWORD PTR _slot$4[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+20], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T5[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN371@Render
	inc	DWORD PTR [eax]
$LN371@Render:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR $T7[ebp], eax
	test	eax, eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN376@Render
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR $T7[ebp]
$LN376@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 314  : 	u32 w_count					= u32(w_verts-w_start);

	mov	ecx, DWORD PTR _w_verts$22[ebp]
	sub	ecx, ebx
	sar	ecx, 3
	imul	ebx, ecx, -1431655765
	mov	DWORD PTR _w_count$1$[ebp], ebx

; 315  : 	RCache.Vertex.Unlock		(w_count,hGeom->vb_stride);

	push	DWORD PTR [eax+20]
	push	ebx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 316  : 	if (w_count)			

	test	ebx, ebx
	je	$LN380@Render

; 317  : 	{
; 318  : 		RCache.set_Shader		(shader);

	push	0
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z

; 319  : 		RCache.set_Geometry		(hGeom);

	mov	esi, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend.h

; 175  : 	ICF void						set_Geometry(ref_geom& _geom) { set_Geometry(&*_geom); }

	mov	edi, DWORD PTR $T7[ebp]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [esi+592], edx
	je	SHORT $LN393@Render

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [esi+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+348]
$LN393@Render:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	edx, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [edi+12]

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [esi+596], ebx
	jne	SHORT $LN397@Render
	cmp	DWORD PTR [esi+604], edx
	je	SHORT $LN396@Render
$LN397@Render:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [esi+596], ebx

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [esi+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	0
	push	ebx
	push	0
	push	eax
	call	DWORD PTR [ecx+400]
$LN396@Render:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [edi+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [esi+600], edx
	je	SHORT $LN400@Render

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [esi+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+416]
$LN400@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 320  : 		if (bSuppressCull)		RCache.set_CullMode (CULL_NONE);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 1
	je	SHORT $LN403@Render
	mov	DWORD PTR [eax+8916], 1
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	1
	push	22					; 00000016H
	push	eax
	call	DWORD PTR [ecx+228]
$LN403@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 321  : 		RCache.Render			(D3DPT_TRIANGLELIST,w_offset,w_count/3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR _w_count$1$[ebp]
	mov	esi, edx
	shr	esi, 1
	mov	edi, DWORD PTR _w_offset$11[ebp]
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 209  : 	stat.calls++;

	inc	DWORD PTR [ecx+9024]

; 210  : 	stat.verts += 3 * PC;

	lea	eax, DWORD PTR [esi+esi*2]
	add	DWORD PTR [ecx+9020], eax

; 211  : 	stat.polys += PC;

	add	DWORD PTR [ecx+9016], esi

; 212  : 	constants.flush();

	add	ecx, 608				; 00000260H
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN409@Render
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN408@Render
$LN409@Render:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN408@Render:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 213  : 	CHK_DX(HW.pDevice->DrawPrimitive(T, startV, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	edi
	push	4
	push	eax
	call	DWORD PTR [ecx+324]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 322  : 		if (bSuppressCull)		RCache.set_CullMode	(CULL_CCW);

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 266  : 	if (cull_mode != _mode) { cull_mode = _mode;			CHK_DX(HW.pDevice->SetRenderState(D3DRS_CULLMODE, _mode)); }

	cmp	DWORD PTR [eax+8916], 3
	je	SHORT $LN412@Render
	mov	DWORD PTR [eax+8916], 3
	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	push	3
	push	22					; 00000016H
	push	eax
	call	DWORD PTR [ecx+228]
$LN412@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 323  : 		Device.Statistic->RenderDUMP_WMT_Count += w_count/3;

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	eax, DWORD PTR [eax+436]
	add	DWORD PTR [eax+2240], esi
$LN380@Render:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	mov	esi, DWORD PTR _slot_it$3[ebp]
	add	esi, 4
	mov	ebx, DWORD PTR _this$[ebp]
	jmp	$LN442@Render
$LN3@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 431  : 	lock.Leave();				// Physics may add wallmarks in parallel with rendering

	mov	ecx, DWORD PTR tv136[ebp]
	call	DWORD PTR __imp_?Leave@xrCriticalSection@@QAEXXZ

; 432  : 
; 433  : 	// Level-wmarks
; 434  : 	RImplementation.r_dsgraph_render_wmarks	();
; 435  : 	Device.Statistic->RenderDUMP_WM.End		();

	mov	edi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	mov	esi, DWORD PTR [edi+436]
; File I:\Vitalya\mine\NSProjectX\xrCore\FTimer.h

; 174  : 	ICF void	End				()		{	if (!g_bEnableStatGather) return;	accum += T.GetElapsed_ticks();	}

	mov	eax, DWORD PTR __imp_?g_bEnableStatGather@@3HA
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN418@Render
	lea	ecx, DWORD PTR [esi+2152]
	call	DWORD PTR __imp_?GetElapsed_ticks@CTimer@@QBE_KXZ
	add	DWORD PTR [esi+2208], eax
	adc	DWORD PTR [esi+2212], edx
	mov	edi, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
$LN418@Render:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\WallmarksEngine.cpp

; 438  : 	Device.mView				= mSavedView;

	add	edi, 536				; 00000218H
	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _mSavedView$[ebp]
	rep movsd

; 439  : 	Device.mProject._43			= _43;

	movss	xmm0, DWORD PTR __43$[ebp]
	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	movss	DWORD PTR [eax+656], xmm0

; 440  : 	RCache.set_xform_view		(Device.mView);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	eax, 536				; 00000218H
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_view@CBackend@@QAEXABU?$_matrix@M@@@Z

; 441  : 	RCache.set_xform_project	(Device.mProject);

	mov	eax, DWORD PTR __imp_?Device@@3VCRenderDevice@@A
	add	eax, 600				; 00000258H
	push	eax
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	call	DWORD PTR __imp_?set_xform_project@CBackend@@QAEXABU?$_matrix@M@@@Z

; 442  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?Render@CWallmarksEngine@@QAEXXZ:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?Render@CWallmarksEngine@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Render@CWallmarksEngine@@QAEXXZ ENDP			; CWallmarksEngine::Render
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEAAULIT@FVF@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEAAULIT@FVF@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEAAULIT@FVF@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEAAPAUstatic_wallmark@CWallmarksEngine@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEAAPAUstatic_wallmark@CWallmarksEngine@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEAAPAUstatic_wallmark@CWallmarksEngine@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEAAPAUwm_slot@WallmarksEngine@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEAAPAUwm_slot@WallmarksEngine@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEAAPAUwm_slot@WallmarksEngine@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ PROC ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ ENDP ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ PROC ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAE@XZ ENDP ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@2@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$dead$ = 8					; size = 4
?reserve@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXI@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jb	?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);
; 1364 :         }
; 1365 :     }

	ret	4
?reserve@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXI@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR __Val$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN14@push_back

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN14@push_back:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN12@emplace_ba

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN12@emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back_with_unused_capacity<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@Emplace_ba

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN17@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 722  :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back_with_unused_capacity@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAE?A_TABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back_with_unused_capacity<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ PROC ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ ENDP ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ PROC ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAE@XZ ENDP ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEAAPAUwm_slot@WallmarksEngine@@XZ
_TEXT	SEGMENT
?back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEAAPAUwm_slot@WallmarksEngine@@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 4

; 1612 :     }

	ret	0
?back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEAAPAUwm_slot@WallmarksEngine@@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@2@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$dead$ = 8					; size = 4
?reserve@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXI@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jb	?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);
; 1364 :         }
; 1365 :     }

	ret	4
?reserve@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXI@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>

; 747  :         // insert by moving into element at end, provide strong guarantee
; 748  :         emplace_back(_STD move(_Val));
; 749  :     }

	ret	4
?push_back@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::emplace_back<WallmarksEngine::wm_slot *>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::emplace_back<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back_with_unused_capacity<WallmarksEngine::wm_slot *>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAE?A_T$$QAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back_with_unused_capacity<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::~vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@I@Z PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::operator[], COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	4
??A?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@I@Z ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QBEIXZ PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QBEIXZ ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAE@XZ ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@XZ
_TEXT	SEGMENT
?back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::back, COMDAT
; _this$ = ecx

; 1606 :         auto& _My_data = _Mypair._Myval2;
; 1607 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1608 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1609 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1610 : 
; 1611 :         return _My_data._Mylast[-1];

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, 4

; 1612 :     }

	ret	0
?back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEAAPAUstatic_wallmark@CWallmarksEngine@@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?empty@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBE_NXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::empty, COMDAT
; _this$ = ecx

; 1530 :         auto& _My_data = _Mypair._Myval2;
; 1531 :         return _My_data._Myfirst == _My_data._Mylast;

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1532 :     }

	ret	0
?empty@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBE_NXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@2@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?pop_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::pop_back, COMDAT
; _this$ = ecx

; 1381 :         auto& _My_data   = _Mypair._Myval2;
; 1382 :         pointer& _Mylast = _My_data._Mylast;
; 1383 : 
; 1384 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1386 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1387 : 
; 1388 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1389 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1390 :         --_Mylast;

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1391 :     }

	ret	0
?pop_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?reserve@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$dead$ = 8					; size = 4
?reserve@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXI@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::reserve, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1357 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jb	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);
; 1364 :         }
; 1365 :     }

	ret	4
?reserve@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXI@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXABQAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXABQAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::push_back, COMDAT
; _this$ = ecx

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXABQAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::emplace_back<CWallmarksEngine::static_wallmark * const &>, COMDAT
; _this$ = ecx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::emplace_back<CWallmarksEngine::static_wallmark * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back_with_unused_capacity<CWallmarksEngine::static_wallmark * const &>, COMDAT
; _this$ = ecx

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 4

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAE?A_TABQAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back_with_unused_capacity<CWallmarksEngine::static_wallmark * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::~vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ PROC ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear, COMDAT
; _this$ = ecx

; 132  : 	void	clear				()									{ clear_and_free	();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ ENDP ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QBEIXZ
_TEXT	SEGMENT
?size@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QBEIXZ PROC ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::size, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QBEIXZ ENDP ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@2@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXABULIT@FVF@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXABULIT@FVF@@@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::push_back, COMDAT
; _this$ = ecx

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	push	esi

; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN4@push_back
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
	pop	esi

; 743  :         emplace_back(_Val);
; 744  :     }

	ret	4
?push_back@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXABULIT@FVF@@@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?A_TABULIT@FVF@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?A_TABULIT@FVF@@@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::emplace_back<FVF::LIT const &>, COMDAT
; _this$ = ecx

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

	push	esi

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, DWORD PTR [ecx+8]
	je	SHORT $LN2@emplace_ba
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp]
	push	esi
	call	??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
	pop	esi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

	ret	4
??$emplace_back@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE?A_TABULIT@FVF@@@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::emplace_back<FVF::LIT const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAE?A_TABULIT@FVF@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAE?A_TABULIT@FVF@@@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_back_with_unused_capacity<FVF::LIT const &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Val_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAE?A_TABULIT@FVF@@@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_back_with_unused_capacity<FVF::LIT const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@ABV0@@Z PROC ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>, COMDAT
; _this$ = ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN6@resptr_cor
	inc	DWORD PTR [eax]
$LN6@resptr_cor:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, ecx
	ret	4
??0?$resptr_core@UShader@@Uresptrcode_shader@@@@QAE@ABV0@@Z ENDP ; resptr_core<Shader,resptrcode_shader>::resptr_core<Shader,resptrcode_shader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z
_TEXT	SEGMENT
_vFrom$ = 8						; size = 4
_vView$ = 12						; size = 4
_vUp$$sroa$343$1$ = 16					; size = 4
_vWorldUp$ = 16						; size = 4
?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z PROC ; _matrix<float>::build_camera_dir, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	edx, DWORD PTR _vView$[esp-4]
	mov	eax, DWORD PTR _vWorldUp$[esp-4]
	movss	xmm4, DWORD PTR [edx]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm5, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm7, DWORD PTR [edx+8]
	mulss	xmm0, xmm5

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm6, xmm7

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm4
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, xmm7
	addss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 464  : 		vUp.mul	(vView, -fDotProduct).add(vWorldUp).normalize();

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm4, xmm2
	mulss	xmm5, xmm2

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm4, DWORD PTR [eax]

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm6, xmm2

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm5, DWORD PTR [eax+4]
	addss	xmm6, DWORD PTR [eax+8]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _vFrom$[esp-4]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm0, xmm4

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm1, xmm5
	mulss	xmm1, xmm5

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm2, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm1, xmm2
	mulss	xmm1, xmm4

; 191  : 		x *= mag;

	movaps	xmm4, xmm2

; 192  : 		y *= mag;

	mulss	xmm2, xmm6
	mulss	xmm4, xmm5

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm2

; 192  : 		y *= mag;

	movss	DWORD PTR _vUp$$sroa$343$1$[esp-4], xmm2

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, DWORD PTR [edx+4]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm2, DWORD PTR [edx]
	movaps	xmm3, xmm4
	mulss	xmm3, xmm7
	subss	xmm3, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm7

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm7, xmm1
	mulss	xmm1, DWORD PTR [edx+4]
	subss	xmm2, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 473  : 		_11 = vRight.x;  _12 = vUp.x;  _13 = vView.x;  _14 = 0.0f;

	movss	DWORD PTR [ecx], xmm3
	movss	DWORD PTR [ecx+4], xmm7
	fld	DWORD PTR [edx]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	subss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 475  : 		_31 = vRight.z;  _32 = vUp.z;  _33 = vView.z;  _34 = 0.0f;

	movss	xmm0, DWORD PTR _vUp$$sroa$343$1$[esp-4]
	fstp	DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+16], xmm2
	mov	DWORD PTR [ecx+12], 0
	movss	DWORD PTR [ecx+20], xmm4
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+28], 0
	movss	DWORD PTR [ecx+32], xmm1
	movss	DWORD PTR [ecx+36], xmm0
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm3, DWORD PTR [eax]
	mulss	xmm2, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax+8]
	addss	xmm3, xmm2
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	addss	xmm3, xmm1
	xorps	xmm3, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 478  : 		_41 = - vFrom.dotproduct(vRight);

	movss	DWORD PTR [ecx+48], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm7, DWORD PTR [eax]
	mulss	xmm4, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [eax+8]
	addss	xmm7, xmm4
	addss	xmm7, xmm0
	xorps	xmm7, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 479  : 		_42 = - vFrom.dotproduct( vUp  );

	movss	DWORD PTR [ecx+52], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [edx]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 482  : 		return *this; 

	mov	eax, ecx
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm1, xmm0
	xorps	xmm1, xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 480  : 		_43 = - vFrom.dotproduct(vView );

	movss	DWORD PTR [ecx+56], xmm1

; 483  : 	}

	ret	12					; 0000000cH
?build_camera_dir@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ENDP ; _matrix<float>::build_camera_dir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z
_TEXT	SEGMENT
_vView$$sroa$393$1$ = -4				; size = 4
_vView$$sroa$374$1$ = 8					; size = 4
_vFrom$ = 8						; size = 4
_vView$$sroa$380$1$ = 12				; size = 4
_vAt$ = 12						; size = 4
_vUp$$sroa$395$1$ = 16					; size = 4
_vWorldUp$ = 16						; size = 4
?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z PROC ; _matrix<float>::build_camera, COMDAT
; _this$ = ecx

; 426  : 	{

	push	ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	mov	eax, DWORD PTR _vAt$[esp]
	mov	edx, DWORD PTR _vFrom$[esp]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	xmm7, DWORD PTR __real@3f800000

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [eax]
	subss	xmm2, DWORD PTR [edx]
	movss	xmm3, DWORD PTR [eax+4]
	subss	xmm3, DWORD PTR [edx+4]
	movss	xmm4, DWORD PTR [eax+8]
	subss	xmm4, DWORD PTR [edx+8]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm2

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mov	eax, DWORD PTR _vWorldUp$[esp]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	mulss	xmm0, xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm1, xmm3
	mulss	xmm1, xmm3

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	divss	xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm5, xmm1

; 191  : 		x *= mag;

	movaps	xmm0, xmm1
	mulss	xmm0, xmm3
	mulss	xmm5, xmm2
	movss	DWORD PTR _vView$$sroa$374$1$[esp], xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR [eax+4]

; 192  : 		y *= mag;

	mulss	xmm1, xmm4

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm6, xmm5
	mulss	xmm6, DWORD PTR [eax]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movss	DWORD PTR _vView$$sroa$393$1$[esp+4], xmm5

; 192  : 		y *= mag;

	movss	DWORD PTR _vView$$sroa$380$1$[esp], xmm1

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm6, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+8]
	addss	xmm6, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 437  : 		vUp.mul	(vView, -fDotProduct).add(vWorldUp).normalize();

	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm4, xmm6
	mulss	xmm4, xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	movaps	xmm5, xmm6
	mulss	xmm5, DWORD PTR _vView$$sroa$374$1$[esp]

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm4, DWORD PTR [eax]

; 42   : 	ICF SelfRef	mul(const Self &a, T s)					{ x=a.x*s;  y=a.y*s;	z=a.z*s;		return *this;	};

	mulss	xmm6, xmm1

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	addss	xmm5, DWORD PTR [eax+4]
	addss	xmm6, DWORD PTR [eax+8]

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4

; 29   : 	ICF	SelfRef	add(const Self &v)						{ x+=v.x;	y+=v.y;		z+=v.z;			return *this;	};

	movaps	xmm1, xmm5
	mulss	xmm1, xmm5

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	divss	xmm7, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 764  :             return (float)sqrt(_X);

	sqrtss	xmm1, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 190  : 		T mag=_sqrt(T(1)/(x*x + y*y + z*z));

	movaps	xmm7, xmm1
	mulss	xmm7, xmm4

; 191  : 		x *= mag;

	movaps	xmm4, xmm1

; 192  : 		y *= mag;

	mulss	xmm1, xmm6

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm6, DWORD PTR _vView$$sroa$374$1$[esp]

; 191  : 		x *= mag;

	mulss	xmm4, xmm5

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm5, DWORD PTR _vView$$sroa$393$1$[esp+4]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm6
	movaps	xmm2, xmm1

; 193  : 		z *= mag;

	movaps	xmm3, xmm4

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm2, xmm5

; 193  : 		z *= mag;

	mulss	xmm3, DWORD PTR _vView$$sroa$380$1$[esp]
	movss	DWORD PTR _vUp$$sroa$395$1$[esp], xmm1

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm1, xmm7
	mulss	xmm1, xmm6
	subss	xmm3, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 446  : 		_11 = vRight.x;  _12 = vUp.x;  _13 = vView.x;  _14 = 0.0f;

	movss	DWORD PTR [ecx+4], xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm7
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 446  : 		_11 = vRight.x;  _12 = vUp.x;  _13 = vView.x;  _14 = 0.0f;

	movss	DWORD PTR [ecx+8], xmm5
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	mulss	xmm0, DWORD PTR _vView$$sroa$380$1$[esp]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 446  : 		_11 = vRight.x;  _12 = vUp.x;  _13 = vView.x;  _14 = 0.0f;

	movss	DWORD PTR [ecx], xmm3
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	subss	xmm2, xmm0

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm5
	subss	xmm1, xmm0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 455  : 		return *this; 

	movss	xmm0, DWORD PTR _vUp$$sroa$395$1$[esp]
	mov	eax, ecx
	movss	xmm5, DWORD PTR _vView$$sroa$380$1$[esp]
	movss	DWORD PTR [ecx+16], xmm2
	movss	DWORD PTR [ecx+20], xmm4
	movss	DWORD PTR [ecx+24], xmm6
	movss	DWORD PTR [ecx+32], xmm1
	movss	DWORD PTR [ecx+36], xmm0
	movss	DWORD PTR [ecx+40], xmm5
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [edx+4]
	mulss	xmm3, DWORD PTR [edx]
	mulss	xmm1, DWORD PTR [edx+8]
	addss	xmm2, xmm3
	movss	xmm5, DWORD PTR _vView$$sroa$393$1$[esp+4]
	addss	xmm2, xmm1
	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 451  : 		_41 = - vFrom.dotproduct(vRight);

	movss	DWORD PTR [ecx+48], xmm2
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm4, DWORD PTR [edx+4]
	mulss	xmm7, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [edx+8]
	addss	xmm4, xmm7
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR _vView$$sroa$380$1$[esp]
	xorps	xmm4, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 452  : 		_42 = - vFrom.dotproduct( vUp  );

	movss	DWORD PTR [ecx+52], xmm4
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, DWORD PTR [edx+4]
	mulss	xmm5, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [edx+8]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 454  : 		_44 = 1.0f;

	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm6, xmm5
	addss	xmm6, xmm0
	xorps	xmm6, xmm1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 453  : 		_43 = - vFrom.dotproduct(vView );

	movss	DWORD PTR [ecx+56], xmm6

; 456  : 	}

	pop	ecx
	ret	12					; 0000000cH
?build_camera@?$_matrix@M@@QAEAAU1@ABU?$_vector3@M@@00@Z ENDP ; _matrix<float>::build_camera
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
;	COMDAT ?rotateZ@?$_matrix@M@@QAEAAU1@M@Z
_TEXT	SEGMENT
_Angle$ = 8						; size = 4
?rotateZ@?$_matrix@M@@QAEAAU1@M@Z PROC			; _matrix<float>::rotateZ, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	DWORD PTR _Angle$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 294  : 		return *this;

	mov	eax, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fld	ST(0)
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 653  :             return (float)cos(_X);

	fcos
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 290  : 		i.set		(cosa,	sina,	0	);	_14 = 0;

	mov	DWORD PTR [ecx+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 291  : 		j.set		(-sina,	cosa,	0	);	_24 = 0;

	mov	DWORD PTR [ecx+28], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 1065353216		; 3f800000H
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 292  : 		k.set		(0,		0,		1	);	_34 = 0;

	mov	DWORD PTR [ecx+44], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 293  : 		c.set		(0,		0,		0	);	_44 = 1;

	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 754  :             return (float)sin(_X);

	fxch	ST(1)
	fsin
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fxch	ST(1)
	fst	DWORD PTR [ecx]
	fxch	ST(1)
	fst	DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 291  : 		j.set		(-sina,	cosa,	0	);	_24 = 0;

	fchs
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	fstp	DWORD PTR [ecx+16]
	fstp	DWORD PTR [ecx+20]
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 295  : 	}

	ret	4
?rotateZ@?$_matrix@M@@QAEAAU1@M@Z ENDP			; _matrix<float>::rotateZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
;	COMDAT ?set@?$_vector2@M@@QAEAAU1@ABU1@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?set@?$_vector2@M@@QAEAAU1@ABU1@@Z PROC			; _vector2<float>::set, COMDAT
; _this$ = ecx

; 18   : 	IC SelfRef set(const Self &p)					{ x=p.x; y=p.y;					return *this;	}

	mov	eax, DWORD PTR _p$[esp-4]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	mov	eax, ecx
	fstp	DWORD PTR [ecx+4]
	ret	4
?set@?$_vector2@M@@QAEAAU1@ABU1@@Z ENDP			; _vector2<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEABULIT@FVF@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEABULIT@FVF@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QBEABULIT@FVF@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@QAE@PAULIT@FVF@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 303  :         _Vector_iterator _Tmp = *this;
; 304  :         _Tmp += _Off; // TRANSITION, LLVM-49342
; 305  :         return _Tmp;
; 306  :     }

	ret	8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEABQAUstatic_wallmark@CWallmarksEngine@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEABQAUstatic_wallmark@CWallmarksEngine@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEABQAUstatic_wallmark@CWallmarksEngine@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEABQAUwm_slot@WallmarksEngine@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEABQAUwm_slot@WallmarksEngine@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEABQAUwm_slot@WallmarksEngine@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ PROC ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@@QAEXXZ ENDP ; xr_vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@CAXXZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@CAXXZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXXZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXXZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QBEIXZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$dead$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	1024					; 00000400H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN18@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [edi+1024]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN21@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ PROC ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@@QAEXXZ ENDP ; xr_vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEXPAPAUwm_slot@WallmarksEngine@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEXPAPAUwm_slot@WallmarksEngine@@0@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEXPAPAUwm_slot@WallmarksEngine@@0@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@CAXXZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@CAXXZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXXZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXXZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QBEIXZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__UFirst$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$dead$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	mov	DWORD PTR __Size$1$[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	1024					; 00000400H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	2
$LL19@Reallocate:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN18@Reallocate

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL19@Reallocate
$LN18@Reallocate:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN33@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN33@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Size$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [ebx+1024]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z ; xalloc<WallmarksEngine::wm_slot *>::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXI@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ PROC ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@@QAEXXZ ENDP ; xr_vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@CAXXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@CAXXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1547 :     }

	ret	0
?capacity@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 1073741823				; 3fffffffH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1537 :     }

	ret	0
?size@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QBEIXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
__Newvec$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__UFirst$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$dead$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1286 :     _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1287 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1288 :         auto& _My_data    = _Mypair._Myval2;
; 1289 :         pointer& _Myfirst = _My_data._Myfirst;
; 1290 :         pointer& _Mylast  = _My_data._Mylast;
; 1291 : 
; 1292 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi]
	sar	eax, 2
	mov	DWORD PTR __Size$1$[ebp], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	push	1024					; 00000400H
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1294 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 1295 : 
; 1296 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1297 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], esi
	npad	2
$LL19@Reallocate:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN18@Reallocate

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$3[ebp], ecx
	jmp	SHORT $LL19@Reallocate
$LN18@Reallocate:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN33@Reallocate
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN33@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Size$1$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	eax, DWORD PTR [ebx+1024]
	mov	DWORD PTR [esi+8], eax

; 1301 :         _CATCH_END
; 1302 : 
; 1303 :         _Change_array(_Newvec, _Size, _Newcapacity);
; 1304 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z$0:

; 1298 :         _CATCH_ALL
; 1299 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ; xalloc<CWallmarksEngine::static_wallmark *>::deallocate

; 1300 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN39@Reallocate:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_and_free@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ PROC ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear_and_free, COMDAT
; _this$ = ecx

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	ret	0
?clear_and_free@?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAEXXZ ENDP ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEAAV?$xalloc@ULIT@FVF@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEAAV?$xalloc@ULIT@FVF@@@@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal, COMDAT
; _this$ = ecx

; 1805 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1806 :     }

	ret	0
?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEAAV?$xalloc@ULIT@FVF@@@@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEXPAULIT@FVF@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEXPAULIT@FVF@@0@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

	ret	8
?_Orphan_range@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEXPAULIT@FVF@@0@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::size, COMDAT
; _this$ = ecx

; 1535 :         auto& _My_data = _Mypair._Myval2;
; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1537 :     }

	ret	0
?size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=, COMDAT
; _this$ = ecx

; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 298  :         _Mybase::operator+=(_Off);
; 299  :         return *this;

	mov	eax, ecx

; 300  :     }

	ret	4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAEAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@II@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@II@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@0@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [esi+eax], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN20@Umove_if_n

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [esi+eax], ecx

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [ecx]
$LN20@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL8@Umove_if_n
	pop	esi
$LN7@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXXZ PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXXZ ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAIABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAIABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAIABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IPBX@Z PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IPBX@Z ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ PROC ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ENDP ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXQAPAUwm_slot@WallmarksEngine@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXQAPAUwm_slot@WallmarksEngine@@II@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXQAPAUwm_slot@WallmarksEngine@@II@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@0@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@0@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXXZ PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEXXZ ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z PROC ; xalloc<WallmarksEngine::wm_slot *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z ENDP ; xalloc<WallmarksEngine::wm_slot *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEPAPAUwm_slot@WallmarksEngine@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEPAPAUwm_slot@WallmarksEngine@@IPBX@Z PROC ; xalloc<WallmarksEngine::wm_slot *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEPAPAUwm_slot@WallmarksEngine@@IPBX@Z ENDP ; xalloc<WallmarksEngine::wm_slot *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ PROC ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAEAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXQAPAUstatic_wallmark@CWallmarksEngine@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXQAPAUstatic_wallmark@CWallmarksEngine@@II@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXQAPAUstatic_wallmark@CWallmarksEngine@@II@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@0@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEXXZ ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 1073741823				; 3fffffffH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAIABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z PROC ; xalloc<CWallmarksEngine::static_wallmark *>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEPAPAUstatic_wallmark@CWallmarksEngine@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEPAPAUstatic_wallmark@CWallmarksEngine@@IPBX@Z PROC ; xalloc<CWallmarksEngine::static_wallmark *>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEPAPAUstatic_wallmark@CWallmarksEngine@@IPBX@Z ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULIT@FVF@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULIT@FVF@@@@XZ PROC ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1339 :         return *this;

	mov	eax, ecx

; 1340 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAEAAV?$xalloc@ULIT@FVF@@@@XZ ENDP ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?clear@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::clear, COMDAT
; _this$ = ecx

; 1437 :         auto& _My_data    = _Mypair._Myval2;
; 1438 :         pointer& _Myfirst = _My_data._Myfirst;
; 1439 :         pointer& _Mylast  = _My_data._Mylast;
; 1440 : 
; 1441 :         _My_data._Orphan_all();
; 1442 :         _Destroy(_Myfirst, _Mylast);
; 1443 :         _Mylast = _Myfirst;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1444 :     }

	ret	0
?clear@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEXXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=, COMDAT
; _this$ = ecx

; 118  :         _Verify_offset(_Off);
; 119  :         _Ptr += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	shl	eax, 2
	add	DWORD PTR [ecx], eax

; 120  :         return *this;

	mov	eax, ecx

; 121  :     }

	ret	4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ PROC ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QBEABV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@XZ ENDP ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	sub	esi, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [esi+eax], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN18@Umove_if_n

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [esi+eax], ecx

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [ecx]
$LN18@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL6@Umove_if_n
	pop	esi
$LN5@Umove_if_n:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1657 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEIXZ PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEIXZ ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ PROC ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUwm_slot@WallmarksEngine@@@@XZ ENDP ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEXPAPAUwm_slot@WallmarksEngine@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEIXZ PROC ; xalloc<WallmarksEngine::wm_slot *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEIXZ ENDP ; xalloc<WallmarksEngine::wm_slot *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ PROC ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QBEABV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@XZ ENDP ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXPAPAUstatic_wallmark@CWallmarksEngine@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEIXZ PROC ; xalloc<CWallmarksEngine::static_wallmark *>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 1073741823				; 3fffffffH
	ret	0
?max_size@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEIXZ ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@0@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1666 :         // destroy [_First, _Last) using allocator
; 1667 :         _Destroy_range(_First, _Last, _Getal());
; 1668 :     }

	ret	8
?_Destroy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@0@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Verify_offset, COMDAT
; _this$dead$ = ecx

; 102  : #if _ITERATOR_DEBUG_LEVEL == 0
; 103  :         (void) _Off;
; 104  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 105  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 106  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 107  :         if (_Off < 0) {
; 108  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 109  :         }
; 110  : 
; 111  :         if (_Off > 0) {
; 112  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 113  :         }
; 114  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 115  :     }

	ret	4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ??0?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@ABV0@@Z PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::intrusive_ptr<CSkeletonWallmark,intrusive_base>, COMDAT
; _this$ = ecx

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _rhs$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [ecx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN11@intrusive_

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [ecx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN11@intrusive_:

; 31   : 	set				(rhs);
; 32   : }

	mov	eax, ecx
	ret	4
??0?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@ABV0@@Z ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::intrusive_ptr<CSkeletonWallmark,intrusive_base>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ??1?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@XZ
_TEXT	SEGMENT
??1?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@XZ PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::~intrusive_ptr<CSkeletonWallmark,intrusive_base>, COMDAT
; _this$ = ecx

; 44   : 	if (!m_object)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN5@intrusive_

; 45   : 		return;
; 46   : 	
; 47   : 	--m_object->base_type::m_ref_count;

	dec	DWORD PTR [eax]

; 48   : 	if (!m_object->base_type::m_ref_count)

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@intrusive_

; 49   : 		m_object->base_type::_release	(m_object);

	push	eax
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN5@intrusive_:

; 37   : 	STATIC_CHECK	(result,Class_MUST_Be_Derived_From_The_Base);
; 38   : 	dec				();
; 39   : }

	ret	0
??1?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAE@XZ ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::~intrusive_ptr<CSkeletonWallmark,intrusive_base>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ??C?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBEPAVCSkeletonWallmark@@XZ
_TEXT	SEGMENT
??C?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBEPAVCSkeletonWallmark@@XZ PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator->, COMDAT
; _this$ = ecx

; 76   : 	VERIFY			(m_object);
; 77   : 	return			(m_object);

	mov	eax, DWORD PTR [ecx]

; 78   : }

	ret	0
??C?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBEPAVCSkeletonWallmark@@XZ ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ??7?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBE_NXZ PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator!, COMDAT
; _this$ = ecx

; 83   : 	return			(!m_object);

	cmp	DWORD PTR [ecx], 0
	sete	al

; 84   : }

	ret	0
??7?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QBE_NXZ ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::operator!
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??$?8UShader@@U0@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z
_TEXT	SEGMENT
??$?8UShader@@U0@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z PROC ; operator==<Shader,Shader,resptrcode_shader>, COMDAT
; _a$ = ecx
; _b$ = edx

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al
	ret	0
??$?8UShader@@U0@Uresptrcode_shader@@@@YA_NABV?$resptr_core@UShader@@Uresptrcode_shader@@@@0@Z ENDP ; operator==<Shader,Shader,resptrcode_shader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@V10@V10@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@V10@V10@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,resptr_core<Shader,resptrcode_shader> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 5185 :     for (; _First != _Last; ++_First) {

	mov	eax, DWORD PTR __Last$[esp-4]

; 5225 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	push	esi

; 5221 :     return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});

	mov	esi, DWORD PTR __First$[esp]

; 5225 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

	push	edi
	mov	edi, ecx

; 5185 :     for (; _First != _Last; ++_First) {

	cmp	esi, eax
	je	SHORT $LN25@find
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	edx, DWORD PTR [edx]
$LL8@find:
	mov	ecx, DWORD PTR [esi]

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	cmp	DWORD PTR [ecx], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5186 :         if (*_First == _Val) {

	je	SHORT $LN25@find

; 5185 :     for (; _First != _Last; ++_First) {

	add	esi, 4
	cmp	esi, eax
	jne	SHORT $LL8@find
$LN25@find:

; 5226 :     _Adl_verify_range(_First, _Last);
; 5227 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5228 :     return _First;
; 5229 : }

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	edi
	pop	esi
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@V10@V10@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;
; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	eax, DWORD PTR [ecx]

; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@Uwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
??$xr_new@Uwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; xr_new<WallmarksEngine::wm_slot,resptr_core<Shader,resptrcode_shader> >, COMDAT
; _p1$ = ecx

; 73   : IC	T*		xr_new		(const P1& p1) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	28					; 0000001cH
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	esi, DWORD PTR [esi]
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 75   : 	return new (ptr) T(p1);

	mov	ebp, eax
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	DWORD PTR $T1[esp+20], esi
	test	esi, esi

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	je	SHORT $LN5@xr_new
	inc	DWORD PTR [esi]
	mov	esi, DWORD PTR $T1[esp+20]
$LN5@xr_new:

; 61   : 						resptr_core		()												{	p_ = 0;						}

	mov	DWORD PTR [ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp+8], 0
	mov	DWORD PTR [ebp+12], 0
	mov	DWORD PTR [ebp+16], 0
	mov	DWORD PTR [ebp+20], 0
	mov	DWORD PTR [ebp+24], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	test	esi, esi

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	je	SHORT $LN35@xr_new
	inc	DWORD PTR [esi]
$LN35@xr_new:
	mov	ecx, ebp
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	DWORD PTR [ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+12]
	sub	eax, DWORD PTR [ebp+4]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN38@xr_new

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebp+4]
	call	?_Reallocate_exactly@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEXI@Z ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Reallocate_exactly
$LN38@xr_new:

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ebp+24]
	sub	eax, DWORD PTR [ebp+16]
	sar	eax, 2

; 1358 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	eax, 256				; 00000100H
	jae	SHORT $LN45@xr_new

; 1359 :             if (_Newcapacity > max_size()) {
; 1360 :                 _Xlength();
; 1361 :             }
; 1362 : 
; 1363 :             _Reallocate_exactly(_Newcapacity);

	push	ecx
	lea	ecx, DWORD PTR [ebp+16]
	call	?_Reallocate_exactly@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXI@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Reallocate_exactly
$LN45@xr_new:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	lea	ecx, DWORD PTR $T1[esp+20]
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 76   : }

	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$xr_new@Uwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@@YAPAUwm_slot@WallmarksEngine@@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; xr_new<WallmarksEngine::wm_slot,resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@Uwm_slot@WallmarksEngine@@@@YAXAAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$xr_delete@Uwm_slot@WallmarksEngine@@@@YAXAAPAUwm_slot@WallmarksEngine@@@Z PROC ; xr_delete<WallmarksEngine::wm_slot>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	mov	ebx, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	test	eax, eax
	je	SHORT $LN16@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN16@xr_delete:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN28@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN28@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	ebx

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
	pop	ebx
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@Uwm_slot@WallmarksEngine@@@@YAXAAPAUwm_slot@WallmarksEngine@@@Z ENDP ; xr_delete<WallmarksEngine::wm_slot>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@Ustatic_wallmark@CWallmarksEngine@@@@YAXAAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
??$xr_delete@Ustatic_wallmark@CWallmarksEngine@@@@YAXAAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; xr_delete<CWallmarksEngine::static_wallmark>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	push	edi
	mov	edi, ecx

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN2@xr_delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN16@xr_delete
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
	mov	esi, DWORD PTR [edi]
$LN16@xr_delete:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [edi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	edi
	pop	esi
	ret	0
??$xr_delete@Ustatic_wallmark@CWallmarksEngine@@@@YAXAAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; xr_delete<CWallmarksEngine::static_wallmark>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_new@Ustatic_wallmark@CWallmarksEngine@@@@YAPAUstatic_wallmark@CWallmarksEngine@@XZ
_TEXT	SEGMENT
??$xr_new@Ustatic_wallmark@CWallmarksEngine@@@@YAPAUstatic_wallmark@CWallmarksEngine@@XZ PROC ; xr_new<CWallmarksEngine::static_wallmark>, COMDAT

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	32					; 00000020H
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z

; 69   : 	return new (ptr) T();

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+28], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 70   : }

	ret	0
??$xr_new@Ustatic_wallmark@CWallmarksEngine@@@@YAPAUstatic_wallmark@CWallmarksEngine@@XZ ENDP ; xr_new<CWallmarksEngine::static_wallmark>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@Z PROC ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@Z ENDP ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV1@@Z PROC ; std::_Unfancy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV1@@Z ENDP ; std::_Unfancy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN7@construct

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z
_TEXT	SEGMENT
__Newvec$ = -28						; size = 4
tv452 = -24						; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN46@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], edi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	eax, 2
	mov	DWORD PTR tv452[ebp], eax
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ebx, DWORD PTR [edi+ebx*4]
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [ebx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN27@Emplace_re

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [ebx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN27@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	edi
	cmp	eax, ecx
	jne	SHORT $LN4@Emplace_re

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

	push	ecx
	push	edx
	call	?_Umove_if_noexcept@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove_if_noexcept

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	eax
	push	edx
	call	?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	lea	eax, DWORD PTR [ebx+4]
	push	eax
	push	DWORD PTR [esi+4]
	push	DWORD PTR __Whereptr$[ebp]
	call	?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN41@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN41@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [esi], edi

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR tv452[ebp]
	add	ecx, edi
	mov	DWORD PTR [esi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QBEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN46@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@CAXXZ ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Xlength
$LN44@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV2@ABV2@@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_reallocate<intrusive_ptr<CSkeletonWallmark,intrusive_base> const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z
_TEXT	SEGMENT
??$move@AAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z PROC ; std::move<WallmarksEngine::wm_slot * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z ENDP ; std::move<WallmarksEngine::wm_slot * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@PAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z PROC ; std::forward<WallmarksEngine::wm_slot *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAUwm_slot@WallmarksEngine@@AAPAU12@@Z ENDP ; std::forward<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUwm_slot@WallmarksEngine@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUwm_slot@WallmarksEngine@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z PROC ; std::_Unfancy<WallmarksEngine::wm_slot *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUwm_slot@WallmarksEngine@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z ENDP ; std::_Unfancy<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUwm_slot@WallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@$$QAPAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUwm_slot@WallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@$$QAPAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::construct<WallmarksEngine::wm_slot *,WallmarksEngine::wm_slot *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUwm_slot@WallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@$$QAPAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::construct<WallmarksEngine::wm_slot *,WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QBEXPAPAUwm_slot@WallmarksEngine@@I@Z ; xalloc<WallmarksEngine::wm_slot *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@CAXXZ ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAUwm_slot@WallmarksEngine@@@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@QAPAU23@$$QAPAU23@@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Emplace_reallocate<WallmarksEngine::wm_slot *>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAUstatic_wallmark@CWallmarksEngine@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAUstatic_wallmark@CWallmarksEngine@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU12@@Z PROC ; std::_Unfancy<CWallmarksEngine::static_wallmark *>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@PAUstatic_wallmark@CWallmarksEngine@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU12@@Z ENDP ; std::_Unfancy<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUstatic_wallmark@CWallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
??$destroy@PAUstatic_wallmark@CWallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::destroy<CWallmarksEngine::static_wallmark *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUstatic_wallmark@CWallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::destroy<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAUstatic_wallmark@CWallmarksEngine@@@std@@YAABQAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@Z
_TEXT	SEGMENT
??$forward@ABQAUstatic_wallmark@CWallmarksEngine@@@std@@YAABQAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@Z PROC ; std::forward<CWallmarksEngine::static_wallmark * const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABQAUstatic_wallmark@CWallmarksEngine@@@std@@YAABQAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@Z ENDP ; std::forward<CWallmarksEngine::static_wallmark * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@ABQAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@ABQAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUstatic_wallmark@CWallmarksEngine@@ABQAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@ABQAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Backout$2 = -76					; size = 12
__Backout$3 = -64					; size = 12
__Backout$4 = -52					; size = 12
__UFirst$5 = -40					; size = 4
__UFirst$6 = -36					; size = 4
__UFirst$7 = -32					; size = 4
__Newvec$ = -28						; size = 4
__Newcapacity$1$ = -24					; size = 4
__Newsize$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv555 = 8						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR __Whereptr$[ebp]
	mov	ebx, esi
	sub	ebx, edx
	sar	ebx, 2

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN83@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	inc	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	jmp	SHORT $LN81@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$1$[ebp]
	cmovb	eax, DWORD PTR __Newsize$1$[ebp]
$LN81@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	DWORD PTR __Newcapacity$1$[ebp], eax
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	edx, eax
	mov	DWORD PTR __Newvec$[ebp], edx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR tv555[ebp], ecx
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 777  :         _Constructed_first = _Newvec + _Whereoff;
; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	cmp	esi, ebx
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$7[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$4[ebp], edx
	mov	DWORD PTR __Backout$4[ebp+4], edx
	mov	DWORD PTR __Backout$4[ebp+8], edi
	npad	1
$LL28@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, ebx
	je	SHORT $LN27@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$4[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$7[ebp], ecx
	jmp	SHORT $LL28@Emplace_re
$LN27@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$4[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	mov	ebx, DWORD PTR tv555[ebp]
	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$6[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$3[ebp], edx
	mov	DWORD PTR __Backout$3[ebp+4], edx
	mov	DWORD PTR __Backout$3[ebp+8], edi
	npad	6
$LL41@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN40@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	edx, 4
	mov	DWORD PTR __Backout$3[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 4
	mov	DWORD PTR __UFirst$6[ebp], ecx
	jmp	SHORT $LL41@Emplace_re
$LN40@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$3[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ebx, DWORD PTR tv555[ebp]
	lea	ecx, DWORD PTR [ebx+4]

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$5[ebp], esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ecx
	mov	DWORD PTR __Backout$2[ebp+4], ecx
	mov	DWORD PTR __Backout$2[ebp+8], edi
	npad	2
$LL54@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	esi, edx
	je	SHORT $LN53@Emplace_re

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR __Backout$2[ebp+4], ecx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	esi, 4
	mov	DWORD PTR __UFirst$5[ebp], esi
	jmp	SHORT $LL54@Emplace_re
$LN53@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], ecx
$LN5@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN68@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [edi], eax

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR __Newcapacity$1$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, ebx

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QBEXPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ; xalloc<CWallmarksEngine::static_wallmark *>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN83@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@CAXXZ ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Xlength
$LN80@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUstatic_wallmark@CWallmarksEngine@@@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_reallocate<CWallmarksEngine::static_wallmark * const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<FVF::LIT> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<FVF::LIT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABULIT@FVF@@@std@@YAABULIT@FVF@@ABU12@@Z
_TEXT	SEGMENT
??$forward@ABULIT@FVF@@@std@@YAABULIT@FVF@@ABU12@@Z PROC ; std::forward<FVF::LIT const &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ABULIT@FVF@@@std@@YAABULIT@FVF@@ABU12@@Z ENDP ; std::forward<FVF::LIT const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@ULIT@FVF@@@std@@YAPAULIT@FVF@@PAU12@@Z
_TEXT	SEGMENT
??$_Unfancy@ULIT@FVF@@@std@@YAPAULIT@FVF@@PAU12@@Z PROC	; std::_Unfancy<FVF::LIT>, COMDAT
; __Ptr$ = ecx

; 266  :     return _Ptr;

	mov	eax, ecx

; 267  : }

	ret	0
??$_Unfancy@ULIT@FVF@@@std@@YAPAULIT@FVF@@PAU12@@Z ENDP	; std::_Unfancy<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@ULIT@FVF@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@ABU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@ULIT@FVF@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@ABU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@ULIT@FVF@@ABU12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@ABU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Backout$2 = -44					; size = 12
__Newvec$ = -32						; size = 4
__Oldsize$1$ = -28					; size = 4
__UFirst$3 = -24					; size = 4
tv435 = -20						; size = 4
__Whereoff$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
__ULast$1$ = 12						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>, COMDAT
; _this$ = ecx

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Whereoff$1$[ebp], eax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx
	sar	eax, 3
	imul	eax, eax, -1431655765
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

	cmp	eax, 178956970				; 0aaaaaaaH
	je	$LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 3
	imul	edx, eax, -1431655765

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	mov	eax, 178956970				; 0aaaaaaaH
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN12@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow

	mov	esi, 178956970				; 0aaaaaaaH
	jmp	SHORT $LN13@Emplace_re
$LN12@Emplace_re:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	esi, DWORD PTR [ecx+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	esi, ebx
	cmovb	esi, ebx
$LN13@Emplace_re:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 773  :         pointer _Constructed_first      = _Constructed_last;
; 774  : 
; 775  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR tv435[ebp], edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR __ULast$1$[ebp], eax
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR __Whereptr$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	DWORD PTR __UFirst$3[ebp], ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR __Backout$2[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR __Backout$2[ebp+4], edx
	mov	DWORD PTR __Backout$2[ebp+8], edi
$LL32@Emplace_re:

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, eax
	je	SHORT $LN31@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	edx, 24					; 00000018H
	mov	DWORD PTR __Backout$2[ebp+4], edx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	ecx, 24					; 00000018H
	mov	DWORD PTR __UFirst$3[ebp], ecx
	mov	eax, DWORD PTR __ULast$1$[ebp]
	jmp	SHORT $LL32@Emplace_re
$LN31@Emplace_re:

; 1625 :         _First = _Last;

	mov	DWORD PTR __Backout$2[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);

	push	ebx
	push	edx
	push	ecx
	call	?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove

; 783  :             _Constructed_first = _Newvec;
; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

	mov	ecx, DWORD PTR tv435[ebp]
	lea	eax, DWORD PTR [ecx+24]
	push	eax
	push	DWORD PTR [edi+4]
	push	DWORD PTR __Whereptr$[ebp]
	call	?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove
$LN5@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN50@Emplace_re
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	eax
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN50@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	DWORD PTR [edi], ebx

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Oldsize$1$[ebp]
	inc	eax
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR [edi+4], ecx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR [edi+8], ecx

; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR tv435[ebp]

; 794  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	ecx
	push	DWORD PTR __Newvec$[ebp]
	call	?deallocate@?$xalloc@ULIT@FVF@@@@QBEXPAULIT@FVF@@I@Z ; xalloc<FVF::LIT>::deallocate

; 789  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Emplace_re:

; 765  :             _Xlength();

	call	?_Xlength@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@CAXXZ ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Xlength
$LN56@Emplace_re:
	int	3
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABULIT@FVF@@@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@QAU23@ABU23@@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Emplace_reallocate<FVF::LIT const &>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@V?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1>::_Compressed_pair<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >,std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1>::_Compressed_pair<xalloc<WallmarksEngine::wm_slot *>,std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@V?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1>::_Compressed_pair<xalloc<CWallmarksEngine::static_wallmark *>,std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z PROC ; std::_Destroy_range<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ENDP ; std::_Destroy_range<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
??$xr_free@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; xr_free<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; xr_free<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z
_TEXT	SEGMENT
??$xr_alloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z PROC ; xr_alloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@I@Z ENDP ; xr_alloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAXPAPAUwm_slot@WallmarksEngine@@QAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAXPAPAUwm_slot@WallmarksEngine@@QAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z PROC ; std::_Destroy_range<xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAXPAPAUwm_slot@WallmarksEngine@@QAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ENDP ; std::_Destroy_range<xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUwm_slot@WallmarksEngine@@@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$xr_free@PAUwm_slot@WallmarksEngine@@@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z PROC ; xr_free<WallmarksEngine::wm_slot *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUwm_slot@WallmarksEngine@@@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z ENDP ; xr_free<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUwm_slot@WallmarksEngine@@@@YAPAPAUwm_slot@WallmarksEngine@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUwm_slot@WallmarksEngine@@@@YAPAPAUwm_slot@WallmarksEngine@@I@Z PROC ; xr_alloc<WallmarksEngine::wm_slot *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUwm_slot@WallmarksEngine@@@@YAPAPAUwm_slot@WallmarksEngine@@I@Z ENDP ; xr_alloc<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAXPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAXPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z PROC ; std::_Destroy_range<xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAXPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ENDP ; std::_Destroy_range<xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@PAUstatic_wallmark@CWallmarksEngine@@@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
??$xr_free@PAUstatic_wallmark@CWallmarksEngine@@@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; xr_free<CWallmarksEngine::static_wallmark *>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@PAUstatic_wallmark@CWallmarksEngine@@@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; xr_free<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@PAUstatic_wallmark@CWallmarksEngine@@@@YAPAPAUstatic_wallmark@CWallmarksEngine@@I@Z
_TEXT	SEGMENT
??$xr_alloc@PAUstatic_wallmark@CWallmarksEngine@@@@YAPAPAUstatic_wallmark@CWallmarksEngine@@I@Z PROC ; xr_alloc<CWallmarksEngine::static_wallmark *>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@PAUstatic_wallmark@CWallmarksEngine@@@@YAPAPAUstatic_wallmark@CWallmarksEngine@@I@Z ENDP ; xr_alloc<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z PROC ; std::_Uninitialized_copy<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [eax], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN16@Uninitiali

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [eax], edx

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [edx]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();
; 1663 : }

	ret	0
??$_Uninitialized_copy@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ENDP ; std::_Uninitialized_copy<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA?A_TABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA?A_TABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::_Get_unwrapped<intrusive_ptr<CSkeletonWallmark,intrusive_base> * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA?A_TABQAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::_Get_unwrapped<intrusive_ptr<CSkeletonWallmark,intrusive_base> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z PROC ; std::_Uninitialized_move<WallmarksEngine::wm_slot * *,xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ENDP ; std::_Uninitialized_move<WallmarksEngine::wm_slot * *,xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUwm_slot@WallmarksEngine@@@std@@YA?A_TABQAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUwm_slot@WallmarksEngine@@@std@@YA?A_TABQAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Get_unwrapped<WallmarksEngine::wm_slot * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUwm_slot@WallmarksEngine@@@std@@YA?A_TABQAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Get_unwrapped<WallmarksEngine::wm_slot * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z PROC ; std::_Uninitialized_move<CWallmarksEngine::static_wallmark * *,xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAPAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@YAPAPAUstatic_wallmark@CWallmarksEngine@@QAPAU12@0PAPAU12@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ENDP ; std::_Uninitialized_move<CWallmarksEngine::static_wallmark * *,xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA?A_TABQAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA?A_TABQAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::_Get_unwrapped<CWallmarksEngine::static_wallmark * * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA?A_TABQAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::_Get_unwrapped<CWallmarksEngine::static_wallmark * * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$xalloc@ULIT@FVF@@@@@std@@YAXPAULIT@FVF@@QAU12@AAV?$xalloc@ULIT@FVF@@@@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$xalloc@ULIT@FVF@@@@@std@@YAXPAULIT@FVF@@QAU12@AAV?$xalloc@ULIT@FVF@@@@@Z PROC ; std::_Destroy_range<xalloc<FVF::LIT> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 901  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 902  :     using _Ty = typename _Alloc::value_type;
; 903  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 904  :         for (; _First != _Last; ++_First) {
; 905  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 906  :         }
; 907  :     }
; 908  : }

	ret	0
??$_Destroy_range@V?$xalloc@ULIT@FVF@@@@@std@@YAXPAULIT@FVF@@QAU12@AAV?$xalloc@ULIT@FVF@@@@@Z ENDP ; std::_Destroy_range<xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0static_wallmark@CWallmarksEngine@@QAE@XZ
_TEXT	SEGMENT
??0static_wallmark@CWallmarksEngine@@QAE@XZ PROC	; CWallmarksEngine::static_wallmark::static_wallmark, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+16], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0static_wallmark@CWallmarksEngine@@QAE@XZ ENDP	; CWallmarksEngine::static_wallmark::static_wallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ PROC ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::~xr_vector<FVF::LIT,xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@xr_vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN6@xr_vector:
	pop	esi
	ret	0
??1?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ ENDP ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::~xr_vector<FVF::LIT,xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEPAPAUstatic_wallmark@CWallmarksEngine@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::~_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::~_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAE@PAPAUstatic_wallmark@CWallmarksEngine@@AAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEPAPAUwm_slot@WallmarksEngine@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::~_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::~_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAE@PAPAUwm_slot@WallmarksEngine@@AAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::~_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAE@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@Ustatic_wallmark@CWallmarksEngine@@@@QAEXAAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@Ustatic_wallmark@CWallmarksEngine@@@@QAEXAAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; xr_special_free<0,CWallmarksEngine::static_wallmark>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx
	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN13@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
	mov	esi, DWORD PTR [ebx]
$LN13@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	esi
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@Ustatic_wallmark@CWallmarksEngine@@@@QAEXAAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; xr_special_free<0,CWallmarksEngine::static_wallmark>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@Uwm_slot@WallmarksEngine@@@@QAEXAAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@Uwm_slot@WallmarksEngine@@@@QAEXAAPAUwm_slot@WallmarksEngine@@@Z PROC ; xr_special_free<0,WallmarksEngine::wm_slot>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	ebx

; 143  : 		ptr->~T			();

	mov	ebx, DWORD PTR _ptr$[esp]
	push	esi
	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	edi, DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN13@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN13@operator:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN25@operator
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN25@operator:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	edi
	pop	edi
	pop	esi
	pop	ebx

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@Uwm_slot@WallmarksEngine@@@@QAEXAAPAUwm_slot@WallmarksEngine@@@Z ENDP ; xr_special_free<0,WallmarksEngine::wm_slot>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEPAPAUwm_slot@WallmarksEngine@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEPAPAUwm_slot@WallmarksEngine@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 328  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR [ecx]

; 329  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QBEPAPAUwm_slot@WallmarksEngine@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Vector_val<std::_Simple_types<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEII@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@ABEII@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z PROC ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [eax], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN18@Umove

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [eax], edx

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [edx]
$LN18@Umove:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@AAEPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@PAV3@00@Z ENDP ; std::vector<intrusive_ptr<CSkeletonWallmark,intrusive_base>,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV2@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV2@@Z PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::construct, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	ecx, DWORD PTR _p$[esp-4]

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR __Val$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [ecx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN5@construct

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [ecx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN5@construct:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	ret	8
?construct@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@ABV2@@Z ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAE@XZ PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAE@XZ ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEII@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@ABEII@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEPAPAUwm_slot@WallmarksEngine@@PAPAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEPAPAUwm_slot@WallmarksEngine@@PAPAU34@00@Z PROC ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAUwm_slot@WallmarksEngine@@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@AAEPAPAUwm_slot@WallmarksEngine@@PAPAU34@00@Z ENDP ; std::vector<WallmarksEngine::wm_slot *,xalloc<WallmarksEngine::wm_slot *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@ABQAU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@ABQAU23@@Z PROC ; xalloc<WallmarksEngine::wm_slot *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@ABQAU23@@Z ENDP ; xalloc<WallmarksEngine::wm_slot *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAE@XZ PROC	; xalloc<WallmarksEngine::wm_slot *>::xalloc<WallmarksEngine::wm_slot *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAE@XZ ENDP	; xalloc<WallmarksEngine::wm_slot *>::xalloc<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUstatic_wallmark@CWallmarksEngine@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >::_Vector_val<std::_Simple_types<CWallmarksEngine::static_wallmark *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEII@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 1073741823				; 3fffffffH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	edx, 2

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	esi, edx
	shr	esi, 1
	sub	ecx, esi
	cmp	edx, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 1073741823				; 3fffffffH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [esi+edx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@ABEII@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU34@00@Z PROC ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN5@Umove
$LL6@Umove:

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx]

; 1621 :         ++_Last;

	add	ecx, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL6@Umove
$LN5@Umove:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@PAUstatic_wallmark@CWallmarksEngine@@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@AAEPAPAUstatic_wallmark@CWallmarksEngine@@PAPAU34@00@Z ENDP ; std::vector<CWallmarksEngine::static_wallmark *,xalloc<CWallmarksEngine::static_wallmark *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; xalloc<CWallmarksEngine::static_wallmark *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@ABQAU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@ABQAU23@@Z PROC ; xalloc<CWallmarksEngine::static_wallmark *>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$[esp-4]
	mov	DWORD PTR [eax], ecx
	ret	8
?construct@?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAEXPAPAUstatic_wallmark@CWallmarksEngine@@ABQAU23@@Z ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAE@XZ PROC ; xalloc<CWallmarksEngine::static_wallmark *>::xalloc<CWallmarksEngine::static_wallmark *>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@QAE@XZ ENDP ; xalloc<CWallmarksEngine::static_wallmark *>::xalloc<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ PROC ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::xr_vector<FVF::LIT,xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	ret	0
??0?$xr_vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@@QAE@XZ ENDP ; xr_vector<FVF::LIT,xalloc<FVF::LIT> >::xr_vector<FVF::LIT,xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@CAXXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Xlength, COMDAT

; 1761 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN3@Xlength:
	int	3
?_Xlength@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@CAXXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXQAULIT@FVF@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXQAULIT@FVF@@II@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Change_array, COMDAT
; _this$ = ecx

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	esi
	mov	esi, ecx

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@Change_arr
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1738 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+4], eax

; 1739 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1740 :     }

	ret	12					; 0000000cH
?_Change_array@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXQAULIT@FVF@@II@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEII@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	ecx, 178956970				; 0aaaaaaaH

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	eax, 3

; 1670 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

	push	esi

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	esi, eax, -1431655765

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	edx, esi
	shr	edx, 1
	sub	ecx, edx
	cmp	esi, ecx
	jbe	SHORT $LN2@Calculate_

; 1676 :             return _Max; // geometric growth would overflow

	mov	eax, 178956970				; 0aaaaaaaH
	pop	esi

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
$LN2@Calculate_:

; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+esi]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp]
	pop	esi
	cmovb	eax, DWORD PTR __Newsize$[esp-4]

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

	ret	4
?_Calculate_growth@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEII@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN7@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL8@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL8@Umove_if_n
$LN7@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1663 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	ecx, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

	push	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	ecx, edi
	je	SHORT $LN22@Umove
$LL6@Umove:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], edx
	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 24					; 00000018H

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL6@Umove
$LN22@Umove:
	pop	edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
?_Umove@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEPAULIT@FVF@@PAU34@00@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::max_size, COMDAT
; _this$dead$ = ecx

; 1540 :         return (_STD min)(

	mov	eax, 178956970				; 0aaaaaaaH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

	ret	0
?max_size@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::~vector<FVF::LIT,xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx

; 698  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

	push	esi
	mov	esi, ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 699  :         _Tidy();
; 700  : #if _ITERATOR_DEBUG_LEVEL != 0
; 701  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 702  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 703  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 704  :     }

	ret	0
??1?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::~vector<FVF::LIT,xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@ABU23@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
__Val$ = 12						; size = 4
?construct@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@ABU23@@Z PROC ; xalloc<FVF::LIT>::construct, COMDAT
; _this$dead$ = ecx

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR _p$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	ret	8
?construct@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@ABU23@@Z ENDP ; xalloc<FVF::LIT>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@ULIT@FVF@@@@QBEXPAULIT@FVF@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$dead$ = 12						; size = 4
?deallocate@?$xalloc@ULIT@FVF@@@@QBEXPAULIT@FVF@@I@Z PROC ; xalloc<FVF::LIT>::deallocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN4@deallocate
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN4@deallocate:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	8
?deallocate@?$xalloc@ULIT@FVF@@@@QBEXPAULIT@FVF@@I@Z ENDP ; xalloc<FVF::LIT>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@ULIT@FVF@@@@QBEPAULIT@FVF@@IPBX@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
_p$dead$ = 12						; size = 4
?allocate@?$xalloc@ULIT@FVF@@@@QBEPAULIT@FVF@@IPBX@Z PROC ; xalloc<FVF::LIT>::allocate, COMDAT
; _this$dead$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, DWORD PTR _n$[esp-4]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	ret	8
?allocate@?$xalloc@ULIT@FVF@@@@QBEPAULIT@FVF@@IPBX@Z ENDP ; xalloc<FVF::LIT>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??_Gstatic_wallmark@CWallmarksEngine@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_Gstatic_wallmark@CWallmarksEngine@@QAEPAXI@Z PROC	; CWallmarksEngine::static_wallmark::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN18@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN18@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gstatic_wallmark@CWallmarksEngine@@QAEPAXI@Z ENDP	; CWallmarksEngine::static_wallmark::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??_Gwm_slot@WallmarksEngine@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_Gwm_slot@WallmarksEngine@@QAEPAXI@Z PROC		; WallmarksEngine::wm_slot::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN11@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN11@scalar:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN23@scalar
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN23@scalar:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??_Gwm_slot@WallmarksEngine@@QAEPAXI@Z ENDP		; WallmarksEngine::wm_slot::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1static_wallmark@CWallmarksEngine@@QAE@XZ
_TEXT	SEGMENT
??1static_wallmark@CWallmarksEngine@@QAE@XZ PROC	; CWallmarksEngine::static_wallmark::~static_wallmark, COMDAT
; _this$ = ecx

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@static_wal
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN8@static_wal:
	pop	esi
	ret	0
??1static_wallmark@CWallmarksEngine@@QAE@XZ ENDP	; CWallmarksEngine::static_wallmark::~static_wallmark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??1wm_slot@WallmarksEngine@@QAE@XZ
_TEXT	SEGMENT
??1wm_slot@WallmarksEngine@@QAE@XZ PROC			; WallmarksEngine::wm_slot::~wm_slot, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN8@wm_slot
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+16], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+20], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+24], 0
$LN8@wm_slot:

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN20@wm_slot
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+8], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+12], 0
$LN20@wm_slot:
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 64   : 						~resptr_core	()												{	_dec();						}

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_?_dec@?$resptr_base@UShader@@@@IAEXXZ
??1wm_slot@WallmarksEngine@@QAE@XZ ENDP			; WallmarksEngine::wm_slot::~wm_slot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEABV?$xalloc@ULIT@FVF@@@@XZ
_TEXT	SEGMENT
?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEABV?$xalloc@ULIT@FVF@@@@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal, COMDAT
; _this$ = ecx

; 1809 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1810 :     }

	ret	0
?_Getal@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@ABEABV?$xalloc@ULIT@FVF@@@@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Tidy, COMDAT
; _this$ = ecx

; 1742 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1743 :         auto& _My_data    = _Mypair._Myval2;
; 1744 :         pointer& _Myfirst = _My_data._Myfirst;
; 1745 :         pointer& _Mylast  = _My_data._Mylast;
; 1746 :         pointer& _Myend   = _My_data._Myend;
; 1747 : 
; 1748 :         _My_data._Orphan_all();
; 1749 : 
; 1750 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Tidy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

	mov	DWORD PTR [esi], 0

; 1755 :             _Mylast  = nullptr;

	mov	DWORD PTR [esi+4], 0

; 1756 :             _Myend   = nullptr;

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1757 :         }
; 1758 :     }

	pop	esi
	ret	0
?_Tidy@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1703 :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

	push	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	mov	esi, DWORD PTR __Last$[esp]
	cmp	eax, esi
	je	SHORT $LN5@Umove_if_n

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edx, DWORD PTR __Dest$[esp]
	sub	edx, eax
$LL6@Umove_if_n:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+eax+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+eax+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	eax, 24					; 00000018H
	cmp	eax, esi
	jne	SHORT $LL6@Umove_if_n
$LN5@Umove_if_n:
	pop	esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1652 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@AAEXPAULIT@FVF@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::capacity, COMDAT
; _this$ = ecx

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3
	imul	eax, eax, -1431655765

; 1547 :     }

	ret	0
?capacity@?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QBEIXZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ PROC ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::vector<FVF::LIT,xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	mov	eax, ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

	ret	0
??0?$vector@ULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ENDP ; std::vector<FVF::LIT,xalloc<FVF::LIT> >::vector<FVF::LIT,xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAIABV?$xalloc@ULIT@FVF@@@@@Z
_TEXT	SEGMENT
?max_size@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAIABV?$xalloc@ULIT@FVF@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::max_size, COMDAT
; __Al$dead$ = ecx

; 591  :         if constexpr (_Has_max_size<_Alloc>::value) {
; 592  :             return _Al.max_size();

	mov	eax, 178956970				; 0aaaaaaaH

; 593  :         } else {
; 594  :             return (numeric_limits<size_type>::max)() / sizeof(value_type);
; 595  :         }
; 596  :     }

	ret	0
?max_size@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAIABV?$xalloc@ULIT@FVF@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULIT@FVF@@@@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULIT@FVF@@@@XZ PROC ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :         return *this;

	mov	eax, ecx

; 1344 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QBEABV?$xalloc@ULIT@FVF@@@@XZ ENDP ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@ULIT@FVF@@@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$xalloc@ULIT@FVF@@@@QBEIXZ PROC		; xalloc<FVF::LIT>::max_size, COMDAT
; _this$dead$ = ecx

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	eax, 178956970				; 0aaaaaaaH
	ret	0
?max_size@?$xalloc@ULIT@FVF@@@@QBEIXZ ENDP		; xalloc<FVF::LIT>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ?dec@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IAEXXZ
_TEXT	SEGMENT
?dec@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IAEXXZ PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::dec, COMDAT
; _this$ = ecx

; 44   : 	if (!m_object)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@dec

; 45   : 		return;
; 46   : 	
; 47   : 	--m_object->base_type::m_ref_count;

	dec	DWORD PTR [eax]

; 48   : 	if (!m_object->base_type::m_ref_count)

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@dec

; 49   : 		m_object->base_type::_release	(m_object);

	push	eax
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN3@dec:

; 50   : }

	ret	0
?dec@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@IAEXXZ ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::dec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
;	COMDAT ?set@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAEXABV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?set@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAEXABV1@@Z PROC ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::set, COMDAT
; _this$ = ecx

; 114  : {

	push	esi
	push	edi

; 115  : 	if (m_object == rhs.m_object)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN1@set

; 44   : 	if (!m_object)

	test	eax, eax
	je	SHORT $LN7@set

; 45   : 		return;
; 46   : 	
; 47   : 	--m_object->base_type::m_ref_count;

	dec	DWORD PTR [eax]

; 48   : 	if (!m_object->base_type::m_ref_count)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@set

; 49   : 		m_object->base_type::_release	(m_object);

	push	eax
	call	??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ; intrusive_base::_release<CSkeletonWallmark>
$LN7@set:

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 119  : 	if (!m_object)

	test	eax, eax
	je	SHORT $LN1@set

; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN1@set:
	pop	edi

; 122  : }

	pop	esi
	ret	4
?set@?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAEXABV1@@Z ENDP ; intrusive_ptr<CSkeletonWallmark,intrusive_base>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1259 :     // check that [_First, _Last) forms an iterator range
; 1260 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1261 :         _Verify_range(_First, _Last);
; 1262 :     }
; 1263 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Find_unchecked@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Find_unchecked@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z PROC ; std::_Find_unchecked<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5185 :     for (; _First != _Last; ++_First) {

	cmp	ecx, edx
	je	SHORT $LN23@Find_unche
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax]
	npad	5
$LL6@Find_unche:
	mov	eax, DWORD PTR [ecx]

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	cmp	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5186 :         if (*_First == _Val) {

	je	SHORT $LN22@Find_unche

; 5185 :     for (; _First != _Last; ++_First) {

	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Find_unche
$LN22@Find_unche:

; 5219 :     // find first matching _Val; choose optimization
; 5220 :     // activate optimization for contiguous iterators to (const) bytes and integral values
; 5221 :     return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});

	mov	eax, ecx
	pop	esi

; 5222 : }

	ret	0
$LN23@Find_unche:

; 5219 :     // find first matching _Val; choose optimization
; 5220 :     // activate optimization for contiguous iterators to (const) bytes and integral values
; 5221 :     return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});

	mov	eax, ecx

; 5222 : }

	ret	0
??$_Find_unchecked@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@QAPAU12@0ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@@Z ENDP ; std::_Find_unchecked<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@$$QAPAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@$$QAPAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,WallmarksEngine::wm_slot * *>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 1375 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1376 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1377 :     } else {
; 1378 :         _It = _STD forward<_UIter>(_UIt);
; 1379 :     }
; 1380 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@0@$$QAPAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >,WallmarksEngine::wm_slot * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
??$destroy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::destroy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::destroy<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAUwm_slot@WallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$destroy@PAUwm_slot@WallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::destroy<WallmarksEngine::wm_slot *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@PAUwm_slot@WallmarksEngine@@@?$_Normal_allocator_traits@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUwm_slot@WallmarksEngine@@@@PAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<WallmarksEngine::wm_slot *> >::destroy<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@Emplace_ba

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN17@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEXAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUwm_slot@WallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUwm_slot@WallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back<WallmarksEngine::wm_slot *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUwm_slot@WallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUwm_slot@WallmarksEngine@@@@@std@@QAEX$$QAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<WallmarksEngine::wm_slot *> >::_Emplace_back<WallmarksEngine::wm_slot *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z
_TEXT	SEGMENT
??$move@AAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z PROC ; std::move<CWallmarksEngine::static_wallmark * &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAPAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z ENDP ; std::move<CWallmarksEngine::static_wallmark * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAUstatic_wallmark@CWallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEX$$QAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAUstatic_wallmark@CWallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEX$$QAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back<CWallmarksEngine::static_wallmark *>, COMDAT
; _this$ = ecx

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 1622 :     }

	ret	4
??$_Emplace_back@PAUstatic_wallmark@CWallmarksEngine@@@?$_Uninitialized_backout_al@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@QAEX$$QAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<CWallmarksEngine::static_wallmark *> >::_Emplace_back<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@ULIT@FVF@@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@@Z
_TEXT	SEGMENT
??$destroy@ULIT@FVF@@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@@Z PROC ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::destroy<FVF::LIT>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 579  :         if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
; 580  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 581  :             _STD destroy_at(_Ptr);
; 582  : #else // __cpp_lib_constexpr_dynamic_alloc
; 583  :             _Ptr->~_Ty();
; 584  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 585  :         } else {
; 586  :             _Al.destroy(_Ptr);
; 587  :         }
; 588  :     }

	ret	0
??$destroy@ULIT@FVF@@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::destroy<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z PROC ; std::_Uninitialized_move<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi
	mov	esi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 30   : 	m_object		= 0;

	mov	DWORD PTR [eax], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN16@Uninitiali

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [eax], edx

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [edx]
$LN16@Uninitiali:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 4
	add	eax, 4

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	ret	0
??$_Uninitialized_move@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@YAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@QAV1@0PAV1@AAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@Z ENDP ; std::_Uninitialized_move<intrusive_ptr<CSkeletonWallmark,intrusive_base> *,xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUstatic_wallmark@CWallmarksEngine@@@std@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUstatic_wallmark@CWallmarksEngine@@@std@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z PROC ; std::_Destroy_in_place<CWallmarksEngine::static_wallmark * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUstatic_wallmark@CWallmarksEngine@@@std@@YAXAAPAPAUstatic_wallmark@CWallmarksEngine@@@Z ENDP ; std::_Destroy_in_place<CWallmarksEngine::static_wallmark * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@YAPAULIT@FVF@@QAU12@0PAU12@AAV?$xalloc@ULIT@FVF@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@YAPAULIT@FVF@@QAU12@0PAU12@AAV?$xalloc@ULIT@FVF@@@@@Z PROC ; std::_Uninitialized_move<FVF::LIT *,xalloc<FVF::LIT> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	esi

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	esi, DWORD PTR __Dest$[esp]

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	edi
	mov	edi, edx

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	je	SHORT $LN20@Uninitiali
	npad	4
$LL4@Uninitiali:
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], edx
	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	ecx, 24					; 00000018H
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	DWORD PTR [esi+20], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	esi, 24					; 00000018H

; 1700 :     // move [_First, _Last) to raw _Dest, using _Al
; 1701 :     // note: only called internally from elsewhere in the STL
; 1702 :     using _Ptrval     = typename _Alloc::value_type*;
; 1703 :     auto _UFirst      = _Get_unwrapped(_First);
; 1704 :     const auto _ULast = _Get_unwrapped(_Last);
; 1705 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1706 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1707 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1708 :         if (!_STD is_constant_evaluated())
; 1709 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1710 :         {
; 1711 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1712 :             return _Dest + (_ULast - _UFirst);
; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	ecx, edi
	jne	SHORT $LL4@Uninitiali
$LN20@Uninitiali:
	pop	edi

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??$_Uninitialized_move@PAULIT@FVF@@V?$xalloc@ULIT@FVF@@@@@std@@YAPAULIT@FVF@@QAU12@0PAU12@AAV?$xalloc@ULIT@FVF@@@@@Z ENDP ; std::_Uninitialized_move<FVF::LIT *,xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAULIT@FVF@@@std@@YA?A_TABQAULIT@FVF@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAULIT@FVF@@@std@@YA?A_TABQAULIT@FVF@@@Z PROC ; std::_Get_unwrapped<FVF::LIT * const &>, COMDAT
; __It$ = ecx

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

	mov	eax, DWORD PTR [ecx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

	ret	0
??$_Get_unwrapped@ABQAULIT@FVF@@@std@@YA?A_TABQAULIT@FVF@@@Z ENDP ; std::_Get_unwrapped<FVF::LIT * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_free@ULIT@FVF@@@@YAXAAPAULIT@FVF@@@Z
_TEXT	SEGMENT
??$xr_free@ULIT@FVF@@@@YAXAAPAULIT@FVF@@@Z PROC		; xr_free<FVF::LIT>, COMDAT
; _P$ = ecx

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@xr_free
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	push	eax
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	mov	DWORD PTR [esi], 0
$LN2@xr_free:
	pop	esi
	ret	0
??$xr_free@ULIT@FVF@@@@YAXAAPAULIT@FVF@@@Z ENDP		; xr_free<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory.h
;	COMDAT ??$xr_alloc@ULIT@FVF@@@@YAPAULIT@FVF@@I@Z
_TEXT	SEGMENT
??$xr_alloc@ULIT@FVF@@@@YAPAULIT@FVF@@I@Z PROC		; xr_alloc<FVF::LIT>, COMDAT
; _count$ = ecx

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	eax, 3
	push	eax
	call	DWORD PTR __imp_?mem_alloc@xrMemory@@QAEPAXI@Z
	ret	0
??$xr_alloc@ULIT@FVF@@@@YAPAULIT@FVF@@I@Z ENDP		; xr_alloc<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$xalloc@ULIT@FVF@@@@V?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1>::_Compressed_pair<xalloc<FVF::LIT>,std::_Vector_val<std::_Simple_types<FVF::LIT> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@XZ PROC ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Release, COMDAT
; _this$ = ecx

; 1625 :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 1626 :         return _Last;
; 1627 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEPAULIT@FVF@@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::~_Uninitialized_backout_al<xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::~_Uninitialized_backout_al<xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@PAULIT@FVF@@AAV?$xalloc@ULIT@FVF@@@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@PAULIT@FVF@@AAV?$xalloc@ULIT@FVF@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Uninitialized_backout_al<xalloc<FVF::LIT> >, COMDAT
; _this$ = ecx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAE@PAULIT@FVF@@AAV?$xalloc@ULIT@FVF@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Uninitialized_backout_al<xalloc<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEXPBQAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEXPBQAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Seek_to, COMDAT
; _this$ = ecx

; 205  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	eax, DWORD PTR __It$[esp-4]
	mov	DWORD PTR [ecx], eax

; 206  :     }

	ret	4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUwm_slot@WallmarksEngine@@@std@@@std@@@std@@QAEXPBQAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<WallmarksEngine::wm_slot *> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@QAEXPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@@Z PROC ; xalloc<WallmarksEngine::wm_slot *>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@PAUwm_slot@WallmarksEngine@@@@QAEXPAPAUwm_slot@WallmarksEngine@@@Z ENDP ; xalloc<WallmarksEngine::wm_slot *>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<FVF::LIT> >::_Vector_val<std::_Simple_types<FVF::LIT> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@ULIT@FVF@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<FVF::LIT> >::_Vector_val<std::_Simple_types<FVF::LIT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@@Z
_TEXT	SEGMENT
_p$dead$ = 8						; size = 4
?destroy@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@@Z PROC	; xalloc<FVF::LIT>::destroy, COMDAT
; _this$dead$ = ecx

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy_in_place(p);			}

	ret	4
?destroy@?$xalloc@ULIT@FVF@@@@QAEXPAULIT@FVF@@@Z ENDP	; xalloc<FVF::LIT>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ??0?$xalloc@ULIT@FVF@@@@QAE@XZ
_TEXT	SEGMENT
??0?$xalloc@ULIT@FVF@@@@QAE@XZ PROC			; xalloc<FVF::LIT>::xalloc<FVF::LIT>, COMDAT
; _this$ = ecx

; 76   : 													xalloc			()										{	}

	mov	eax, ecx
	ret	0
??0?$xalloc@ULIT@FVF@@@@QAE@XZ ENDP			; xalloc<FVF::LIT>::xalloc<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr.h
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr.h
;	COMDAT ??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_object$ = 8						; size = 4
??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z PROC ; intrusive_base::_release<CSkeletonWallmark>, COMDAT
; _this$dead$ = ecx

; 26   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 27   : 		try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	esi, DWORD PTR _object$[ebp]
	test	esi, esi
	je	SHORT $LN7@release
	mov	ecx, esi
	call	DWORD PTR __imp_??1CSkeletonWallmark@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	esi
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
$LN7@release:
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr.h

; 32   : 	}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z$0:

; 28   : 			xr_delete	(object);
; 29   : 		}
; 30   : 		catch(...) {
; 31   : 		}

	mov	eax, $LN7@release
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_release@VCSkeletonWallmark@@@intrusive_base@@QAEXPAVCSkeletonWallmark@@@Z ENDP ; intrusive_base::_release<CSkeletonWallmark>
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Find_unchecked1@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@QAPAU12@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Find_unchecked1@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@QAPAU12@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 5184 :     // find first matching _Val
; 5185 :     for (; _First != _Last; ++_First) {

	cmp	ecx, edx
	je	SHORT $LN21@Find_unche
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax]
	npad	5
$LL4@Find_unche:
	mov	eax, DWORD PTR [ecx]

; 90   : template<class T, class U, typename D>	inline bool operator	==	(resptr_core<T,D> const & a, resptr_core<U,D> const & b)		{ return a._get() == b._get();						}

	cmp	DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 5186 :         if (*_First == _Val) {

	je	SHORT $LN20@Find_unche

; 5184 :     // find first matching _Val
; 5185 :     for (; _First != _Last; ++_First) {

	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL4@Find_unche
$LN20@Find_unche:

; 5187 :             break;
; 5188 :         }
; 5189 :     }
; 5190 : 
; 5191 :     return _First;

	mov	eax, ecx
	pop	esi

; 5192 : }

	ret	0
$LN21@Find_unche:

; 5187 :             break;
; 5188 :         }
; 5189 :     }
; 5190 : 
; 5191 :     return _First;

	mov	eax, ecx

; 5192 : }

	ret	0
??$_Find_unchecked1@PAPAUwm_slot@WallmarksEngine@@V?$resptr_core@UShader@@Uresptrcode_shader@@@@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@QAPAU12@ABV?$resptr_core@UShader@@Uresptrcode_shader@@@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<WallmarksEngine::wm_slot * *,resptr_core<Shader,resptrcode_shader> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAPAUwm_slot@WallmarksEngine@@AAPAPAU12@@Z
_TEXT	SEGMENT
??$forward@PAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAPAUwm_slot@WallmarksEngine@@AAPAPAU12@@Z PROC ; std::forward<WallmarksEngine::wm_slot * *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAPAUwm_slot@WallmarksEngine@@@std@@YA$$QAPAPAUwm_slot@WallmarksEngine@@AAPAPAU12@@Z ENDP ; std::forward<WallmarksEngine::wm_slot * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z PROC ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAAAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ENDP ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN7@construct

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z
_TEXT	SEGMENT
??$forward@PAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z PROC ; std::forward<CWallmarksEngine::static_wallmark *>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@PAUstatic_wallmark@CWallmarksEngine@@@std@@YA$$QAPAUstatic_wallmark@CWallmarksEngine@@AAPAU12@@Z ENDP ; std::forward<CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAUstatic_wallmark@CWallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@$$QAPAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAUstatic_wallmark@CWallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@$$QAPAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 565  :         if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
; 566  :             (void) _Al; // TRANSITION, DevCom-1004719
; 567  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 568  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 569  : #else // __cpp_lib_constexpr_dynamic_alloc
; 570  :             ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
; 571  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 572  :         } else {
; 573  :             _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 574  :         }
; 575  :     }

	ret	0
??$construct@PAUstatic_wallmark@CWallmarksEngine@@PAU12@@?$_Normal_allocator_traits@V?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@@std@@SAXAAV?$xalloc@PAUstatic_wallmark@CWallmarksEngine@@@@PAPAUstatic_wallmark@CWallmarksEngine@@$$QAPAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<CWallmarksEngine::static_wallmark *> >::construct<CWallmarksEngine::static_wallmark *,CWallmarksEngine::static_wallmark *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z PROC ; std::move<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ENDP ; std::move<intrusive_ptr<CSkeletonWallmark,intrusive_base> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEX$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEX$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR [ecx+4]
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@Emplace_ba

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN17@Emplace_ba:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1622 :     }

	add	DWORD PTR [ecx+4], 4
	ret	4
??$_Emplace_back@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@?$_Uninitialized_backout_al@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@QAEX$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::_Emplace_back<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z PROC	; std::move<FVF::LIT &>, COMDAT
; __Arg$ = ecx

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, ecx

; 1398 : }

	ret	0
??$move@AAULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z ENDP	; std::move<FVF::LIT &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ULIT@FVF@@@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEX$$QAULIT@FVF@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ULIT@FVF@@@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEX$$QAULIT@FVF@@@Z PROC ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Emplace_back<FVF::LIT>, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	edx, DWORD PTR _<_Vals_0>$[esp-4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	esi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

	add	DWORD PTR [ecx+4], 24			; 00000018H
	pop	esi

; 1622 :     }

	ret	4
??$_Emplace_back@ULIT@FVF@@@?$_Uninitialized_backout_al@V?$xalloc@ULIT@FVF@@@@@std@@QAEX$$QAULIT@FVF@@@Z ENDP ; std::_Uninitialized_backout_al<xalloc<FVF::LIT> >::_Emplace_back<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Refancy@PAPAUwm_slot@WallmarksEngine@@$0A@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z
_TEXT	SEGMENT
??$_Refancy@PAPAUwm_slot@WallmarksEngine@@$0A@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z PROC ; std::_Refancy<WallmarksEngine::wm_slot * *,0>, COMDAT
; __Ptr$ = ecx

; 287  :     return _Ptr;

	mov	eax, ecx

; 288  : }

	ret	0
??$_Refancy@PAPAUwm_slot@WallmarksEngine@@$0A@@std@@YAPAPAUwm_slot@WallmarksEngine@@PAPAU12@@Z ENDP ; std::_Refancy<WallmarksEngine::wm_slot * *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z PROC ; std::_Destroy_in_place<intrusive_ptr<CSkeletonWallmark,intrusive_base> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YAXAAPAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@Z ENDP ; std::_Destroy_in_place<intrusive_ptr<CSkeletonWallmark,intrusive_base> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z PROC ; std::_Destroy_in_place<WallmarksEngine::wm_slot * *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAPAUwm_slot@WallmarksEngine@@@std@@YAXAAPAPAUwm_slot@WallmarksEngine@@@Z ENDP ; std::_Destroy_in_place<WallmarksEngine::wm_slot * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAULIT@FVF@@@std@@YAXAAPAULIT@FVF@@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAULIT@FVF@@@std@@YAXAAPAULIT@FVF@@@Z PROC ; std::_Destroy_in_place<FVF::LIT *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PAULIT@FVF@@@std@@YAXAAPAULIT@FVF@@@Z ENDP ; std::_Destroy_in_place<FVF::LIT *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCSkeletonWallmark@@@@YAXAAPAVCSkeletonWallmark@@@Z
_TEXT	SEGMENT
??$xr_delete@VCSkeletonWallmark@@@@YAXAAPAVCSkeletonWallmark@@@Z PROC ; xr_delete<CSkeletonWallmark>, COMDAT
; _ptr$ = ecx

; 150  : {

	push	esi
	mov	esi, ecx

; 151  : 	if (ptr) 

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@xr_delete
	call	DWORD PTR __imp_??1CSkeletonWallmark@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z

; 152  : 	{
; 153  : 		xr_special_free<is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = nullptr;

	mov	DWORD PTR [esi], 0
$LN2@xr_delete:

; 155  : 	}
; 156  : }

	pop	esi
	ret	0
??$xr_delete@VCSkeletonWallmark@@@@YAXAAPAVCSkeletonWallmark@@@Z ENDP ; xr_delete<CSkeletonWallmark>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z
_TEXT	SEGMENT
??$forward@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z PROC ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@std@@YA$$QAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@AAV1@@Z ENDP ; std::forward<intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@$$QAV3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@$$QAV3@@Z PROC ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\intrusive_ptr_inline.h

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]

; 30   : 	m_object		= 0;

	mov	DWORD PTR [edx], 0

; 115  : 	if (m_object == rhs.m_object)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN7@construct

; 116  : 		return;
; 117  : 	dec				();
; 118  : 	m_object		= rhs.m_object;

	mov	DWORD PTR [edx], eax

; 119  : 	if (!m_object)
; 120  : 		return;
; 121  : 	++m_object->m_ref_count;

	inc	DWORD PTR [eax]
$LN7@construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@V1@@?$_Normal_allocator_traits@V?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@@std@@SAXAAV?$xalloc@V?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@@@PAV?$intrusive_ptr@VCSkeletonWallmark@@Uintrusive_base@@@@$$QAV3@@Z ENDP ; std::_Normal_allocator_traits<xalloc<intrusive_ptr<CSkeletonWallmark,intrusive_base> > >::construct<intrusive_ptr<CSkeletonWallmark,intrusive_base>,intrusive_ptr<CSkeletonWallmark,intrusive_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z
_TEXT	SEGMENT
??$forward@ULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z PROC ; std::forward<FVF::LIT>, COMDAT
; __Arg$ = ecx

; 1386 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, ecx

; 1387 : }

	ret	0
??$forward@ULIT@FVF@@@std@@YA$$QAULIT@FVF@@AAU12@@Z ENDP ; std::forward<FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@ULIT@FVF@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@$$QAU34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@ULIT@FVF@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@$$QAU34@@Z PROC ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	::new((void*)p) value_type (_Val); }

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 575  :     }

	ret	0
??$construct@ULIT@FVF@@U12@@?$_Normal_allocator_traits@V?$xalloc@ULIT@FVF@@@@@std@@SAXAAV?$xalloc@ULIT@FVF@@@@PAULIT@FVF@@$$QAU34@@Z ENDP ; std::_Normal_allocator_traits<xalloc<FVF::LIT> >::construct<FVF::LIT,FVF::LIT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xrMemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCSkeletonWallmark@@@@QAEXAAPAVCSkeletonWallmark@@@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
??R?$xr_special_free@$0A@VCSkeletonWallmark@@@@QAEXAAPAVCSkeletonWallmark@@@Z PROC ; xr_special_free<0,CSkeletonWallmark>::operator(), COMDAT
; _this$dead$ = ecx

; 142  : 	{

	push	esi

; 143  : 		ptr->~T			();

	mov	esi, DWORD PTR _ptr$[esp]
	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_??1CSkeletonWallmark@@QAE@XZ

; 144  : 		Memory.mem_free	(ptr);

	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	DWORD PTR __imp_?mem_free@xrMemory@@QAEXPAX@Z
	pop	esi

; 145  : 	}

	ret	4
??R?$xr_special_free@$0A@VCSkeletonWallmark@@@@QAEXAAPAVCSkeletonWallmark@@@Z ENDP ; xr_special_free<0,CSkeletonWallmark>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GCSkeletonWallmark@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GCSkeletonWallmark@@QAEPAXI@Z PROC			; CSkeletonWallmark::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1CSkeletonWallmark@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	4
??_GCSkeletonWallmark@@QAEPAXI@Z ENDP			; CSkeletonWallmark::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??0?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??0?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QAE@ABV0@@Z PROC ; resptr_core<SGeometry,resptrcode_geom>::resptr_core<SGeometry,resptrcode_geom>, COMDAT
; _this$ = ecx

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 43   : 	void				_inc	()									{	if (0==p_) return;	p_->dwReference++;														}

	test	eax, eax
	je	SHORT $LN6@resptr_cor
	inc	DWORD PTR [eax]
$LN6@resptr_cor:

; 63   : 						resptr_core		(const self & rhs)								{	p_ = rhs.p_; _inc();		}

	mov	eax, ecx
	ret	4
??0?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QAE@ABV0@@Z ENDP ; resptr_core<SGeometry,resptrcode_geom>::resptr_core<SGeometry,resptrcode_geom>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h
;	COMDAT ?set@LIT@FVF@@QAEXABU?$_vector3@M@@IMM@Z
_TEXT	SEGMENT
__p$ = 8						; size = 4
_C$ = 12						; size = 4
_u$ = 16						; size = 4
_v$ = 20						; size = 4
?set@LIT@FVF@@QAEXABU?$_vector3@M@@IMM@Z PROC		; FVF::LIT::set, COMDAT
; _this$ = ecx
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR __p$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	xmm0, DWORD PTR _u$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fld	DWORD PTR [eax]
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	eax, DWORD PTR _C$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [ecx+16], xmm0
	movss	xmm0, DWORD PTR _v$[esp-4]
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	fstp	DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	mov	DWORD PTR [ecx+12], eax
; File I:\Vitalya\mine\NSProjectX\xrCore\_vector2.h

; 15   : 	IC SelfRef set(float _u, float _v)				{ x=T(_u); y=T(_v);				return *this;	}

	movss	DWORD PTR [ecx+20], xmm0
; File I:\Vitalya\mine\NSProjectX\xrEngine\fvf.h

; 32   : 		IC void		set(const Fvector& _p, u32 C, float u, float v) { p.set(_p); color = C; t.set(u, v); }

	ret	16					; 00000010H
?set@LIT@FVF@@QAEXABU?$_vector3@M@@IMM@Z ENDP		; FVF::LIT::set
_TEXT	ENDS
END
