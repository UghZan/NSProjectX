; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30146.0 

	TITLE	i:\vitalya\mine\nsprojectx\nspx_build\intermediate\release-win32\xrrender_r1\detailmanager_soft.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?flush_cache@R_constants@@QAEXXZ:PROC
EXTRN	__imp_?flush@R_constants@@QAEXXZ:PROC
EXTRN	__imp_?Render@CBackend@@QAEXW4_D3DPRIMITIVETYPE@@IIIII@Z:PROC
EXTRN	__imp_?set_Format@CBackend@@QAEXPAUIDirect3DVertexDeclaration9@@@Z:PROC
EXTRN	__imp_?set_Vertices@CBackend@@QAEXPAUIDirect3DVertexBuffer9@@I@Z:PROC
EXTRN	__imp_?set_Indices@CBackend@@QAEXPAUIDirect3DIndexBuffer9@@@Z:PROC
EXTRN	__imp_?set_Geometry@CBackend@@QAEXPAUSGeometry@@@Z:PROC
EXTRN	__imp_?set_Geometry@CBackend@@QAEXAAV?$resptr_core@USGeometry@@Uresptrcode_geom@@@@@Z:PROC
EXTRN	__imp_?Unlock@_IndexStream@@QAEXI@Z:PROC
EXTRN	__imp_?Unlock@_VertexStream@@QAEXII@Z:PROC
EXTRN	__imp_?Lock@_IndexStream@@QAEPAGIAAI@Z:PROC
EXTRN	__imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z:PROC
EXTRN	__imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z:PROC
EXTRN	__imp_?destroy@resptrcode_geom@@QAEXXZ:PROC
EXTRN	__imp_?Buffer@_VertexStream@@QAEPAUIDirect3DVertexBuffer9@@XZ:PROC
EXTRN	__imp_?Buffer@_IndexStream@@QAEPAUIDirect3DIndexBuffer9@@XZ:PROC
EXTRN	__imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z:PROC
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
PUBLIC	??D?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEAAUSGeometry@@XZ ; resptr_core<SGeometry,resptrcode_geom>::operator*
PUBLIC	?_get@?$resptr_base@USDeclaration@@@@QBEPAUSDeclaration@@XZ ; resptr_base<SDeclaration>::_get
PUBLIC	??$_To_address@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@YA?A_PABQAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@Z ; std::_To_address<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
PUBLIC	??$_Copy_memmove@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z ; std::_Copy_memmove<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
PUBLIC	??$_Move_unchecked@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z ; std::_Move_unchecked<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Compat
PUBLIC	?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Xrange
PUBLIC	?erase@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@0@Z ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::erase
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEABQAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator==
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
PUBLIC	??C?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEPAUSGeometry@@XZ ; resptr_core<SGeometry,resptrcode_geom>::operator->
PUBLIC	?at@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEAAPAUSlotItem@CDetailManager@@I@Z ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::at
PUBLIC	?begin@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::begin
PUBLIC	?end@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::end
PUBLIC	?clear_not_free@?$xr_vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@@QAEXXZ ; xr_vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::clear_not_free
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator!=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEAAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++
PUBLIC	?soft_Load@CDetailManager@@QAEXXZ		; CDetailManager::soft_Load
PUBLIC	?soft_Unload@CDetailManager@@QAEXXZ		; CDetailManager::soft_Unload
PUBLIC	?soft_Render@CDetailManager@@QAEXXZ		; CDetailManager::soft_Render
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
_TEXT	SEGMENT
_Object$1$ = -128					; size = 4
_iDest$1$ = -124					; size = 4
_vDest$1$ = -120					; size = 4
_iOffset$1$ = -116					; size = 4
_vCount_Lock$1$ = -112					; size = 4
_item_idx$1$ = -108					; size = 4
_vCount_Object$1$ = -104				; size = 4
_this$1$ = -100						; size = 4
_iCount_Object$1$ = -96					; size = 4
__VS$1$ = -92						; size = 4
_iCount_Lock$1$ = -88					; size = 4
__IS$1$ = -84						; size = 4
_L_ID$1$ = -80						; size = 4
tv1783 = -76						; size = 4
_O$1$ = -72						; size = 4
tv1778 = -68						; size = 4
tv1779 = -64						; size = 4
tv1807 = -60						; size = 4
tv1781 = -56						; size = 4
_o_total$1$ = -52					; size = 4
_items$1$ = -48						; size = 4
_mXform$8$ = -44					; size = 4
tv1774 = -40						; size = 4
_mXform$9$ = -36					; size = 4
tv1775 = -32						; size = 4
_mXform$4$ = -28					; size = 4
$T1 = -24						; size = 4
_dwNumPrimitives$1$ = -24				; size = 4
tv1776 = -24						; size = 4
_baseV$1$ = -20						; size = 4
__vb$1$ = -20						; size = 4
_item_end$2$ = -20					; size = 4
_iBase$2 = -16						; size = 4
_vBase$3 = -12						; size = 4
_item_end$1$ = -8					; size = 4
__vis$1$ = -4						; size = 4
?soft_Render@CDetailManager@@QAEXXZ PROC		; CDetailManager::soft_Render
; _this$ = ecx

; 20   : {

	sub	esp, 128				; 00000080H

; 21   : 	// Render itself
; 22   : 	// float	fPhaseRange	= PI/16;
; 23   : 	// float	fPhaseX		= _sin(Device.fTimeGlobal*0.1f)	*fPhaseRange;
; 24   : 	// float	fPhaseZ		= _sin(Device.fTimeGlobal*0.11f)*fPhaseRange;
; 25   : 
; 26   : 	// Get index-stream
; 27   : 	_IndexStream&	_IS		= RCache.Index;

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	mov	edx, ecx
	push	ebx
	push	ebp

; 29   : 	for (u32 O=0; O<objects.size(); O++)

	xor	ebx, ebx
	mov	DWORD PTR __VS$1$[esp+136], eax
	add	eax, 20					; 00000014H
	mov	DWORD PTR _this$1$[esp+136], edx
	push	esi
	push	edi
	mov	DWORD PTR __IS$1$[esp+144], eax
	mov	DWORD PTR _O$1$[esp+144], ebx
	cmp	DWORD PTR [edx+1392], ebx
	jbe	$LN165@soft_Rende

; 21   : 	// Render itself
; 22   : 	// float	fPhaseRange	= PI/16;
; 23   : 	// float	fPhaseX		= _sin(Device.fTimeGlobal*0.1f)	*fPhaseRange;
; 24   : 	// float	fPhaseZ		= _sin(Device.fTimeGlobal*0.11f)*fPhaseRange;
; 25   : 
; 26   : 	// Get index-stream
; 27   : 	_IndexStream&	_IS		= RCache.Index;

	xor	esi, esi
	lea	ecx, DWORD PTR [edx+1136]
	mov	DWORD PTR tv1779[esp+144], esi
	mov	DWORD PTR tv1778[esp+144], ecx
$LL4@soft_Rende:

; 30   : 	{
; 31   : 		CDetail& Object		= *objects[O];

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _Object$1$[esp+144], eax

; 33   : 		u32	iCount_Object	= Object.number_indices;

	mov	ecx, DWORD PTR [eax+72]
	mov	ebp, DWORD PTR [eax+64]
	mov	DWORD PTR _iCount_Object$1$[esp+144], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	ecx, DWORD PTR [edx+1396]
	add	ecx, esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 32   : 		u32	vCount_Object	= Object.number_vertices;

	mov	DWORD PTR _vCount_Object$1$[esp+144], ebp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 119  :         _Ptr += _Off;

	mov	DWORD PTR __vis$1$[esp+144], ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 38   : 		for (; _vI!=_vE; _vI++){

	je	$LN172@soft_Rende
	add	eax, 56					; 00000038H
	mov	DWORD PTR tv1807[esp+144], eax
	npad	7
$LL7@soft_Rende:

; 39   : 			SlotItemVec*	items	= *_vI;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _items$1$[esp+144], eax

; 49   : 
; 50   : 			// Fill VB (and flush it as nesessary)
; 51   : 			RCache.set_Shader	(Object.shader);

	push	0
	push	DWORD PTR tv1807[esp+148]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	ebx, DWORD PTR [eax+4]
	sub	ebx, DWORD PTR [eax]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 40   : 			u32	vCount_Total		= items->size()*vCount_Object;

	mov	eax, 91625969				; 057619f1H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sar	ebx, 2
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 40   : 			u32	vCount_Total		= items->size()*vCount_Object;

	mov	ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1536 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	DWORD PTR _o_total$1$[esp+152], ebx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 40   : 			u32	vCount_Total		= items->size()*vCount_Object;

	imul	ecx, ebp
	mul	ecx
	shr	edx, 6

; 41   : 			// calculate lock count needed
; 42   : 			u32	lock_count			= vCount_Total/vs_size;
; 43   : 			if	(vCount_Total>(lock_count*vs_size))	lock_count++;

	imul	eax, edx, 3000
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	cmp	ecx, eax
	lea	ecx, DWORD PTR [edx+1]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 46   : 			u32	o_total			= items->size();

	mov	eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	cmovbe	ecx, edx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 46   : 			u32	o_total			= items->size();

	xor	edx, edx
	div	ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1535 :         auto& _My_data = _Mypair._Myval2;

	mov	DWORD PTR tv1783[esp+152], ecx
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 48   : 			if  (o_total > (o_per_lock*lock_count))	o_per_lock++;

	mov	ecx, ebx
	sub	ecx, edx

; 49   : 
; 50   : 			// Fill VB (and flush it as nesessary)
; 51   : 			RCache.set_Shader	(Object.shader);

	cmp	ebx, ecx
	mov	ecx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	lea	edx, DWORD PTR [eax+1]
	cmovbe	edx, eax
	mov	DWORD PTR tv1781[esp+152], edx
	call	DWORD PTR __imp_?set_Shader@CBackend@@QAEXAAV?$resptr_core@UShader@@Uresptrcode_shader@@@@I@Z

; 54   : 			for (u32 L_ID=0; L_ID<lock_count; L_ID++){

	cmp	DWORD PTR tv1783[esp+144], 0
	mov	ebp, DWORD PTR _vCount_Object$1$[esp+144]
	mov	DWORD PTR _L_ID$1$[esp+144], 0
	jbe	$LN5@soft_Rende
	xor	ebx, ebx
	mov	DWORD PTR _item_idx$1$[esp+144], ebx
	npad	8
$LL10@soft_Rende:

; 55   : 				// Calculate params
; 56   : 				u32	item_start	= L_ID*o_per_lock;
; 57   : 				u32	item_end	= item_start+o_per_lock;

	mov	ecx, DWORD PTR tv1781[esp+144]
	add	ecx, ebx

; 58   : 				if (item_end>o_total)	item_end = o_total;

	cmp	ecx, DWORD PTR _o_total$1$[esp+144]
	mov	eax, ecx
	mov	DWORD PTR _item_end$1$[esp+144], ecx
	cmova	eax, DWORD PTR _o_total$1$[esp+144]
	mov	DWORD PTR _item_end$2$[esp+144], eax

; 59   : 				if (item_end<=item_start)	break;

	cmp	eax, ebx
	jbe	$LN5@soft_Rende

; 60   : 				u32	item_range	= item_end-item_start;

	sub	eax, ebx

; 61   : 
; 62   : 				// Calc Lock params
; 63   : 				u32	vCount_Lock	= item_range*vCount_Object;

	mov	ecx, eax

; 64   : 				u32	iCount_Lock = item_range*iCount_Object;

	imul	eax, DWORD PTR _iCount_Object$1$[esp+144]
	imul	ecx, ebp

; 65   : 
; 66   : 				// Lock buffers
; 67   : 				u32	vBase,iBase,iOffset=0;

	xor	ebp, ebp
	mov	DWORD PTR _iOffset$1$[esp+144], ebp
	mov	DWORD PTR _iCount_Lock$1$[esp+144], eax

; 68   : 				CDetail::fvfVertexOut* vDest	= (CDetail::fvfVertexOut*)	_VS.Lock(vCount_Lock,soft_Geom->vb_stride,vBase);

	lea	eax, DWORD PTR _vBase$3[esp+144]
	push	eax
	mov	eax, DWORD PTR _this$1$[esp+148]
	mov	DWORD PTR _vCount_Lock$1$[esp+148], ecx
	mov	eax, DWORD PTR [eax+701224]
	push	DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __VS$1$[esp+156]
	call	DWORD PTR __imp_?Lock@_VertexStream@@QAEPAXIIAAI@Z

; 69   : 				u16*	iDest					= (u16*)					_IS.Lock(iCount_Lock,iBase);

	mov	ecx, DWORD PTR __IS$1$[esp+144]
	mov	DWORD PTR _vDest$1$[esp+144], eax
	lea	eax, DWORD PTR _iBase$2[esp+144]
	push	eax
	push	DWORD PTR _iCount_Lock$1$[esp+148]
	call	DWORD PTR __imp_?Lock@_IndexStream@@QAEPAGIAAI@Z
	mov	DWORD PTR _iDest$1$[esp+144], eax
	npad	4
$LL13@soft_Rende:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1571 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	ecx, DWORD PTR _items$1$[esp+144]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, ebx
	jbe	$LN143@soft_Rende
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 74   : 					float	scale			= Instance.scale_calculated;

	mov	eax, DWORD PTR [eax+ebx*4]
	movss	xmm2, DWORD PTR [eax+4]

; 75   : 
; 76   : 					// Build matrix
; 77   : 					Fmatrix& M = Instance.mRotY;
; 78   : 					mXform._11=M._11*scale;	mXform._12=M._12*scale;	mXform._13=M._13*scale;	mXform._14=M._14;
; 79   : 					mXform._21=M._21*scale;	mXform._22=M._22*scale;	mXform._23=M._23*scale;	mXform._24=M._24;

	movaps	xmm0, xmm2
	movaps	xmm3, xmm2
	mulss	xmm0, DWORD PTR [eax+32]
	movaps	xmm4, xmm2
	mulss	xmm3, DWORD PTR [eax+8]
	movaps	xmm5, xmm2
	mulss	xmm4, DWORD PTR [eax+12]
	movaps	xmm6, xmm2
	mulss	xmm5, DWORD PTR [eax+16]
	movaps	xmm7, xmm2
	mulss	xmm6, DWORD PTR [eax+24]
	mulss	xmm7, DWORD PTR [eax+28]
	movss	DWORD PTR _mXform$4$[esp+144], xmm0

; 80   : 					mXform._31=M._31*scale;	mXform._32=M._32*scale;	mXform._33=M._33*scale;	mXform._34=M._34;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+40]
	movss	DWORD PTR _mXform$8$[esp+144], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+44]
	mulss	xmm2, DWORD PTR [eax+48]
	movss	DWORD PTR _mXform$9$[esp+144], xmm0

; 81   : 					mXform._41=M._41;		mXform._42=M._42;		mXform._43=M._43;		mXform._44=1;

	movss	xmm0, DWORD PTR [eax+56]
	movss	DWORD PTR tv1774[esp+144], xmm0
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR tv1775[esp+144], xmm0
	movss	xmm0, DWORD PTR [eax+64]

; 82   : 
; 83   : 					// Transfer vertices
; 84   : 					{
; 85   : 						u32					C = 0xffffffff;
; 86   : 						CDetail::fvfVertexIn	*srcIt = Object.vertices, *srcEnd = Object.vertices+Object.number_vertices;

	mov	eax, DWORD PTR _Object$1$[esp+144]
	movss	DWORD PTR tv1776[esp+144], xmm0
	mov	ecx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR [eax+64]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ecx+eax*4]

; 87   : 						CDetail::fvfVertexOut	*dstIt = vDest;
; 88   : 
; 89   : 						for	(; srcIt!=srcEnd; srcIt++, dstIt++){

	cmp	ecx, edx
	je	$LN19@soft_Rende
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1575 :         return _My_data._Myfirst[_Pos];

	mov	eax, DWORD PTR _vDest$1$[esp+144]
	add	eax, 8
$LL16@soft_Rende:
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 499  : 		dest.x = v.x*_11 + v.y*_21 + v.z*_31 + _41;

	movaps	xmm1, xmm6
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm1, DWORD PTR [ecx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _mXform$8$[esp+144]
	mulss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR tv1774[esp+144]
	addss	xmm1, xmm0

; 500  : 		dest.y = v.x*_12 + v.y*_22 + v.z*_32 + _42;

	movaps	xmm0, xmm4
	movss	DWORD PTR [eax-8], xmm1
	movaps	xmm1, xmm7
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm1, DWORD PTR [ecx+4]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _mXform$9$[esp+144]
	mulss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR tv1775[esp+144]
	addss	xmm1, xmm0

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	movaps	xmm0, xmm5
	movss	DWORD PTR [eax-4], xmm1
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR _mXform$4$[esp+144]
	mulss	xmm1, DWORD PTR [ecx+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 91   :                             dstIt->C	= C;

	mov	DWORD PTR [eax+4], -1
; File I:\Vitalya\mine\NSProjectX\xrCore\_matrix.h

; 501  : 		dest.z = v.x*_13 + v.y*_23 + v.z*_33 + _43;

	addss	xmm0, DWORD PTR tv1776[esp+144]
	addss	xmm1, xmm0
	movss	DWORD PTR [eax], xmm1
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 92   :                             dstIt->u	= srcIt->u;

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+8]

; 93   :                             dstIt->v	= srcIt->v;

	fld	DWORD PTR [ecx+16]
	add	ecx, 20					; 00000014H
	fstp	DWORD PTR [eax+12]
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	$LL16@soft_Rende
$LN19@soft_Rende:

; 94   : 						}
; 95   : 					}
; 96   : 
; 97   : 					// Transfer indices (in 32bit lines)
; 98   : 					VERIFY	(iOffset<65535);
; 99   : 					{
; 100  : 						u32	item	= (iOffset<<16) | iOffset;
; 101  : 						u32	count	= Object.number_indices/2;
; 102  : 						LPDWORD	sit		= LPDWORD(Object.indices);

	mov	eax, DWORD PTR _Object$1$[esp+144]
	mov	ebx, ebp

; 103  : 						LPDWORD	send	= sit+count;
; 104  : 						LPDWORD	dit		= LPDWORD(iDest);

	mov	edx, DWORD PTR _iDest$1$[esp+144]
	shl	ebx, 16					; 00000010H
	or	ebx, ebp
	mov	ecx, DWORD PTR [eax+68]
	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR $T1[esp+144], eax
	shr	eax, 1
	lea	ebp, DWORD PTR [ecx+eax*4]

; 105  : 						for		(; sit!=send; dit++,sit++)	*dit=*sit+item;

	cmp	ecx, ebp
	je	SHORT $LN173@soft_Rende
	npad	2
$LL22@soft_Rende:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+4]
	add	eax, ebx
	add	ecx, 4
	mov	DWORD PTR [edx-4], eax
	cmp	ecx, ebp
	jne	SHORT $LL22@soft_Rende
	mov	eax, DWORD PTR _Object$1$[esp+144]
	mov	ecx, DWORD PTR [eax+72]
	jmp	SHORT $LN163@soft_Rende
$LN173@soft_Rende:
	mov	ecx, DWORD PTR $T1[esp+144]
	mov	eax, DWORD PTR _Object$1$[esp+144]
$LN163@soft_Rende:

; 106  : 						if		(Object.number_indices&1)

	mov	ebp, DWORD PTR _iOffset$1$[esp+144]
	mov	edx, DWORD PTR _iDest$1$[esp+144]
	test	cl, 1
	je	SHORT $LN27@soft_Rende

; 107  : 							iDest[Object.number_indices-1]=(u16)(Object.indices[Object.number_indices-1]+u16(iOffset));

	mov	eax, DWORD PTR [eax+68]
	mov	ax, WORD PTR [eax+ecx*2-2]
	add	ax, bp
	mov	WORD PTR [edx+ecx*2-2], ax
$LN27@soft_Rende:

; 108  : 					}
; 109  : 
; 110  : 					// Increment counters
; 111  : 					vDest					+=	vCount_Object;

	mov	ebx, DWORD PTR _vCount_Object$1$[esp+144]

; 112  : 					iDest					+=	iCount_Object;
; 113  : 					iOffset					+=	vCount_Object;

	add	ebp, ebx
	mov	ecx, DWORD PTR _vDest$1$[esp+144]
	mov	DWORD PTR _iOffset$1$[esp+144], ebp
	lea	eax, DWORD PTR [ebx+ebx*2]
	mov	ebx, DWORD PTR _item_idx$1$[esp+144]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	ebx
	mov	eax, DWORD PTR _iCount_Object$1$[esp+144]
	mov	DWORD PTR _vDest$1$[esp+144], ecx
	mov	DWORD PTR _item_idx$1$[esp+144], ebx
	lea	edx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _iDest$1$[esp+144], edx
	cmp	ebx, DWORD PTR _item_end$2$[esp+144]
	jb	$LL13@soft_Rende

; 114  : 				}
; 115  : 				_VS.Unlock		(vCount_Lock,soft_Geom->vb_stride);

	mov	ebp, DWORD PTR _this$1$[esp+144]
	mov	ecx, DWORD PTR __VS$1$[esp+144]
	mov	eax, DWORD PTR [ebp+701224]
	push	DWORD PTR [eax+20]
	push	DWORD PTR _vCount_Lock$1$[esp+148]
	call	DWORD PTR __imp_?Unlock@_VertexStream@@QAEXII@Z

; 116  : 				_IS.Unlock		(iCount_Lock);

	mov	ebx, DWORD PTR _iCount_Lock$1$[esp+144]
	mov	ecx, DWORD PTR __IS$1$[esp+144]
	push	ebx
	call	DWORD PTR __imp_?Unlock@_IndexStream@@QAEXI@Z
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	ebp, DWORD PTR [ebp+701224]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 119  : 				u32	dwNumPrimitives		= iCount_Lock/3;

	mov	eax, -1431655765			; aaaaaaabH
	mul	ebx
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	eax, DWORD PTR [ebp+8]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 120  : 				RCache.set_Geometry		(soft_Geom);

	mov	ebx, DWORD PTR __imp_?RCache@@3VCBackend@@A
	shr	edx, 1
	mov	DWORD PTR _dwNumPrimitives$1$[esp+144], edx
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 224  : 	set_Format(_geom->dcl._get()->dcl);

	mov	edx, DWORD PTR [eax+8]

; 131  : 	if (decl != _decl)

	cmp	DWORD PTR [ebx+592], edx
	je	SHORT $LN94@soft_Rende

; 132  : 	{
; 133  : 		PGO(Msg("PGO:v_format:%x", _decl));
; 134  : #ifdef DEBUG
; 135  : 		stat.decl++;
; 136  : #endif
; 137  : 		decl = _decl;

	mov	DWORD PTR [ebx+592], edx

; 138  : 		CHK_DX(HW.pDevice->SetVertexDeclaration(decl));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+348]
$LN94@soft_Rende:

; 225  : 	set_Vertices(_geom->vb, _geom->vb_stride);

	mov	eax, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+20]
	mov	DWORD PTR __vb$1$[esp+144], eax

; 172  : 	if ((vb != _vb) || (vb_stride != _vb_stride))

	cmp	DWORD PTR [ebx+596], eax
	jne	SHORT $LN98@soft_Rende
	cmp	DWORD PTR [ebx+604], edx
	je	SHORT $LN97@soft_Rende
$LN98@soft_Rende:

; 173  : 	{
; 174  : 		PGO(Msg("PGO:VB:%x,%d", _vb, _vb_stride));
; 175  : #ifdef DEBUG
; 176  : 		stat.vb++;
; 177  : #endif
; 178  : 		vb = _vb;

	mov	DWORD PTR [ebx+596], eax

; 179  : 		vb_stride = _vb_stride;

	mov	DWORD PTR [ebx+604], edx

; 180  : 		CHK_DX(HW.pDevice->SetStreamSource(0, vb, 0, vb_stride));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	push	0
	push	DWORD PTR __vb$1$[esp+152]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+400]
$LN97@soft_Rende:

; 226  : 	set_Indices(_geom->ib);

	mov	edx, DWORD PTR [ebp+16]

; 186  : 	if (ib != _ib)

	cmp	DWORD PTR [ebx+600], edx
	je	SHORT $LN101@soft_Rende

; 187  : 	{
; 188  : 		PGO(Msg("PGO:IB:%x", _ib));
; 189  : #ifdef DEBUG
; 190  : 		stat.ib++;
; 191  : #endif
; 192  : 		ib = _ib;

	mov	DWORD PTR [ebx+600], edx

; 193  : 		CHK_DX(HW.pDevice->SetIndices(ib));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	edx
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]
$LN101@soft_Rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 121  : 				RCache.Render			(D3DPT_TRIANGLELIST,vBase,0,vCount_Lock,iBase,dwNumPrimitives);

	mov	eax, DWORD PTR _vBase$3[esp+144]
	mov	ebp, DWORD PTR _iBase$2[esp+144]
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 200  : 	stat.verts += countV;

	mov	ecx, DWORD PTR _vCount_Lock$1$[esp+144]

; 201  : 	stat.polys += PC;

	mov	ebx, DWORD PTR _dwNumPrimitives$1$[esp+144]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 121  : 				RCache.Render			(D3DPT_TRIANGLELIST,vBase,0,vCount_Lock,iBase,dwNumPrimitives);

	mov	DWORD PTR _baseV$1$[esp+144], eax
	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 200  : 	stat.verts += countV;

	add	DWORD PTR [eax+9020], ecx

; 202  : 	constants.flush();

	lea	ecx, DWORD PTR [eax+608]
	inc	DWORD PTR [eax+9024]
	add	DWORD PTR [eax+9016], ebx
; File I:\Vitalya\mine\NSProjectX\xrEngine\r_constants_cache.h

; 172  : 		if (a_pixel.b_dirty || a_vertex.b_dirty)	flush_cache();

	cmp	DWORD PTR [ecx+4112], 0
	jne	SHORT $LN107@soft_Rende
	cmp	DWORD PTR [ecx+8240], 0
	je	SHORT $LN106@soft_Rende
$LN107@soft_Rende:
	call	DWORD PTR __imp_?flush_cache@R_constants@@QAEXXZ
$LN106@soft_Rende:
; File I:\Vitalya\mine\NSProjectX\xrEngine\R_Backend_Runtime.h

; 203  : 	CHK_DX(HW.pDevice->DrawIndexedPrimitive(T, baseV, startV, countV, startI, PC));

	mov	eax, DWORD PTR __imp_?HW@@3VCHW@@A
	push	ebx
	push	ebp
	push	DWORD PTR _vCount_Lock$1$[esp+152]
	mov	eax, DWORD PTR [eax+8]
	push	0
	push	DWORD PTR _baseV$1$[esp+160]
	mov	ecx, DWORD PTR [eax]
	push	4
	push	eax
	call	DWORD PTR [ecx+328]
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 54   : 			for (u32 L_ID=0; L_ID<lock_count; L_ID++){

	mov	eax, DWORD PTR _L_ID$1$[esp+144]
	mov	ebx, DWORD PTR _item_end$1$[esp+144]
	inc	eax
	mov	ebp, DWORD PTR _vCount_Object$1$[esp+144]
	mov	DWORD PTR _L_ID$1$[esp+144], eax
	mov	DWORD PTR _item_idx$1$[esp+144], ebx
	cmp	eax, DWORD PTR tv1783[esp+144]
	jb	$LL10@soft_Rende
$LN5@soft_Rende:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 74   :         ++_Ptr;

	add	esi, 4

; 150  :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 38   : 		for (; _vI!=_vE; _vI++){

	jne	$LL7@soft_Rende
	mov	edx, DWORD PTR _this$1$[esp+144]
	mov	ecx, DWORD PTR __vis$1$[esp+144]
	mov	ebx, DWORD PTR _O$1$[esp+144]
$LN172@soft_Rende:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	eax, DWORD PTR [ecx]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;
; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN124@soft_Rende

; 1426 :             _Orphan_range(_Firstptr, _Mylast);
; 1427 : 
; 1428 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
; 1429 :             _Destroy(_Newlast, _Mylast);
; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ecx+4], eax
$LN124@soft_Rende:
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 29   : 	for (u32 O=0; O<objects.size(); O++)

	mov	ecx, DWORD PTR tv1778[esp+144]
	inc	ebx
	mov	esi, DWORD PTR tv1779[esp+144]
	add	ecx, 4
	add	esi, 12					; 0000000cH
	mov	DWORD PTR _O$1$[esp+144], ebx
	mov	DWORD PTR tv1778[esp+144], ecx
	mov	DWORD PTR tv1779[esp+144], esi
	cmp	ebx, DWORD PTR [edx+1392]
	jb	$LL4@soft_Rende
$LN165@soft_Rende:

; 127  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 128				; 00000080H
	ret	0
$LN143@soft_Rende:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1572 :             _Xrange();

	call	?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Xrange
$LN175@soft_Rende:
	int	3
?soft_Render@CDetailManager@@QAEXXZ ENDP		; CDetailManager::soft_Render
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
_TEXT	SEGMENT
?soft_Unload@CDetailManager@@QAEXXZ PROC		; CDetailManager::soft_Unload
; _this$ = ecx

; 15   : {

	push	esi

; 16   : 	soft_Geom.destroy				();

	lea	esi, DWORD PTR [ecx+701224]
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h

; 46   : 	ICF		void		_set	(T * rhs) 							{	if (0!=rhs) rhs->dwReference++;	_dec(); p_ = rhs;											}

	mov	ecx, esi
	call	DWORD PTR __imp_?_dec@?$resptr_base@USGeometry@@@@IAEXXZ
	mov	DWORD PTR [esi], 0
	pop	esi
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp

; 17   : }

	ret	0
?soft_Unload@CDetailManager@@QAEXXZ ENDP		; CDetailManager::soft_Unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\layers\xrRender\DetailManager_soft.cpp
_TEXT	SEGMENT
?soft_Load@CDetailManager@@QAEXXZ PROC			; CDetailManager::soft_Load
; _this$ = ecx

; 10   : 	// Vertex Stream
; 11   : 	soft_Geom.create				(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1, RCache.Vertex.Buffer(), RCache.Index.Buffer());

	mov	eax, DWORD PTR __imp_?RCache@@3VCBackend@@A
	add	ecx, 701224				; 000ab328H
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax]
	push	322					; 00000142H
	call	DWORD PTR __imp_?create@resptrcode_geom@@QAEXIPAUIDirect3DVertexBuffer9@@PAUIDirect3DIndexBuffer9@@@Z

; 12   : }

	ret	0
?soft_Load@CDetailManager@@QAEXXZ ENDP			; CDetailManager::soft_Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++, COMDAT
; _this$ = ecx

; 281  :         _Vector_iterator _Tmp = *this;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 74   :         ++_Ptr;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 282  :         _Mybase::operator++();
; 283  :         return _Tmp;
; 284  :     }

	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEAAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEAAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*, COMDAT
; _this$ = ecx

; 261  :         return const_cast<reference>(_Mybase::operator*());

	mov	eax, DWORD PTR [ecx]

; 262  :     }

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEAAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator!=, COMDAT
; _this$ = ecx

; 160  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 161  :     }

	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h
;	COMDAT ?clear_not_free@?$xr_vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear_not_free@?$xr_vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@@QAEXXZ PROC ; xr_vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::clear_not_free, COMDAT
; _this$ = ecx

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	push	ebx
	push	edi
	mov	edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1414 :         const pointer _Firstptr = _First._Ptr;

	mov	ebx, DWORD PTR [edi]

; 1415 :         const pointer _Lastptr  = _Last._Ptr;

	mov	eax, DWORD PTR [edi+4]

; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;
; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	ebx, eax
	je	SHORT $LN16@clear_not_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	push	esi
	mov	esi, eax
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [esi+ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [edi+4], eax
	pop	esi
$LN16@clear_not_:
	pop	edi
; File I:\Vitalya\mine\NSProjectX\xrCore\_stl_extensions.h

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	pop	ebx
	ret	0
?clear_not_free@?$xr_vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@@QAEXXZ ENDP ; xr_vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::clear_not_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ PROC ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::end, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1472 :         auto& _My_data = _Mypair._Myval2;
; 1473 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1474 :     }

	ret	4
?end@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ ENDP ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ PROC ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::begin, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1462 :         auto& _My_data = _Mypair._Myval2;
; 1463 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1464 :     }

	ret	4
?begin@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@XZ ENDP ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEAAPAUSlotItem@CDetailManager@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEAAPAUSlotItem@CDetailManager@@I@Z PROC ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::at, COMDAT
; _this$ = ecx

; 1570 :         auto& _My_data = _Mypair._Myval2;
; 1571 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	sub	eax, edx
	mov	ecx, DWORD PTR __Pos$[esp-4]
	sar	eax, 2
	cmp	eax, ecx
	jbe	SHORT $LN6@at

; 1573 :         }
; 1574 : 
; 1575 :         return _My_data._Myfirst[_Pos];

	lea	eax, DWORD PTR [edx+ecx*4]

; 1576 :     }

	ret	4
$LN6@at:

; 1572 :             _Xrange();

	call	?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Xrange
$LN4@at:
	int	3
?at@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@QAEAAPAUSlotItem@CDetailManager@@I@Z ENDP ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::at
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??C?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEPAUSGeometry@@XZ
_TEXT	SEGMENT
??C?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEPAUSGeometry@@XZ PROC ; resptr_core<SGeometry,resptrcode_geom>::operator->, COMDAT
; _this$ = ecx

; 71   : 	T *					operator->() const												{	return p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??C?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEPAUSGeometry@@XZ ENDP ; resptr_core<SGeometry,resptrcode_geom>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR ___param0$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator==, COMDAT
; _this$ = ecx

; 149  :         _Compat(_Right);
; 150  :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 151  :     }

	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++, COMDAT
; _this$ = ecx

; 68   : #if _ITERATOR_DEBUG_LEVEL != 0
; 69   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 70   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 71   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 72   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 73   : 
; 74   :         ++_Ptr;

	add	DWORD PTR [ecx], 4

; 75   :         return *this;

	mov	eax, ecx

; 76   :     }

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEABQAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEABQAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*, COMDAT
; _this$ = ecx

; 46   : #if _ITERATOR_DEBUG_LEVEL != 0
; 47   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 48   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 49   :         _STL_VERIFY(
; 50   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 51   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 52   : 
; 53   :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 54   :     }

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEABQAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 42   :         this->_Adopt(_Pvector);
; 43   :     }

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QAE@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@0@Z PROC ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::erase, COMDAT
; _this$ = ecx

; 1414 :         const pointer _Firstptr = _First._Ptr;
; 1415 :         const pointer _Lastptr  = _Last._Ptr;
; 1416 :         auto& _My_data          = _Mypair._Myval2;
; 1417 :         pointer& _Mylast        = _My_data._Mylast;

	mov	eax, DWORD PTR __Last$[esp-4]
	push	ebx
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ebx, ecx
	cmp	edi, eax

; 1418 : 
; 1419 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1420 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1421 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1422 :             "vector erase iterator outside range");
; 1423 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1424 : 
; 1425 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	je	SHORT $LN15@erase
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	push	esi
	mov	esi, DWORD PTR [ebx+4]
	sub	esi, eax

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1430 :             _Mylast = _Newlast;

	mov	DWORD PTR [ebx+4], eax

; 1431 :         }
; 1432 : 
; 1433 :         return iterator(_Firstptr, _STD addressof(_My_data));

	pop	esi
$LN15@erase:

; 1434 :     }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	ebx
	ret	12					; 0000000cH
?erase@?$vector@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@V?$xalloc@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@2@0@Z ENDP ; std::vector<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *,xalloc<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ PROC ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Xrange, COMDAT

; 1765 :         _Xout_of_range("invalid vector subscript");

	push	OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN3@Xrange:
	int	3
?_Xrange@?$vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@std@@CAXXZ ENDP ; std::vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 182  :         // test for compatible iterator pair
; 183  : #if _ITERATOR_DEBUG_LEVEL == 0
; 184  :         (void) _Right;
; 185  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 186  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 187  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 188  :     }

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >, COMDAT
; __Val$ = ecx

; 253  :     return __builtin_addressof(_Val);

	mov	eax, ecx

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_unchecked@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z PROC ; std::_Move_unchecked<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	esi

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]

; 4308 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	push	edi
	mov	edi, edx

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	edi, ecx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 4309 :     // move [_First, _Last) to [_Dest, ...)
; 4310 :     // note: _Move_unchecked has callers other than the move family
; 4311 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4312 : #ifdef __cpp_lib_is_constant_evaluated
; 4313 :         if (!_STD is_constant_evaluated())
; 4314 : #endif // __cpp_lib_is_constant_evaluated
; 4315 :         {
; 4316 :             return _Copy_memmove(_First, _Last, _Dest);

	pop	edi
	pop	esi

; 4317 :         }
; 4318 :     }
; 4319 : 
; 4320 :     for (; _First != _Last; ++_Dest, (void) ++_First) {
; 4321 :         *_Dest = _STD move(*_First);
; 4322 :     }
; 4323 : 
; 4324 :     return _Dest;
; 4325 : }

	ret	0
??$_Move_unchecked@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z ENDP ; std::_Move_unchecked<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z PROC ; std::_Copy_memmove<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	esi

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

	ret	0
??$_Copy_memmove@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@@std@@YAPAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *,xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@YA?A_PABQAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@Z
_TEXT	SEGMENT
??$_To_address@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@YA?A_PABQAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@Z PROC ; std::_To_address<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>, COMDAT
; __Val$ = ecx

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

	mov	eax, DWORD PTR [ecx]

; 3983 : }

	ret	0
??$_To_address@PAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@std@@YA?A_PABQAPAV?$xr_vector@PAUSlotItem@CDetailManager@@V?$xalloc@PAUSlotItem@CDetailManager@@@@@@@Z ENDP ; std::_To_address<xr_vector<CDetailManager::SlotItem *,xalloc<CDetailManager::SlotItem *> > * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ?_get@?$resptr_base@USDeclaration@@@@QBEPAUSDeclaration@@XZ
_TEXT	SEGMENT
?_get@?$resptr_base@USDeclaration@@@@QBEPAUSDeclaration@@XZ PROC ; resptr_base<SDeclaration>::_get, COMDAT
; _this$ = ecx

; 48   : 	ICF		T *			_get	() const							{	return p_;																					}

	mov	eax, DWORD PTR [ecx]
	ret	0
?_get@?$resptr_base@USDeclaration@@@@QBEPAUSDeclaration@@XZ ENDP ; resptr_base<SDeclaration>::_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File I:\Vitalya\mine\NSProjectX\xrCore\xr_resource.h
;	COMDAT ??D?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEAAUSGeometry@@XZ
_TEXT	SEGMENT
??D?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEAAUSGeometry@@XZ PROC ; resptr_core<SGeometry,resptrcode_geom>::operator*, COMDAT
; _this$ = ecx

; 70   : 	T &					operator*() const												{	return *p_;	}

	mov	eax, DWORD PTR [ecx]
	ret	0
??D?$resptr_core@USGeometry@@Uresptrcode_geom@@@@QBEAAUSGeometry@@XZ ENDP ; resptr_core<SGeometry,resptrcode_geom>::operator*
_TEXT	ENDS
END
